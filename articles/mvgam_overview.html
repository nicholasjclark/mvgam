<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="description" content="mvgam">
<title>Overview of the mvgam package • mvgam</title>
<!-- favicons --><link rel="icon" type="image/png" sizes="16x16" href="../favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="../favicon-32x32.png">
<link rel="apple-touch-icon" type="image/png" sizes="180x180" href="../apple-touch-icon.png">
<link rel="apple-touch-icon" type="image/png" sizes="120x120" href="../apple-touch-icon-120x120.png">
<link rel="apple-touch-icon" type="image/png" sizes="76x76" href="../apple-touch-icon-76x76.png">
<link rel="apple-touch-icon" type="image/png" sizes="60x60" href="../apple-touch-icon-60x60.png">
<script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet">
<script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous">
<!-- bootstrap-toc --><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@v1.0.1/dist/bootstrap-toc.min.js" integrity="sha256-4veVQbu7//Lk5TSmc7YV48MxtMy98e26cf5MrgZYnwo=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.11/clipboard.min.js" integrity="sha512-7O5pXpc0oCRrxk8RUfDYFgn0nO1t+jLuIOQdOMRp4APB7uZ4vSjspzp5y6YDtDs4VzUSTbWzBFZ/LKJhnyFOKw==" crossorigin="anonymous" referrerpolicy="no-referrer"></script><!-- search --><script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/6.4.6/fuse.js" integrity="sha512-zv6Ywkjyktsohkbp9bb45V6tEMoWhzFzXis+LrMehmJZZSys19Yxf1dopHx7WzIKxr5tK2dVcYmaCk2uqdjF4A==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/autocomplete.js/0.38.0/autocomplete.jquery.min.js" integrity="sha512-GU9ayf+66Xx2TmpxqJpliWbT5PiGYxpaG8rfnBEk1LL8l1KGkRShhngwdXK1UgqhAzWpZHSiYPc09/NwDQIGyg==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/mark.min.js" integrity="sha512-5CYOlHXGh6QpOFA/TeTylKLWfB3ftPsde7AnmhuitiTX4K5SqCLBeKro6sPS8ilsz1Q4NRx3v8Ko2IBiszzdww==" crossorigin="anonymous"></script><!-- pkgdown --><script src="../pkgdown.js"></script><link href="../extra.css" rel="stylesheet">
<meta property="og:title" content="Overview of the mvgam package">
<meta property="og:description" content="mvgam">
<meta property="og:image" content="https://nicholasjclark.github.io/mvgam/logo.png">
<!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>
    

    <nav class="navbar fixed-top navbar-dark navbar-expand-lg bg-primary" data-bs-theme="dark"><div class="container">
    
    <a class="navbar-brand me-2" href="../index.html">mvgam</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">1.1.5004</small>

    
    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="active nav-item dropdown">
  <a href="#" class="nav-link dropdown-toggle" data-bs-toggle="dropdown" role="button" aria-expanded="false" aria-haspopup="true" id="dropdown-articles">Articles</a>
  <div class="dropdown-menu" aria-labelledby="dropdown-articles">
    <a class="dropdown-item" href="../articles/data_in_mvgam.html">Formatting data for use in mvgam</a>
    <a class="dropdown-item" href="../articles/forecast_evaluation.html">Forecasting and forecast evaluation in mvgam</a>
    <a class="dropdown-item" href="../articles/mvgam_overview.html">Overview of the mvgam package</a>
    <a class="dropdown-item" href="../articles/nmixtures.html">N-mixtures in mvgam</a>
    <a class="dropdown-item" href="../articles/shared_states.html">Shared latent states in mvgam</a>
    <a class="dropdown-item" href="../articles/time_varying_effects.html">Time-varying effects in mvgam</a>
    <a class="dropdown-item" href="../articles/trend_formulas.html">State-Space models in mvgam</a>
  </div>
</li>
<li class="nav-item">
  <a class="nav-link" href="../reference/index.html">Reference</a>
</li>
<li class="nav-item">
  <a class="nav-link" href="../news/index.html">Changelog</a>
</li>
      </ul>
<form class="form-inline my-2 my-lg-0" role="search">
        <input type="search" class="form-control me-sm-2" aria-label="Toggle navigation" name="search-input" data-search-index="../search.json" id="search-input" placeholder="Search for" autocomplete="off">
</form>

      <ul class="navbar-nav">
<li class="nav-item">
  <a class="external-link nav-link" href="https://github.com/nicholasjclark/mvgam/" aria-label="github">
    <span class="fab fa fab fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
</div>

    
  </div>
</nav><div class="container template-article">




<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">
      <img src="../logo.png" class="logo" alt=""><h1>Overview of the mvgam package</h1>
                        <h4 data-toc-skip class="author">Nicholas J
Clark</h4>
            
            <h4 data-toc-skip class="date">2025-03-12</h4>
      
      <small class="dont-index">Source: <a href="https://github.com/nicholasjclark/mvgam/blob/HEAD/vignettes/mvgam_overview.Rmd" class="external-link"><code>vignettes/mvgam_overview.Rmd</code></a></small>
      <div class="d-none name"><code>mvgam_overview.Rmd</code></div>
    </div>

    
    
<p>The purpose of this vignette is to give a general overview of the
<code>mvgam</code> package and its primary functions.</p>
<div class="section level2">
<h2 id="dynamic-gams">Dynamic GAMs<a class="anchor" aria-label="anchor" href="#dynamic-gams"></a>
</h2>
<p><code>mvgam</code> is designed to propagate unobserved temporal
processes to capture latent dynamics in the observed time series. This
works in a state-space format, with the temporal <em>trend</em> evolving
independently of the observation process. An introduction to the package
and some worked examples are also shown in this seminar: <a href="https://www.youtube.com/watch?v=0zZopLlomsQ" target="_blank" class="external-link">Ecological Forecasting with Dynamic Generalized Additive
Models</a>. Briefly, assume <span class="math inline">\(\tilde{\boldsymbol{y}}_{i,t}\)</span> is the
conditional expectation of response variable <span class="math inline">\(\boldsymbol{i}\)</span> at time <span class="math inline">\(\boldsymbol{t}\)</span>. Assuming <span class="math inline">\(\boldsymbol{y_i}\)</span> is drawn from an
exponential distribution with an invertible link function, the linear
predictor for a multivariate Dynamic GAM can be written as:</p>
<p><span class="math display">\[for~i~in~1:N_{series}~...\]</span> <span class="math display">\[for~t~in~1:N_{timepoints}~...\]</span></p>
<p><span class="math display">\[g^{-1}(\tilde{\boldsymbol{y}}_{i,t})=\alpha_{i}+\sum\limits_{j=1}^J\boldsymbol{s}_{i,j,t}\boldsymbol{x}_{j,t}+\boldsymbol{Z}\boldsymbol{z}_{k,t}\,,\]</span>
Here <span class="math inline">\(\alpha\)</span> are the unknown
intercepts, the <span class="math inline">\(\boldsymbol{s}\)</span>’s
are unknown smooth functions of covariates (<span class="math inline">\(\boldsymbol{x}\)</span>’s), which can potentially
vary among the response series, and <span class="math inline">\(\boldsymbol{z}\)</span> are dynamic latent
processes. Each smooth function <span class="math inline">\(\boldsymbol{s_j}\)</span> is composed of basis
expansions whose coefficients, which must be estimated, control the
functional relationship between <span class="math inline">\(\boldsymbol{x}_{j}\)</span> and <span class="math inline">\(g^{-1}(\tilde{\boldsymbol{y}})\)</span>. The size
of the basis expansion limits the smooth’s potential complexity. A
larger set of basis functions allows greater flexibility. For more
information on GAMs and how they can smooth through data, see <a href="https://ecogambler.netlify.app/blog/interpreting-gams/" target="_blank" class="external-link">this blogpost on how to interpret nonlinear effects from
Generalized Additive Models</a>. Latent processes are captured with
<span class="math inline">\(\boldsymbol{Z}\boldsymbol{z}_{i,t}\)</span>,
where <span class="math inline">\(\boldsymbol{Z}\)</span> is an <span class="math inline">\(i~by~k\)</span> matrix of loading coefficients
(which can be fixed or a combination of fixed and freely estimated
parameters) and <span class="math inline">\(\boldsymbol{z}_{k,t}\)</span> are a set of <span class="math inline">\(K\)</span> latent factors that can also include
their own GAM linear predictors (see the <a href="https://nicholasjclark.github.io/mvgam/articles/trend_formulas.html">State-Space
models vignette</a>), the <a href="https://nicholasjclark.github.io/mvgam/articles/nmixtures.html">N-mixtures
vignette</a> and the example in <a href="https://nicholasjclark.github.io/mvgam/reference/jsdgam.html"><code>jsdgam</code></a>
to get an idea of how flexible these processes can be.</p>
<p>Several advantages of GAMs are that they can model a diversity of
response families, including discrete distributions (i.e. Poisson,
Negative Binomial, Gamma) that accommodate common ecological features
such as zero-inflation or overdispersion, and that they can be
formulated to include hierarchical smoothing for multivariate responses.
<code>mvgam</code> supports a number of different observation families,
which are summarized below:</p>
</div>
<div class="section level2">
<h2 id="supported-observation-families">Supported observation families<a class="anchor" aria-label="anchor" href="#supported-observation-families"></a>
</h2>
<table class="table">
<colgroup>
<col width="16%">
<col width="15%">
<col width="46%">
<col width="20%">
</colgroup>
<thead><tr class="header">
<th align="center">Distribution</th>
<th align="center">Function</th>
<th align="center">Support</th>
<th align="center">Extra parameter(s)</th>
</tr></thead>
<tbody>
<tr class="odd">
<td align="center">Gaussian (identity link)</td>
<td align="center"><code><a href="https://rdrr.io/r/stats/family.html" class="external-link">gaussian()</a></code></td>
<td align="center">Real values in <span class="math inline">\((-\infty,
\infty)\)</span>
</td>
<td align="center"><span class="math inline">\(\sigma\)</span></td>
</tr>
<tr class="even">
<td align="center">Student’s T (identity link)</td>
<td align="center"><code>student-t()</code></td>
<td align="center">Heavy-tailed real values in <span class="math inline">\((-\infty, \infty)\)</span>
</td>
<td align="center">
<span class="math inline">\(\sigma\)</span>, <span class="math inline">\(\nu\)</span>
</td>
</tr>
<tr class="odd">
<td align="center">LogNormal (identity link)</td>
<td align="center"><code><a href="../reference/mvgam_families.html">lognormal()</a></code></td>
<td align="center">Positive real values in <span class="math inline">\([0, \infty)\)</span>
</td>
<td align="center"><span class="math inline">\(\sigma\)</span></td>
</tr>
<tr class="even">
<td align="center">Gamma (log link)</td>
<td align="center"><code><a href="https://rdrr.io/r/stats/family.html" class="external-link">Gamma()</a></code></td>
<td align="center">Positive real values in <span class="math inline">\([0, \infty)\)</span>
</td>
<td align="center"><span class="math inline">\(\alpha\)</span></td>
</tr>
<tr class="odd">
<td align="center">Beta (logit link)</td>
<td align="center"><code><a href="../reference/mvgam_families.html">betar()</a></code></td>
<td align="center">Real values (proportional) in <span class="math inline">\([0,1]\)</span>
</td>
<td align="center"><span class="math inline">\(\phi\)</span></td>
</tr>
<tr class="even">
<td align="center">Bernoulli (logit link)</td>
<td align="center"><code><a href="../reference/mvgam_families.html">bernoulli()</a></code></td>
<td align="center">Binary data in <span class="math inline">\({0,1}\)</span>
</td>
<td align="center">-</td>
</tr>
<tr class="odd">
<td align="center">Poisson (log link)</td>
<td align="center"><code><a href="https://rdrr.io/r/stats/family.html" class="external-link">poisson()</a></code></td>
<td align="center">Non-negative integers in <span class="math inline">\((0,1,2,...)\)</span>
</td>
<td align="center">-</td>
</tr>
<tr class="even">
<td align="center">Negative Binomial2 (log link)</td>
<td align="center"><code><a href="../reference/mvgam_families.html">nb()</a></code></td>
<td align="center">Non-negative integers in <span class="math inline">\((0,1,2,...)\)</span>
</td>
<td align="center"><span class="math inline">\(\phi\)</span></td>
</tr>
<tr class="odd">
<td align="center">Binomial (logit link)</td>
<td align="center"><code><a href="https://rdrr.io/r/stats/family.html" class="external-link">binomial()</a></code></td>
<td align="center">Non-negative integers in <span class="math inline">\((0,1,2,...)\)</span>
</td>
<td align="center">-</td>
</tr>
<tr class="even">
<td align="center">Beta-Binomial (logit link)</td>
<td align="center"><code><a href="../reference/mvgam_families.html">beta_binomial()</a></code></td>
<td align="center">Non-negative integers in <span class="math inline">\((0,1,2,...)\)</span>
</td>
<td align="center"><span class="math inline">\(\phi\)</span></td>
</tr>
<tr class="odd">
<td align="center">Poisson Binomial N-mixture (log link)</td>
<td align="center"><code><a href="../reference/mvgam_families.html">nmix()</a></code></td>
<td align="center">Non-negative integers in <span class="math inline">\((0,1,2,...)\)</span>
</td>
<td align="center">-</td>
</tr>
</tbody>
</table>
<p>For all supported observation families, any extra parameters that
need to be estimated (i.e. the <span class="math inline">\(\sigma\)</span> in a Gaussian model or the <span class="math inline">\(\phi\)</span> in a Negative Binomial model) are by
default estimated independently for each series. However, users can opt
to force all series to share extra observation parameters using
<code>share_obs_params = TRUE</code> in <code><a href="../reference/mvgam.html">mvgam()</a></code>. Note that
default link functions cannot currently be changed.</p>
</div>
<div class="section level2">
<h2 id="supported-temporal-dynamic-processes">Supported temporal dynamic processes<a class="anchor" aria-label="anchor" href="#supported-temporal-dynamic-processes"></a>
</h2>
<p>As stated above, the latent processes can take a wide variety of
forms, some of which can be multivariate to allow the different
observational variables to interact or be correlated. When using the
<code><a href="../reference/mvgam.html">mvgam()</a></code> function, the user chooses between different
process models with the <code>trend_model</code> argument. Available
process models are described in detail below.</p>
<div class="section level3">
<h3 id="correlated-multivariate-processes">Correlated multivariate processes<a class="anchor" aria-label="anchor" href="#correlated-multivariate-processes"></a>
</h3>
<p>If more than one observational unit (usually referred to as ‘series’)
is included in <code>data</code> <span class="math inline">\((N_{series}
&gt; 1)\)</span>, use <code>trend_model = ZMVN()</code> to set up a
model where the outcomes for different observational units may be
correlated according to:</p>
<p><span class="math display">\[\begin{align*}
z_{t} &amp; \sim \text{MVNormal}(0, \Sigma) \end{align*}\]</span></p>
<p>The covariance matrix <span class="math inline">\(\Sigma\)</span>
will capture potentially correlated process errors. It is parameterised
using a Cholesky factorization, which requires priors on the
series-level variances <span class="math inline">\(\sigma\)</span> and
on the strength of correlations using <code>Stan</code>’s
<code>lkj_corr_cholesky</code> distribution. Note that this
<code>trend_model</code> does not assume that measurements occur over
<em>time</em>, as users can specify what variable in the
<code>data</code> represents the unit of analysis (i.e. outcomes could
be counts of different <em>species</em> across different <em>sites</em>
or <em>regions</em>, for example; see <a href="https://nicholasjclark.github.io/mvgam/reference/ZMVN.html">`?ZMVN()</a>
for guidelines).</p>
</div>
<div class="section level3">
<h3 id="independent-random-walks">Independent Random Walks<a class="anchor" aria-label="anchor" href="#independent-random-walks"></a>
</h3>
<p>Use <code>trend_model = 'RW'</code> or
<code>trend_model = RW()</code> to set up a model where each series in
<code>data</code> has independent latent temporal dynamics of the
form:</p>
<p><span class="math display">\[\begin{align*}
z_{i,t} &amp; \sim \text{Normal}(z_{i,t-1}, \sigma_i)
\end{align*}\]</span></p>
<p>Process error parameters <span class="math inline">\(\sigma\)</span>
are modeled independently for each series. If a moving average process
is required, use <code>trend_model = RW(ma = TRUE)</code> to set up the
following:</p>
<p><span class="math display">\[\begin{align*}
z_{i,t} &amp; = z_{i,t-1} + \theta_i * error_{i,t-1} + error_{i,t} \\
error_{i,t} &amp; \sim \text{Normal}(0, \sigma_i)
\end{align*}\]</span></p>
<p>Moving average coefficients <span class="math inline">\(\theta\)</span> are independently estimated for
each series and will be forced to be stationary by default <span class="math inline">\((abs(\theta)&lt;1)\)</span>. Only moving averages
of order <span class="math inline">\(q=1\)</span> are currently
allowed.</p>
</div>
<div class="section level3">
<h3 id="multivariate-random-walks">Multivariate Random Walks<a class="anchor" aria-label="anchor" href="#multivariate-random-walks"></a>
</h3>
<p>If more than one series is included in <code>data</code> <span class="math inline">\((N_{series} &gt; 1)\)</span>, a multivariate
Random Walk can be set up using
<code>trend_model = RW(cor = TRUE)</code>, resulting in the
following:</p>
<p><span class="math display">\[\begin{align*}
z_{t} &amp; \sim \text{MVNormal}(z_{t-1}, \Sigma)
\end{align*}\]</span></p>
<p>Where the latent process estimate <span class="math inline">\(z_t\)</span> now takes the form of a vector. The
covariance matrix <span class="math inline">\(\Sigma\)</span> will
capture contemporaneously correlated process errors. It is parameterised
using a Cholesky factorization, which requires priors on the
series-level variances <span class="math inline">\(\sigma\)</span> and
on the strength of correlations using <code>Stan</code>’s
<code>lkj_corr_cholesky</code> distribution.</p>
<p>Moving average terms can also be included for multivariate random
walks, in which case the moving average coefficients <span class="math inline">\(\theta\)</span> will be parameterised as an <span class="math inline">\(N_{series} * N_{series}\)</span> matrix</p>
</div>
<div class="section level3">
<h3 id="autoregressive-processes">Autoregressive processes<a class="anchor" aria-label="anchor" href="#autoregressive-processes"></a>
</h3>
<p>Autoregressive models up to <span class="math inline">\(p=3\)</span>,
in which the autoregressive coefficients are estimated independently for
each series, can be used by specifying <code>trend_model = 'AR1'</code>,
<code>trend_model = 'AR2'</code>, <code>trend_model = 'AR3'</code>, or
<code>trend_model = AR(p = 1, 2, or 3)</code>. For example, a univariate
AR(1) model takes the form:</p>
<p><span class="math display">\[\begin{align*}
z_{i,t} &amp; \sim \text{Normal}(ar1_i * z_{i,t-1}, \sigma_i)
\end{align*}\]</span></p>
<p>All options are the same as for Random Walks, but additional options
will be available for placing priors on the autoregressive coefficients.
By default, these coefficients will not be forced into stationarity, but
users can impose this restriction by changing the upper and lower bounds
on their priors. See <code><a href="../reference/get_mvgam_priors.html">?get_mvgam_priors</a></code> for more
details.</p>
</div>
<div class="section level3">
<h3 id="vector-autoregressive-processes">Vector Autoregressive processes<a class="anchor" aria-label="anchor" href="#vector-autoregressive-processes"></a>
</h3>
<p>A Vector Autoregression of order <span class="math inline">\(p=1\)</span> can be specified if <span class="math inline">\(N_{series} &gt; 1\)</span> using
<code>trend_model = 'VAR1'</code> or <code>trend_model = VAR()</code>. A
VAR(1) model takes the form:</p>
<p><span class="math display">\[\begin{align*}
z_{t} &amp; \sim \text{Normal}(A * z_{t-1}, \Sigma)
\end{align*}\]</span></p>
<p>Where <span class="math inline">\(A\)</span> is an <span class="math inline">\(N_{series} * N_{series}\)</span> matrix of
autoregressive coefficients in which the diagonals capture lagged
self-dependence (i.e. the effect of a process at time <span class="math inline">\(t\)</span> on its own estimate at time <span class="math inline">\(t+1\)</span>), while off-diagonals capture lagged
cross-dependence (i.e. the effect of a process at time <span class="math inline">\(t\)</span> on the process for another series at
time <span class="math inline">\(t+1\)</span>). By default, the
covariance matrix <span class="math inline">\(\Sigma\)</span> will
assume no process error covariance by fixing the off-diagonals to <span class="math inline">\(0\)</span>. To allow for correlated errors, use
<code>trend_model = 'VAR1cor'</code> or
<code>trend_model = VAR(cor = TRUE)</code>. A moving average of order
<span class="math inline">\(q=1\)</span> can also be included using
<code>trend_model = VAR(ma = TRUE, cor = TRUE)</code>.</p>
<p>Note that for all VAR models, stationarity of the process is enforced
with a structured prior distribution that is described in detail in <a href="https://www.tandfonline.com/doi/full/10.1080/10618600.2022.2079648" class="external-link">Heaps
2022</a></p>
<p>Heaps, Sarah E. “<a href="https://www.tandfonline.com/doi/full/10.1080/10618600.2022.2079648" class="external-link">Enforcing
stationarity through the prior in vector autoregressions.</a>”
<em>Journal of Computational and Graphical Statistics</em> 32.1 (2023):
74-83.</p>
</div>
<div class="section level3">
<h3 id="hierarchical-processes">Hierarchical processes<a class="anchor" aria-label="anchor" href="#hierarchical-processes"></a>
</h3>
<p>Several of the above-mentioned <code>trend_model</code> options can
be modified to account for grouping structures in <code>data</code> by
setting up hierarchical latent processes. If an optional grouping
variable (<code>gr</code>; which must be a <code>factor</code> in the
supplied <code>data</code>) exists, users can model hierarchical
residual correlation structures. where the residual correlations for a
specific level of <code>gr</code> are modelled hierarchically:</p>
<p><span class="math display">\[\begin{align*}
\Omega_{group} &amp; = \alpha_{cor}\Omega_{global} + (1 -
\alpha_{cor})\Omega_{group, local} \end{align*}\]</span></p>
<p>where <span class="math inline">\(\Omega_{global}\)</span> is a
<em>global</em> correlation matrix, <span class="math inline">\(\Omega_{group, local}\)</span> is a <em>local
deviation</em> correlation matrix and <span class="math inline">\(\alpha_{cor}\)</span> is a weighting parameter
controlling how strongly the local correlation matrix <span class="math inline">\(\Omega_{group}\)</span> (i.e. the derived
correlation matrix that will be used for each level of the grouping
factor <code>gr</code>) is shrunk towards the global correlation matrix
<span class="math inline">\(\Omega_{global}\)</span> (larger values of
<span class="math inline">\(\alpha_{cor}\)</span> indicate a greater
degree of shrinkage, i.e. a greater degree of partial pooling). This
option is valuable for many types of designs where the same
observational units (i.e. <em>financial assets</em> or <em>species</em>,
for example) are measured in different strata (i.e. <em>regions</em>,
<em>countries</em> or <em>experimental units</em>, for example).
Currently hierarchical correlations can be included for
<code><a href="../reference/RW.html">AR()</a></code>, <code><a href="../reference/RW.html">VAR()</a></code> or <code><a href="../reference/ZMVN.html">ZMVN()</a></code>
<code>trend_model</code> options.</p>
</div>
<div class="section level3">
<h3 id="gaussian-processes">Gaussian Processes<a class="anchor" aria-label="anchor" href="#gaussian-processes"></a>
</h3>
<p>The final option for modelling temporal dynamics is to use a Gaussian
Process with squared exponential kernel. These are set up independently
for each series (there is currently no multivariate GP option), using
<code>trend_model = 'GP'</code>. The dynamics for each latent process
are modelled as:</p>
<p><span class="math display">\[\begin{align*}
z &amp; \sim \text{MVNormal}(0, \Sigma_{error}) \\
\Sigma_{error}[t_i, t_j] &amp; = \alpha^2 * exp(-0.5 * ((|t_i - t_j| /
\rho))^2) \end{align*}\]</span></p>
<p>The latent dynamic process evolves from a complex, high-dimensional
Multivariate Normal distribution which depends on <span class="math inline">\(\rho\)</span> (often called the length scale
parameter) to control how quickly the correlations between the model’s
errors decay as a function of time. For these models, covariance decays
exponentially fast with the squared distance (in time) between the
observations. The functions also depend on a parameter <span class="math inline">\(\alpha\)</span>, which controls the marginal
variability of the temporal function at all points; in other words it
controls how much the GP term contributes to the linear predictor.
<code>mvgam</code> capitalizes on some advances that allow GPs to be
approximated using Hilbert space basis functions, which <a href="https://link.springer.com/article/10.1007/s11222-022-10167-2" target="_blank" class="external-link">considerably speed up computation at little cost to
accuracy or prediction performance</a>.</p>
</div>
<div class="section level3">
<h3 id="piecewise-logistic-and-linear-trends">Piecewise logistic and linear trends<a class="anchor" aria-label="anchor" href="#piecewise-logistic-and-linear-trends"></a>
</h3>
<p>Modeling growth for many types of time series is often similar to
modeling population growth in natural ecosystems, where there series
exhibits nonlinear growth that saturates at some particular carrying
capacity. The logistic trend model available in {<code>mvgam</code>}
allows for a time-varying capacity <span class="math inline">\(C(t)\)</span> as well as a non-constant growth
rate. Changes in the base growth rate <span class="math inline">\(k\)</span> are incorporated by explicitly defining
changepoints throughout the training period where the growth rate is
allowed to vary. The changepoint vector <span class="math inline">\(a\)</span> is represented as a vector of
<code>1</code>s and <code>0</code>s, and the rate of growth at time
<span class="math inline">\(t\)</span> is represented as <span class="math inline">\(k+a(t)^T\delta\)</span>. Potential changepoints
are selected uniformly across the training period, and the number of
changepoints, as well as the flexibility of the potential rate changes
at these changepoints, can be controlled using
<code>trend_model = PW()</code>. The full piecewise logistic growth
model is then:</p>
<p><span class="math display">\[\begin{align*}
z_t &amp; = \frac{C_t}{1 +
\exp(-(k+a(t)^T\delta)(t-(m+a(t)^T\gamma)))}  \end{align*}\]</span></p>
<p>For time series that do not appear to exhibit saturating growth, a
piece-wise constant rate of growth can often provide a useful trend
model. The piecewise linear trend is defined as:</p>
<p><span class="math display">\[\begin{align*}
z_t &amp; = (k+a(t)^T\delta)t +
(m+a(t)^T\gamma)  \end{align*}\]</span></p>
<p>In both trend models, <span class="math inline">\(m\)</span> is an
offset parameter that controls the trend intercept. Because of this
parameter, it is not recommended that you include an intercept in your
observation formula because this will not be identifiable. You can read
about the full description of piecewise linear and logistic trends <a href="https://www.tandfonline.com/doi/abs/10.1080/00031305.2017.1380080" target="_blank" class="external-link">in this paper by Taylor and Letham</a>.</p>
<p>Sean J. Taylor and Benjamin Letham. “<a href="https://www.tandfonline.com/doi/full/10.1080/00031305.2017.1380080" class="external-link">Forecasting
at scale.</a>” <em>The American Statistician</em> 72.1 (2018):
37-45.</p>
</div>
<div class="section level3">
<h3 id="continuous-time-ar1-processes">Continuous time AR(1) processes<a class="anchor" aria-label="anchor" href="#continuous-time-ar1-processes"></a>
</h3>
<p>Most trend models in the <code><a href="../reference/mvgam.html">mvgam()</a></code> function expect time to
be measured in regularly-spaced, discrete intervals (i.e. one
measurement per week, or one per year for example). But some time series
are taken at irregular intervals and we’d like to model autoregressive
properties of these. The <code>trend_model = CAR()</code> can be useful
to set up these models, which currently only support autoregressive
processes of order <code>1</code>. The evolution of the latent dynamic
process follows the form:</p>
<p><span class="math display">\[\begin{align*}
z_{i,t} &amp; \sim \text{Normal}(ar1_i^{distance} * z_{i,t-1}, \sigma_i)
\end{align*}\]</span></p>
<p>Where <span class="math inline">\(distance\)</span> is a vector of
non-negative measurements of the time differences between successive
observations. See the <strong>Examples</strong> section in
<code><a href="../reference/RW.html">?CAR</a></code> for an illustration of how to set these models up.</p>
</div>
</div>
<div class="section level2">
<h2 id="regression-formulae">Regression formulae<a class="anchor" aria-label="anchor" href="#regression-formulae"></a>
</h2>
<p><code>mvgam</code> supports an observation model regression formula,
built off the <code>mgcv</code> package, as well as an optional process
model regression formula. The formulae supplied to are exactly like
those supplied to <code><a href="https://rdrr.io/r/stats/glm.html" class="external-link">glm()</a></code> except that smooth terms,
<code><a href="https://rdrr.io/pkg/mgcv/man/s.html" class="external-link">s()</a></code>, <code><a href="https://rdrr.io/pkg/mgcv/man/te.html" class="external-link">te()</a></code>, <code><a href="https://rdrr.io/pkg/mgcv/man/te.html" class="external-link">ti()</a></code> and
<code><a href="https://rdrr.io/pkg/mgcv/man/t2.html" class="external-link">t2()</a></code>, time-varying effects using <code><a href="../reference/dynamic.html">dynamic()</a></code>,
monotonically increasing (using <code>s(x, bs = 'moi')</code>) or
decreasing splines (using <code>s(x, bs = 'mod')</code>; see
<code><a href="../reference/monotonic.html">?smooth.construct.moi.smooth.spec</a></code> for details), as well as
Gaussian Process functions using <code><a href="https://paulbuerkner.com/brms/reference/gp.html" class="external-link">gp()</a></code>, can be added to the
right hand side (and <code>.</code> is not supported in
<code>mvgam</code> formulae). See <code><a href="../reference/mvgam_formulae.html">?mvgam_formulae</a></code> for more
guidance.</p>
<p>For setting up State-Space models, the optional process model formula
can be used (see <a href="https://nicholasjclark.github.io/mvgam/articles/trend_formulas.html">the
State-Space model vignette</a> and <a href="https://nicholasjclark.github.io/mvgam/articles/trend_formulas.html">the
shared latent states vignette</a> for guidance on using trend
formulae).</p>
</div>
<div class="section level2">
<h2 id="example-time-series-data">Example time series data<a class="anchor" aria-label="anchor" href="#example-time-series-data"></a>
</h2>
<p>The ‘portal_data’ object contains time series of rodent captures from
the Portal Project, <a href="https://portal.weecology.org/" target="_blank" class="external-link">a long-term monitoring study based near the town of
Portal, Arizona</a>. Researchers have been operating a standardized set
of baited traps within 24 experimental plots at this site since the
1970’s. Sampling follows the lunar monthly cycle, with observations
occurring on average about 28 days apart. However, missing observations
do occur due to difficulties accessing the site (weather events, COVID
disruptions etc…). You can read about the full sampling protocol <a href="https://www.biorxiv.org/content/10.1101/332783v3.full" target="_blank" class="external-link">in this preprint by Ernest et al on the Biorxiv</a>.</p>
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/utils/data.html" class="external-link">data</a></span><span class="op">(</span><span class="st">"portal_data"</span><span class="op">)</span></span></code></pre></div>
<p>As the data come pre-loaded with the <code>mvgam</code> package, you
can read a little about it in the help page using
<code><a href="../reference/portal_data.html">?portal_data</a></code>. Before working with data, it is important to
inspect how the data are structured, first using <code>head</code>:</p>
<div class="sourceCode" id="cb2"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/utils/head.html" class="external-link">head</a></span><span class="op">(</span><span class="va">portal_data</span><span class="op">)</span></span>
<span><span class="co">#&gt;   time series captures  ndvi_ma12    mintemp</span></span>
<span><span class="co">#&gt; 1    1     DM       20 -0.1721441 -0.7963381</span></span>
<span><span class="co">#&gt; 2    1     DO        2 -0.1721441 -0.7963381</span></span>
<span><span class="co">#&gt; 3    1     PB        0 -0.1721441 -0.7963381</span></span>
<span><span class="co">#&gt; 4    1     PP        0 -0.1721441 -0.7963381</span></span>
<span><span class="co">#&gt; 5    2     DM       NA -0.2373635 -1.3347160</span></span>
<span><span class="co">#&gt; 6    2     DO       NA -0.2373635 -1.3347160</span></span></code></pre></div>
<p>But the <code>glimpse</code> function in <code>dplyr</code> is also
useful for understanding how variables are structured</p>
<div class="sourceCode" id="cb3"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu">dplyr</span><span class="fu">::</span><span class="fu"><a href="https://pillar.r-lib.org/reference/glimpse.html" class="external-link">glimpse</a></span><span class="op">(</span><span class="va">portal_data</span><span class="op">)</span></span>
<span><span class="co">#&gt; Rows: 320</span></span>
<span><span class="co">#&gt; Columns: 5</span></span>
<span><span class="co">#&gt; $ time      <span style="color: #949494; font-style: italic;">&lt;int&gt;</span> 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, …</span></span>
<span><span class="co">#&gt; $ series    <span style="color: #949494; font-style: italic;">&lt;fct&gt;</span> DM, DO, PB, PP, DM, DO, PB, PP, DM, DO, PB, PP, DM, DO, PB, …</span></span>
<span><span class="co">#&gt; $ captures  <span style="color: #949494; font-style: italic;">&lt;int&gt;</span> 20, 2, 0, 0, <span style="color: #BB0000;">NA</span>, <span style="color: #BB0000;">NA</span>, <span style="color: #BB0000;">NA</span>, <span style="color: #BB0000;">NA</span>, 36, 5, 0, 0, 40, 3, 0, 1, 29, 3…</span></span>
<span><span class="co">#&gt; $ ndvi_ma12 <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span> -0.172144125, -0.172144125, -0.172144125, -0.172144125, -0.2…</span></span>
<span><span class="co">#&gt; $ mintemp   <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span> -0.79633807, -0.79633807, -0.79633807, -0.79633807, -1.33471…</span></span></code></pre></div>
<p>We will focus analyses on the time series of captures for one
specific rodent species, the Desert Pocket Mouse <em>Chaetodipus
penicillatus</em>. This species is interesting in that it goes into a
kind of “hibernation” during the colder months, leading to very low
captures during the winter period</p>
</div>
<div class="section level2">
<h2 id="manipulating-data-for-modelling">Manipulating data for modelling<a class="anchor" aria-label="anchor" href="#manipulating-data-for-modelling"></a>
</h2>
<p>Manipulating the data into a ‘long’ format is necessary for modelling
in <code>mvgam</code>. By ‘long’ format, we mean that each
<code>series x time</code> observation needs to have its own entry in
the <code>dataframe</code> or <code>list</code> object that we wish to
use as data for modelling. A simple example can be viewed by simulating
data using the <code>sim_mvgam</code> function. See
<code><a href="../reference/sim_mvgam.html">?sim_mvgam</a></code> for more details</p>
<div class="sourceCode" id="cb4"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">data</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/sim_mvgam.html">sim_mvgam</a></span><span class="op">(</span>n_series <span class="op">=</span> <span class="fl">4</span>, T <span class="op">=</span> <span class="fl">24</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/head.html" class="external-link">head</a></span><span class="op">(</span><span class="va">data</span><span class="op">$</span><span class="va">data_train</span>, <span class="fl">12</span><span class="op">)</span></span>
<span><span class="co">#&gt;    y season year   series time</span></span>
<span><span class="co">#&gt; 1  0      1    1 series_1    1</span></span>
<span><span class="co">#&gt; 2  0      1    1 series_2    1</span></span>
<span><span class="co">#&gt; 3  3      1    1 series_3    1</span></span>
<span><span class="co">#&gt; 4  0      1    1 series_4    1</span></span>
<span><span class="co">#&gt; 5  3      2    1 series_1    2</span></span>
<span><span class="co">#&gt; 6  3      2    1 series_2    2</span></span>
<span><span class="co">#&gt; 7  3      2    1 series_3    2</span></span>
<span><span class="co">#&gt; 8  5      2    1 series_4    2</span></span>
<span><span class="co">#&gt; 9  1      3    1 series_1    3</span></span>
<span><span class="co">#&gt; 10 0      3    1 series_2    3</span></span>
<span><span class="co">#&gt; 11 4      3    1 series_3    3</span></span>
<span><span class="co">#&gt; 12 5      3    1 series_4    3</span></span></code></pre></div>
<p>Notice how we have four different time series in these simulated
data, but we do not spread the outcome values into different columns.
Rather, there is only a single column for the outcome variable, labelled
<code>y</code> in these simulated data. We also must supply a variable
labelled <code>time</code> to ensure the modelling software knows how to
arrange the time series when building models. This setup still allows us
to formulate multivariate time series models, as you can see in the <a href="https://nicholasjclark.github.io/mvgam/articles/trend_formulas.html">State-Space
vignette</a>. Below are the steps needed to shape our
<code>portal_data</code> object into the correct form. First, we create
a <code>time</code> variable, select the column representing counts of
our target species (<code>PP</code>), and select appropriate variables
that we can use as predictors</p>
<div class="sourceCode" id="cb5"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">portal_data</span> <span class="op"><a href="../reference/pipe.html">%&gt;%</a></span></span>
<span>  <span class="co"># Filter the data to only contain captures of the 'PP' </span></span>
<span>  <span class="fu">dplyr</span><span class="fu">::</span><span class="fu"><a href="https://dplyr.tidyverse.org/reference/filter.html" class="external-link">filter</a></span><span class="op">(</span><span class="va">series</span> <span class="op">==</span> <span class="st">'PP'</span><span class="op">)</span> <span class="op"><a href="../reference/pipe.html">%&gt;%</a></span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/droplevels.html" class="external-link">droplevels</a></span><span class="op">(</span><span class="op">)</span> <span class="op"><a href="../reference/pipe.html">%&gt;%</a></span></span>
<span>  <span class="fu">dplyr</span><span class="fu">::</span><span class="fu"><a href="https://dplyr.tidyverse.org/reference/mutate.html" class="external-link">mutate</a></span><span class="op">(</span>count <span class="op">=</span> <span class="va">captures</span><span class="op">)</span> <span class="op"><a href="../reference/pipe.html">%&gt;%</a></span></span>
<span>  <span class="co"># Add a 'year' variable</span></span>
<span>  <span class="fu">dplyr</span><span class="fu">::</span><span class="fu"><a href="https://dplyr.tidyverse.org/reference/mutate.html" class="external-link">mutate</a></span><span class="op">(</span>year <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/sort.html" class="external-link">sort</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="fl">8</span>, <span class="fl">12</span><span class="op">)</span><span class="op">)</span><span class="op">[</span><span class="va">time</span><span class="op">]</span><span class="op">)</span> <span class="op"><a href="../reference/pipe.html">%&gt;%</a></span></span>
<span>  <span class="co"># Select the variables of interest to keep in the model_data</span></span>
<span>  <span class="fu">dplyr</span><span class="fu">::</span><span class="fu"><a href="https://dplyr.tidyverse.org/reference/select.html" class="external-link">select</a></span><span class="op">(</span><span class="va">series</span>, <span class="va">year</span>, <span class="va">time</span>, <span class="va">count</span>, <span class="va">mintemp</span>, <span class="va">ndvi_ma12</span><span class="op">)</span> <span class="op">-&gt;</span> <span class="va">model_data</span></span></code></pre></div>
<p>The data now contain six variables:<br><code>series</code>, a factor indexing which time series each
observation belongs to<br><code>year</code>, the year of sampling<br><code>time</code>, the indicator of which time step each observation
belongs to<br><code>count</code>, the response variable representing the number of
captures of the species <code>PP</code> in each sampling
observation<br><code>mintemp</code>, the monthly average minimum temperature at each
time step<br><code>ndvi_ma12</code>, a 12-month moving average of the monthly
Normalized Difference Vegetation Index at each time step</p>
<p>Now check the data structure again</p>
<div class="sourceCode" id="cb6"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/utils/head.html" class="external-link">head</a></span><span class="op">(</span><span class="va">model_data</span><span class="op">)</span></span>
<span><span class="co">#&gt;   series year time count     mintemp   ndvi_ma12</span></span>
<span><span class="co">#&gt; 1     PP    1    1     0 -0.79633807 -0.17214413</span></span>
<span><span class="co">#&gt; 2     PP    1    2    NA -1.33471597 -0.23736348</span></span>
<span><span class="co">#&gt; 3     PP    1    3     0 -1.24166462 -0.21212064</span></span>
<span><span class="co">#&gt; 4     PP    1    4     1 -1.08048145 -0.16043812</span></span>
<span><span class="co">#&gt; 5     PP    1    5     7 -0.42447625 -0.08267729</span></span>
<span><span class="co">#&gt; 6     PP    1    6     7  0.06532892 -0.03692877</span></span></code></pre></div>
<div class="sourceCode" id="cb7"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu">dplyr</span><span class="fu">::</span><span class="fu"><a href="https://pillar.r-lib.org/reference/glimpse.html" class="external-link">glimpse</a></span><span class="op">(</span><span class="va">model_data</span><span class="op">)</span></span>
<span><span class="co">#&gt; Rows: 80</span></span>
<span><span class="co">#&gt; Columns: 6</span></span>
<span><span class="co">#&gt; $ series    <span style="color: #949494; font-style: italic;">&lt;fct&gt;</span> PP, PP, PP, PP, PP, PP, PP, PP, PP, PP, PP, PP, PP, PP, PP, …</span></span>
<span><span class="co">#&gt; $ year      <span style="color: #949494; font-style: italic;">&lt;int&gt;</span> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, …</span></span>
<span><span class="co">#&gt; $ time      <span style="color: #949494; font-style: italic;">&lt;int&gt;</span> 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 1…</span></span>
<span><span class="co">#&gt; $ count     <span style="color: #949494; font-style: italic;">&lt;int&gt;</span> 0, <span style="color: #BB0000;">NA</span>, 0, 1, 7, 7, 8, 8, 4, <span style="color: #BB0000;">NA</span>, 0, 0, 0, 0, 0, 0, <span style="color: #BB0000;">NA</span>, 2, 4, …</span></span>
<span><span class="co">#&gt; $ mintemp   <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span> -0.79633807, -1.33471597, -1.24166462, -1.08048145, -0.42447…</span></span>
<span><span class="co">#&gt; $ ndvi_ma12 <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span> -0.172144125, -0.237363477, -0.212120638, -0.160438125, -0.0…</span></span></code></pre></div>
<p>You can also summarize multiple variables, which is helpful to search
for data ranges and identify missing values</p>
<div class="sourceCode" id="cb8"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">model_data</span><span class="op">)</span></span>
<span><span class="co">#&gt;  series       year           time           count           mintemp       </span></span>
<span><span class="co">#&gt;  PP:80   Min.   :1.00   Min.   : 1.00   Min.   : 0.000   Min.   :-2.0978  </span></span>
<span><span class="co">#&gt;          1st Qu.:2.00   1st Qu.:20.75   1st Qu.: 1.000   1st Qu.:-1.0808  </span></span>
<span><span class="co">#&gt;          Median :4.00   Median :40.50   Median : 5.000   Median :-0.4091  </span></span>
<span><span class="co">#&gt;          Mean   :3.85   Mean   :40.50   Mean   : 5.222   Mean   :-0.2151  </span></span>
<span><span class="co">#&gt;          3rd Qu.:5.25   3rd Qu.:60.25   3rd Qu.: 8.000   3rd Qu.: 0.6133  </span></span>
<span><span class="co">#&gt;          Max.   :7.00   Max.   :80.00   Max.   :21.000   Max.   : 1.4530  </span></span>
<span><span class="co">#&gt;                                         NA's   :17                        </span></span>
<span><span class="co">#&gt;    ndvi_ma12       </span></span>
<span><span class="co">#&gt;  Min.   :-0.66884  </span></span>
<span><span class="co">#&gt;  1st Qu.:-0.20869  </span></span>
<span><span class="co">#&gt;  Median :-0.16517  </span></span>
<span><span class="co">#&gt;  Mean   :-0.09501  </span></span>
<span><span class="co">#&gt;  3rd Qu.:-0.03440  </span></span>
<span><span class="co">#&gt;  Max.   : 0.74831  </span></span>
<span><span class="co">#&gt; </span></span></code></pre></div>
<p>We have some <code>NA</code>s in our response variable
<code>count</code>. These observations will generally be thrown out by
most modelling packages in . But as you will see when we work through
the tutorials, <code>mvgam</code> keeps these in the data so that
predictions can be automatically returned for the full dataset. The time
series and some of its descriptive features can be plotted using
<code><a href="../reference/plot_mvgam_series.html">plot_mvgam_series()</a></code>:</p>
<div class="sourceCode" id="cb9"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/plot_mvgam_series.html">plot_mvgam_series</a></span><span class="op">(</span>data <span class="op">=</span> <span class="va">model_data</span>, series <span class="op">=</span> <span class="fl">1</span>, y <span class="op">=</span> <span class="st">"count"</span><span class="op">)</span></span></code></pre></div>
<p><img src="mvgam_overview_files/figure-html/unnamed-chunk-6-1.png" width="60%" style="display: block; margin: auto;"></p>
</div>
<div class="section level2">
<h2 id="glms-with-temporal-random-effects">GLMs with temporal random effects<a class="anchor" aria-label="anchor" href="#glms-with-temporal-random-effects"></a>
</h2>
<p>Our first task will be to fit a Generalized Linear Model (GLM) that
can adequately capture the features of our <code>count</code>
observations (integer data, lower bound at zero, missing values) while
also attempting to model temporal variation. We are almost ready to fit
our first model, which will be a GLM with Poisson observations, a log
link function and random (hierarchical) intercepts for
<code>year</code>. This will allow us to capture our prior belief that,
although each year is unique, having been sampled from the same
population of effects, all years are connected and thus might contain
valuable information about one another. This will be done by
capitalizing on the partial pooling properties of hierarchical models.
Hierarchical (also known as random) effects offer many advantages when
modelling data with grouping structures (i.e. multiple species,
locations, years etc…). The ability to incorporate these in time series
models is a huge advantage over traditional models such as ARIMA or
Exponential Smoothing. But before we fit the model, we will need to
convert <code>year</code> to a factor so that we can use a random effect
basis in <code>mvgam</code>. See <code><a href="https://rdrr.io/pkg/mgcv/man/smooth.terms.html" class="external-link">?smooth.terms</a></code> and
<code><a href="https://rdrr.io/pkg/mgcv/man/smooth.construct.re.smooth.spec.html" class="external-link">?smooth.construct.re.smooth.spec</a></code> for details about the
<code>re</code> basis construction that is used by both
<code>mvgam</code> and <code>mgcv</code></p>
<div class="sourceCode" id="cb10"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">model_data</span> <span class="op"><a href="../reference/pipe.html">%&gt;%</a></span></span>
<span>  <span class="co"># Create a 'year_fac' factor version of 'year'</span></span>
<span>  <span class="fu">dplyr</span><span class="fu">::</span><span class="fu"><a href="https://dplyr.tidyverse.org/reference/mutate.html" class="external-link">mutate</a></span><span class="op">(</span>year_fac <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/factor.html" class="external-link">factor</a></span><span class="op">(</span><span class="va">year</span><span class="op">)</span><span class="op">)</span> <span class="op">-&gt;</span> <span class="va">model_data</span></span></code></pre></div>
<p>Preview the dataset to ensure year is now a factor with a unique
factor level for each year in the data</p>
<div class="sourceCode" id="cb11"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu">dplyr</span><span class="fu">::</span><span class="fu"><a href="https://pillar.r-lib.org/reference/glimpse.html" class="external-link">glimpse</a></span><span class="op">(</span><span class="va">model_data</span><span class="op">)</span></span>
<span><span class="co">#&gt; Rows: 80</span></span>
<span><span class="co">#&gt; Columns: 7</span></span>
<span><span class="co">#&gt; $ series    <span style="color: #949494; font-style: italic;">&lt;fct&gt;</span> PP, PP, PP, PP, PP, PP, PP, PP, PP, PP, PP, PP, PP, PP, PP, …</span></span>
<span><span class="co">#&gt; $ year      <span style="color: #949494; font-style: italic;">&lt;int&gt;</span> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, …</span></span>
<span><span class="co">#&gt; $ time      <span style="color: #949494; font-style: italic;">&lt;int&gt;</span> 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 1…</span></span>
<span><span class="co">#&gt; $ count     <span style="color: #949494; font-style: italic;">&lt;int&gt;</span> 0, <span style="color: #BB0000;">NA</span>, 0, 1, 7, 7, 8, 8, 4, <span style="color: #BB0000;">NA</span>, 0, 0, 0, 0, 0, 0, <span style="color: #BB0000;">NA</span>, 2, 4, …</span></span>
<span><span class="co">#&gt; $ mintemp   <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span> -0.79633807, -1.33471597, -1.24166462, -1.08048145, -0.42447…</span></span>
<span><span class="co">#&gt; $ ndvi_ma12 <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span> -0.172144125, -0.237363477, -0.212120638, -0.160438125, -0.0…</span></span>
<span><span class="co">#&gt; $ year_fac  <span style="color: #949494; font-style: italic;">&lt;fct&gt;</span> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, …</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/levels.html" class="external-link">levels</a></span><span class="op">(</span><span class="va">model_data</span><span class="op">$</span><span class="va">year_fac</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] "1" "2" "3" "4" "5" "6" "7"</span></span></code></pre></div>
<p>We are now ready for our first <code>mvgam</code> model. The syntax
will be familiar to users who have previously built models with
<code>mgcv</code>. But for a refresher, see <code><a href="https://rdrr.io/pkg/mgcv/man/formula.gam.html" class="external-link">?formula.gam</a></code>
and the examples in <code><a href="https://rdrr.io/pkg/mgcv/man/gam.html" class="external-link">?gam</a></code>. Random effects can be specified
using the <code>s</code> wrapper with the <code>re</code> basis. Note
that we can also suppress the primary intercept using the usual
<code>R</code> formula syntax <code>- 1</code>. <code>mvgam</code> has a
number of possible observation families that can be used, see
<code><a href="../reference/mvgam_families.html">?mvgam_families</a></code> for more information. We will use
<code>Stan</code> as the fitting engine, which deploys Hamiltonian Monte
Carlo (HMC) for full Bayesian inference. By default, 4 HMC chains will
be run using a warmup of 500 iterations and collecting 500 posterior
samples from each chain. The package will also aim to use the
<code>Cmdstan</code> backend when possible, so it is recommended that
users have an up-to-date installation of <code>Cmdstan</code> and the
associated <code>cmdstanr</code> interface on their machines (note that
you can set the backend yourself using the <code>backend</code>
argument: see <code><a href="../reference/mvgam.html">?mvgam</a></code> for details). Interested users should
consult the <a href="https://mc-stan.org/docs/stan-users-guide/index.html" target="_blank" class="external-link"><code>Stan</code> user’s guide</a> for more information
about the software and the enormous variety of models that can be
tackled with HMC.</p>
<div class="sourceCode" id="cb12"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">model1</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/mvgam.html">mvgam</a></span><span class="op">(</span><span class="va">count</span> <span class="op">~</span> <span class="fu"><a href="https://rdrr.io/pkg/mgcv/man/s.html" class="external-link">s</a></span><span class="op">(</span><span class="va">year_fac</span>, bs <span class="op">=</span> <span class="st">"re"</span><span class="op">)</span> <span class="op">-</span> <span class="fl">1</span>,</span>
<span>  family <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/family.html" class="external-link">poisson</a></span><span class="op">(</span><span class="op">)</span>,</span>
<span>  data <span class="op">=</span> <span class="va">model_data</span></span>
<span><span class="op">)</span></span></code></pre></div>
<p>The model can be described mathematically for each timepoint <span class="math inline">\(t\)</span> as follows: <span class="math display">\[\begin{align*}
\boldsymbol{count}_t &amp; \sim \text{Poisson}(\lambda_t) \\
log(\lambda_t) &amp; = \beta_{year[year_t]} \\
\beta_{year} &amp; \sim \text{Normal}(\mu_{year}, \sigma_{year})
\end{align*}\]</span></p>
<p>Where the <span class="math inline">\(\beta_{year}\)</span> effects
are drawn from a <em>population</em> distribution that is parameterized
by a common mean <span class="math inline">\((\mu_{year})\)</span> and
variance <span class="math inline">\((\sigma_{year})\)</span>. Priors on
most of the model parameters can be interrogated and changed using
similar functionality to the options available in <code>brms</code>. For
example, the default priors on <span class="math inline">\((\mu_{year})\)</span> and <span class="math inline">\((\sigma_{year})\)</span> can be viewed using the
following code:</p>
<div class="sourceCode" id="cb13"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/get_mvgam_priors.html">get_mvgam_priors</a></span><span class="op">(</span><span class="va">count</span> <span class="op">~</span> <span class="fu"><a href="https://rdrr.io/pkg/mgcv/man/s.html" class="external-link">s</a></span><span class="op">(</span><span class="va">year_fac</span>, bs <span class="op">=</span> <span class="st">"re"</span><span class="op">)</span> <span class="op">-</span> <span class="fl">1</span>,</span>
<span>  family <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/family.html" class="external-link">poisson</a></span><span class="op">(</span><span class="op">)</span>,</span>
<span>  data <span class="op">=</span> <span class="va">model_data</span></span>
<span><span class="op">)</span></span>
<span><span class="co">#&gt;                      param_name param_length           param_info</span></span>
<span><span class="co">#&gt; 1             vector[1] mu_raw;            1 s(year_fac) pop mean</span></span>
<span><span class="co">#&gt; 2 vector&lt;lower=0&gt;[1] sigma_raw;            1   s(year_fac) pop sd</span></span>
<span><span class="co">#&gt;                                  prior                example_change</span></span>
<span><span class="co">#&gt; 1               mu_raw ~ std_normal();  mu_raw ~ normal(0.45, 0.81);</span></span>
<span><span class="co">#&gt; 2 sigma_raw ~ inv_gamma(1.418, 0.452); sigma_raw ~ exponential(0.8);</span></span>
<span><span class="co">#&gt;   new_lowerbound new_upperbound</span></span>
<span><span class="co">#&gt; 1             NA             NA</span></span>
<span><span class="co">#&gt; 2             NA             NA</span></span></code></pre></div>
<p>See examples in <code><a href="../reference/get_mvgam_priors.html">?get_mvgam_priors</a></code> to find out different
ways that priors can be altered. Once the model has finished, the first
step is to inspect the <code>summary</code> to ensure no major
diagnostic warnings have been produced and to quickly summarise
posterior distributions for key parameters</p>
<div class="sourceCode" id="cb14"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">model1</span><span class="op">)</span></span>
<span><span class="co">#&gt; GAM formula:</span></span>
<span><span class="co">#&gt; count ~ s(year_fac, bs = "re") - 1</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Family:</span></span>
<span><span class="co">#&gt; poisson</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Link function:</span></span>
<span><span class="co">#&gt; log</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Trend model:</span></span>
<span><span class="co">#&gt; None</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; N series:</span></span>
<span><span class="co">#&gt; 1 </span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; N timepoints:</span></span>
<span><span class="co">#&gt; 80 </span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Status:</span></span>
<span><span class="co">#&gt; Fitted using Stan </span></span>
<span><span class="co">#&gt; 4 chains, each with iter = 1000; warmup = 500; thin = 1 </span></span>
<span><span class="co">#&gt; Total post-warmup draws = 2000</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; GAM coefficient (beta) estimates:</span></span>
<span><span class="co">#&gt;                2.5% 50% 97.5% Rhat n_eff</span></span>
<span><span class="co">#&gt; s(year_fac).1 0.920 1.3   1.6    1  2359</span></span>
<span><span class="co">#&gt; s(year_fac).2 0.870 1.2   1.5    1  2652</span></span>
<span><span class="co">#&gt; s(year_fac).3 0.064 0.6   1.0    1  2082</span></span>
<span><span class="co">#&gt; s(year_fac).4 2.100 2.3   2.5    1  2256</span></span>
<span><span class="co">#&gt; s(year_fac).5 1.100 1.5   1.8    1  2520</span></span>
<span><span class="co">#&gt; s(year_fac).6 1.500 1.8   2.1    1  2405</span></span>
<span><span class="co">#&gt; s(year_fac).7 1.800 2.1   2.3    1  2508</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; GAM group-level estimates:</span></span>
<span><span class="co">#&gt;                   2.5% 50% 97.5% Rhat n_eff</span></span>
<span><span class="co">#&gt; mean(s(year_fac)) 0.85 1.5   1.9 1.01   367</span></span>
<span><span class="co">#&gt; sd(s(year_fac))   0.36 0.6   1.2 1.01   497</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Approximate significance of GAM smooths:</span></span>
<span><span class="co">#&gt;              edf Ref.df Chi.sq p-value    </span></span>
<span><span class="co">#&gt; s(year_fac) 6.01      7    237  &lt;2e-16 ***</span></span>
<span><span class="co">#&gt; ---</span></span>
<span><span class="co">#&gt; Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Stan MCMC diagnostics:</span></span>
<span><span class="co">#&gt; ✔ No issues with effective samples per iteration</span></span>
<span><span class="co">#&gt; ✔ Rhat looks good for all parameters</span></span>
<span><span class="co">#&gt; ✔ No issues with divergences</span></span>
<span><span class="co">#&gt; ✔ No issues with maximum tree depth</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Samples were drawn using sampling(hmc). For each parameter, n_eff is a</span></span>
<span><span class="co">#&gt;   crude measure of effective sample size, and Rhat is the potential scale</span></span>
<span><span class="co">#&gt;   reduction factor on split MCMC chains (at convergence, Rhat = 1)</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Use how_to_cite() to get started describing this model</span></span></code></pre></div>
<p>The diagnostic messages at the bottom of the summary show that the
HMC sampler did not encounter any problems or difficult posterior
spaces. This is a good sign. Posterior distributions for model
parameters can be extracted in any way that an object of class
<code>brmsfit</code> can (see <code><a href="../reference/mvgam_draws.html">?mvgam::mvgam_draws</a></code> for
details). For example, we can extract the coefficients related to the
GAM linear predictor (i.e. the <span class="math inline">\(\beta\)</span>’s) into a <code>data.frame</code>
using:</p>
<div class="sourceCode" id="cb15"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">beta_post</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/as.data.frame.html" class="external-link">as.data.frame</a></span><span class="op">(</span><span class="va">model1</span>, variable <span class="op">=</span> <span class="st">"betas"</span><span class="op">)</span></span>
<span><span class="fu">dplyr</span><span class="fu">::</span><span class="fu"><a href="https://pillar.r-lib.org/reference/glimpse.html" class="external-link">glimpse</a></span><span class="op">(</span><span class="va">beta_post</span><span class="op">)</span></span>
<span><span class="co">#&gt; Rows: 2,000</span></span>
<span><span class="co">#&gt; Columns: 7</span></span>
<span><span class="co">#&gt; $ `s(year_fac).1` <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span> 1.214940, 1.327580, 1.312270, 1.277200, 1.580130, 0.92…</span></span>
<span><span class="co">#&gt; $ `s(year_fac).2` <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span> 1.314350, 1.107400, 1.242660, 1.254060, 1.283390, 1.11…</span></span>
<span><span class="co">#&gt; $ `s(year_fac).3` <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span> 0.5728820, 0.7694690, 0.2130090, 0.7907590, 0.6334420,…</span></span>
<span><span class="co">#&gt; $ `s(year_fac).4` <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span> 2.32520, 2.33122, 2.19439, 2.26896, 2.38990, 2.27307, …</span></span>
<span><span class="co">#&gt; $ `s(year_fac).5` <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span> 1.58084, 1.24458, 1.50030, 1.58874, 1.44873, 1.56224, …</span></span>
<span><span class="co">#&gt; $ `s(year_fac).6` <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span> 1.74901, 2.02590, 1.80032, 1.88439, 1.82428, 1.81131, …</span></span>
<span><span class="co">#&gt; $ `s(year_fac).7` <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span> 2.08108, 2.30094, 2.28501, 1.88996, 1.93482, 2.14432, …</span></span></code></pre></div>
<p>With any model fitted in <code>mvgam</code>, the underlying
<code>Stan</code> code can be viewed using the <code>code</code>
function:</p>
<div class="sourceCode" id="cb16"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/code.html">code</a></span><span class="op">(</span><span class="va">model1</span><span class="op">)</span></span>
<span><span class="co">#&gt; // Stan model code generated by package mvgam</span></span>
<span><span class="co">#&gt; data {</span></span>
<span><span class="co">#&gt;   int&lt;lower=0&gt; total_obs; // total number of observations</span></span>
<span><span class="co">#&gt;   int&lt;lower=0&gt; n; // number of timepoints per series</span></span>
<span><span class="co">#&gt;   int&lt;lower=0&gt; n_series; // number of series</span></span>
<span><span class="co">#&gt;   int&lt;lower=0&gt; num_basis; // total number of basis coefficients</span></span>
<span><span class="co">#&gt;   matrix[total_obs, num_basis] X; // mgcv GAM design matrix</span></span>
<span><span class="co">#&gt;   array[n, n_series] int&lt;lower=0&gt; ytimes; // time-ordered matrix (which col in X belongs to each [time, series] observation?)</span></span>
<span><span class="co">#&gt;   int&lt;lower=0&gt; n_nonmissing; // number of nonmissing observations</span></span>
<span><span class="co">#&gt;   array[n_nonmissing] int&lt;lower=0&gt; flat_ys; // flattened nonmissing observations</span></span>
<span><span class="co">#&gt;   matrix[n_nonmissing, num_basis] flat_xs; // X values for nonmissing observations</span></span>
<span><span class="co">#&gt;   array[n_nonmissing] int&lt;lower=0&gt; obs_ind; // indices of nonmissing observations</span></span>
<span><span class="co">#&gt; }</span></span>
<span><span class="co">#&gt; parameters {</span></span>
<span><span class="co">#&gt;   // raw basis coefficients</span></span>
<span><span class="co">#&gt;   vector[num_basis] b_raw;</span></span>
<span><span class="co">#&gt;   </span></span>
<span><span class="co">#&gt;   // random effect variances</span></span>
<span><span class="co">#&gt;   vector&lt;lower=0&gt;[1] sigma_raw;</span></span>
<span><span class="co">#&gt;   </span></span>
<span><span class="co">#&gt;   // random effect means</span></span>
<span><span class="co">#&gt;   vector[1] mu_raw;</span></span>
<span><span class="co">#&gt; }</span></span>
<span><span class="co">#&gt; transformed parameters {</span></span>
<span><span class="co">#&gt;   // basis coefficients</span></span>
<span><span class="co">#&gt;   vector[num_basis] b;</span></span>
<span><span class="co">#&gt;   b[1 : 7] = mu_raw[1] + b_raw[1 : 7] * sigma_raw[1];</span></span>
<span><span class="co">#&gt; }</span></span>
<span><span class="co">#&gt; model {</span></span>
<span><span class="co">#&gt;   // prior for random effect population variances</span></span>
<span><span class="co">#&gt;   sigma_raw ~ inv_gamma(1.418, 0.452);</span></span>
<span><span class="co">#&gt;   </span></span>
<span><span class="co">#&gt;   // prior for random effect population means</span></span>
<span><span class="co">#&gt;   mu_raw ~ std_normal();</span></span>
<span><span class="co">#&gt;   </span></span>
<span><span class="co">#&gt;   // prior (non-centred) for s(year_fac)...</span></span>
<span><span class="co">#&gt;   b_raw[1 : 7] ~ std_normal();</span></span>
<span><span class="co">#&gt;   {</span></span>
<span><span class="co">#&gt;     // likelihood functions</span></span>
<span><span class="co">#&gt;     flat_ys ~ poisson_log_glm(flat_xs, 0.0, b);</span></span>
<span><span class="co">#&gt;   }</span></span>
<span><span class="co">#&gt; }</span></span>
<span><span class="co">#&gt; generated quantities {</span></span>
<span><span class="co">#&gt;   vector[total_obs] eta;</span></span>
<span><span class="co">#&gt;   matrix[n, n_series] mus;</span></span>
<span><span class="co">#&gt;   array[n, n_series] int ypred;</span></span>
<span><span class="co">#&gt;   </span></span>
<span><span class="co">#&gt;   // posterior predictions</span></span>
<span><span class="co">#&gt;   eta = X * b;</span></span>
<span><span class="co">#&gt;   for (s in 1 : n_series) {</span></span>
<span><span class="co">#&gt;     mus[1 : n, s] = eta[ytimes[1 : n, s]];</span></span>
<span><span class="co">#&gt;     ypred[1 : n, s] = poisson_log_rng(mus[1 : n, s]);</span></span>
<span><span class="co">#&gt;   }</span></span>
<span><span class="co">#&gt; }</span></span></code></pre></div>
<div class="section level3">
<h3 id="plotting-effects-and-residuals">Plotting effects and residuals<a class="anchor" aria-label="anchor" href="#plotting-effects-and-residuals"></a>
</h3>
<p>Now for interrogating the model. We can get some sense of the
variation in yearly intercepts from the summary above, but it is easier
to understand them using targeted plots. Plot posterior distributions of
the temporal random effects using <code>plot.mvgam</code> with
<code>type = 're'</code>. See <code><a href="../reference/plot.mvgam.html">?plot.mvgam</a></code> for more details
about the types of plots that can be produced from fitted
<code>mvgam</code> objects</p>
<div class="sourceCode" id="cb17"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">model1</span>, type <span class="op">=</span> <span class="st">"re"</span><span class="op">)</span></span></code></pre></div>
<p><img src="mvgam_overview_files/figure-html/Plot%20random%20effect%20estimates-1.png" width="60%" style="display: block; margin: auto;"></p>
</div>
<div class="section level3">
<h3 id="bayesplot-support">
<code>bayesplot</code> support<a class="anchor" aria-label="anchor" href="#bayesplot-support"></a>
</h3>
<p>We can also capitalize on most of the useful MCMC plotting functions
from the <code>bayesplot</code> package to visualize posterior
distributions and diagnostics (see <code><a href="../reference/mcmc_plot.mvgam.html">?mvgam::mcmc_plot.mvgam</a></code>
for details):</p>
<div class="sourceCode" id="cb18"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://paulbuerkner.com/brms/reference/mcmc_plot.brmsfit.html" class="external-link">mcmc_plot</a></span><span class="op">(</span></span>
<span>  object <span class="op">=</span> <span class="va">model1</span>,</span>
<span>  variable <span class="op">=</span> <span class="st">"betas"</span>,</span>
<span>  type <span class="op">=</span> <span class="st">"areas"</span></span>
<span><span class="op">)</span></span></code></pre></div>
<p><img src="mvgam_overview_files/figure-html/unnamed-chunk-13-1.png" width="60%" style="display: block; margin: auto;"></p>
<p>We can also use the wide range of posterior checking functions
available in <code>bayesplot</code> (see
<code>?mvgam::ppc_check.mvgam</code> for details):</p>
<div class="sourceCode" id="cb19"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/pp_check.mvgam.html">pp_check</a></span><span class="op">(</span>object <span class="op">=</span> <span class="va">model1</span><span class="op">)</span></span></code></pre></div>
<p><img src="mvgam_overview_files/figure-html/unnamed-chunk-14-1.png" width="60%" style="display: block; margin: auto;"></p>
<p>There is clearly some variation in these yearly intercept estimates.
But how do these translate into time-varying predictions? To understand
this, we can plot posterior hindcasts from this model for the training
period using <code>plot.mvgam</code> with
<code>type = 'forecast'</code></p>
<div class="sourceCode" id="cb20"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">model1</span>, type <span class="op">=</span> <span class="st">"forecast"</span><span class="op">)</span></span></code></pre></div>
<p><img src="mvgam_overview_files/figure-html/Plot%20posterior%20hindcasts-1.png" width="60%" style="display: block; margin: auto;"></p>
<p>If you wish to extract these hindcasts for other downstream analyses,
the <code>hindcast</code> function can be used. This will return a list
object of class <code>mvgam_forecast</code>. In the
<code>hindcasts</code> slot, a matrix of posterior retrodictions will be
returned for each series in the data (only one series in our
example):</p>
<div class="sourceCode" id="cb21"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">hc</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/hindcast.mvgam.html">hindcast</a></span><span class="op">(</span><span class="va">model1</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/str.html" class="external-link">str</a></span><span class="op">(</span><span class="va">hc</span><span class="op">)</span></span>
<span><span class="co">#&gt; List of 15</span></span>
<span><span class="co">#&gt;  $ call              :Class 'formula'  language count ~ s(year_fac, bs = "re") - 1</span></span>
<span><span class="co">#&gt;   .. ..- attr(*, ".Environment")=&lt;environment: R_GlobalEnv&gt; </span></span>
<span><span class="co">#&gt;  $ trend_call        : NULL</span></span>
<span><span class="co">#&gt;  $ family            : chr "poisson"</span></span>
<span><span class="co">#&gt;  $ trend_model       : chr "None"</span></span>
<span><span class="co">#&gt;  $ drift             : logi FALSE</span></span>
<span><span class="co">#&gt;  $ use_lv            : logi FALSE</span></span>
<span><span class="co">#&gt;  $ fit_engine        : chr "stan"</span></span>
<span><span class="co">#&gt;  $ type              : chr "response"</span></span>
<span><span class="co">#&gt;  $ series_names      : chr "PP"</span></span>
<span><span class="co">#&gt;  $ train_observations:List of 1</span></span>
<span><span class="co">#&gt;   ..$ PP: int [1:80] 0 NA 0 1 7 7 8 8 4 NA ...</span></span>
<span><span class="co">#&gt;  $ train_times       : int [1:80] 1 2 3 4 5 6 7 8 9 10 ...</span></span>
<span><span class="co">#&gt;  $ test_observations : NULL</span></span>
<span><span class="co">#&gt;  $ test_times        : NULL</span></span>
<span><span class="co">#&gt;  $ hindcasts         :List of 1</span></span>
<span><span class="co">#&gt;   ..$ PP: num [1:2000, 1:80] 1 4 2 1 2 4 1 6 5 4 ...</span></span>
<span><span class="co">#&gt;   .. ..- attr(*, "dimnames")=List of 2</span></span>
<span><span class="co">#&gt;   .. .. ..$ : NULL</span></span>
<span><span class="co">#&gt;   .. .. ..$ : chr [1:80] "ypred[1,1]" "ypred[2,1]" "ypred[3,1]" "ypred[4,1]" ...</span></span>
<span><span class="co">#&gt;  $ forecasts         : NULL</span></span>
<span><span class="co">#&gt;  - attr(*, "class")= chr "mvgam_forecast"</span></span></code></pre></div>
<p>You can also extract these hindcasts on the linear predictor scale,
which in this case is the log scale (our Poisson GLM used a log link
function). Sometimes this can be useful for asking more targeted
questions about drivers of variation:</p>
<div class="sourceCode" id="cb22"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">hc</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/hindcast.mvgam.html">hindcast</a></span><span class="op">(</span><span class="va">model1</span>, type <span class="op">=</span> <span class="st">"link"</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/range.html" class="external-link">range</a></span><span class="op">(</span><span class="va">hc</span><span class="op">$</span><span class="va">hindcasts</span><span class="op">$</span><span class="va">PP</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] -0.367547  2.593740</span></span></code></pre></div>
<p>In any regression analysis, a key question is whether the residuals
show any patterns that can be indicative of un-modelled sources of
variation. For GLMs, we can use a modified residual called the <a href="https://www.jstor.org/stable/1390802" target="_blank" class="external-link">Dunn-Smyth,
or randomized quantile, residual</a>. Inspect Dunn-Smyth residuals from
the model using <code>plot.mvgam</code> with
<code>type = 'residuals'</code></p>
<div class="sourceCode" id="cb23"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">model1</span>, type <span class="op">=</span> <span class="st">"residuals"</span><span class="op">)</span></span></code></pre></div>
<p><img src="mvgam_overview_files/figure-html/Plot%20posterior%20residuals-1.png" width="60%" style="display: block; margin: auto;"></p>
</div>
</div>
<div class="section level2">
<h2 id="automatic-forecasting-for-new-data">Automatic forecasting for new data<a class="anchor" aria-label="anchor" href="#automatic-forecasting-for-new-data"></a>
</h2>
<p>These temporal random effects do not have a sense of “time”. Because
of this, each yearly random intercept is not restricted in some way to
be similar to the previous yearly intercept. This drawback becomes
evident when we predict for a new year. To do this, we can repeat the
exercise above but this time will split the data into training and
testing sets before re-running the model. We can then supply the test
set as <code>newdata</code>. For splitting, we will make use of the
<code>filter</code> function from <code>dplyr</code></p>
<div class="sourceCode" id="cb24"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">model_data</span> <span class="op"><a href="../reference/pipe.html">%&gt;%</a></span></span>
<span>  <span class="fu">dplyr</span><span class="fu">::</span><span class="fu"><a href="https://dplyr.tidyverse.org/reference/filter.html" class="external-link">filter</a></span><span class="op">(</span><span class="va">time</span> <span class="op">&lt;=</span> <span class="fl">70</span><span class="op">)</span> <span class="op">-&gt;</span> <span class="va">data_train</span></span>
<span><span class="va">model_data</span> <span class="op"><a href="../reference/pipe.html">%&gt;%</a></span></span>
<span>  <span class="fu">dplyr</span><span class="fu">::</span><span class="fu"><a href="https://dplyr.tidyverse.org/reference/filter.html" class="external-link">filter</a></span><span class="op">(</span><span class="va">time</span> <span class="op">&gt;</span> <span class="fl">70</span><span class="op">)</span> <span class="op">-&gt;</span> <span class="va">data_test</span></span></code></pre></div>
<div class="sourceCode" id="cb25"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">model1b</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/mvgam.html">mvgam</a></span><span class="op">(</span><span class="va">count</span> <span class="op">~</span> <span class="fu"><a href="https://rdrr.io/pkg/mgcv/man/s.html" class="external-link">s</a></span><span class="op">(</span><span class="va">year_fac</span>, bs <span class="op">=</span> <span class="st">"re"</span><span class="op">)</span> <span class="op">-</span> <span class="fl">1</span>,</span>
<span>  family <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/family.html" class="external-link">poisson</a></span><span class="op">(</span><span class="op">)</span>,</span>
<span>  data <span class="op">=</span> <span class="va">data_train</span>,</span>
<span>  newdata <span class="op">=</span> <span class="va">data_test</span></span>
<span><span class="op">)</span></span></code></pre></div>
<p>We can view the test data in the forecast plot to see that the
predictions do not capture the temporal variation in the test set</p>
<div class="sourceCode" id="cb26"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">model1b</span>, type <span class="op">=</span> <span class="st">"forecast"</span>, newdata <span class="op">=</span> <span class="va">data_test</span><span class="op">)</span></span></code></pre></div>
<p><img src="mvgam_overview_files/figure-html/Plotting%20predictions%20against%20test%20data-1.png" width="60%" style="display: block; margin: auto;"></p>
<p>As with the <code>hindcast</code> function, we can use the
<code>forecast</code> function to automatically extract the posterior
distributions for these predictions. This also returns an object of
class <code>mvgam_forecast</code>, but now it will contain both the
hindcasts and forecasts for each series in the data:</p>
<div class="sourceCode" id="cb27"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">fc</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/forecast.mvgam.html">forecast</a></span><span class="op">(</span><span class="va">model1b</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/str.html" class="external-link">str</a></span><span class="op">(</span><span class="va">fc</span><span class="op">)</span></span>
<span><span class="co">#&gt; List of 16</span></span>
<span><span class="co">#&gt;  $ call              :Class 'formula'  language count ~ s(year_fac, bs = "re") - 1</span></span>
<span><span class="co">#&gt;   .. ..- attr(*, ".Environment")=&lt;environment: R_GlobalEnv&gt; </span></span>
<span><span class="co">#&gt;  $ trend_call        : NULL</span></span>
<span><span class="co">#&gt;  $ family            : chr "poisson"</span></span>
<span><span class="co">#&gt;  $ family_pars       : NULL</span></span>
<span><span class="co">#&gt;  $ trend_model       : chr "None"</span></span>
<span><span class="co">#&gt;  $ drift             : logi FALSE</span></span>
<span><span class="co">#&gt;  $ use_lv            : logi FALSE</span></span>
<span><span class="co">#&gt;  $ fit_engine        : chr "stan"</span></span>
<span><span class="co">#&gt;  $ type              : chr "response"</span></span>
<span><span class="co">#&gt;  $ series_names      : Factor w/ 1 level "PP": 1</span></span>
<span><span class="co">#&gt;  $ train_observations:List of 1</span></span>
<span><span class="co">#&gt;   ..$ PP: int [1:70] 0 NA 0 1 7 7 8 8 4 NA ...</span></span>
<span><span class="co">#&gt;  $ train_times       : int [1:70] 1 2 3 4 5 6 7 8 9 10 ...</span></span>
<span><span class="co">#&gt;  $ test_observations :List of 1</span></span>
<span><span class="co">#&gt;   ..$ PP: int [1:10] NA 4 11 8 5 2 5 8 14 14</span></span>
<span><span class="co">#&gt;  $ test_times        : int [1:10] 71 72 73 74 75 76 77 78 79 80</span></span>
<span><span class="co">#&gt;  $ hindcasts         :List of 1</span></span>
<span><span class="co">#&gt;   ..$ PP: num [1:2000, 1:70] 6 3 2 2 3 3 4 4 4 0 ...</span></span>
<span><span class="co">#&gt;   .. ..- attr(*, "dimnames")=List of 2</span></span>
<span><span class="co">#&gt;   .. .. ..$ : NULL</span></span>
<span><span class="co">#&gt;   .. .. ..$ : chr [1:70] "ypred[1,1]" "ypred[2,1]" "ypred[3,1]" "ypred[4,1]" ...</span></span>
<span><span class="co">#&gt;  $ forecasts         :List of 1</span></span>
<span><span class="co">#&gt;   ..$ PP: num [1:2000, 1:10] 4 13 10 13 7 7 5 4 5 5 ...</span></span>
<span><span class="co">#&gt;   .. ..- attr(*, "dimnames")=List of 2</span></span>
<span><span class="co">#&gt;   .. .. ..$ : NULL</span></span>
<span><span class="co">#&gt;   .. .. ..$ : chr [1:10] "ypred[71,1]" "ypred[72,1]" "ypred[73,1]" "ypred[74,1]" ...</span></span>
<span><span class="co">#&gt;  - attr(*, "class")= chr "mvgam_forecast"</span></span></code></pre></div>
</div>
<div class="section level2">
<h2 id="adding-predictors-as-fixed-effects">Adding predictors as “fixed” effects<a class="anchor" aria-label="anchor" href="#adding-predictors-as-fixed-effects"></a>
</h2>
<p>Any users familiar with GLMs will know that we nearly always wish to
include predictor variables that may explain some of the variation in
our observations. Predictors are easily incorporated into GLMs / GAMs.
Here, we will update the model from above by including a parametric
(fixed) effect of <code>ndvi_ma12</code> as a linear predictor:</p>
<div class="sourceCode" id="cb28"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">model2</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/mvgam.html">mvgam</a></span><span class="op">(</span></span>
<span>  <span class="va">count</span> <span class="op">~</span> <span class="fu"><a href="https://rdrr.io/pkg/mgcv/man/s.html" class="external-link">s</a></span><span class="op">(</span><span class="va">year_fac</span>, bs <span class="op">=</span> <span class="st">"re"</span><span class="op">)</span> <span class="op">+</span></span>
<span>    <span class="va">ndvi_ma12</span> <span class="op">-</span> <span class="fl">1</span>,</span>
<span>  family <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/family.html" class="external-link">poisson</a></span><span class="op">(</span><span class="op">)</span>,</span>
<span>  data <span class="op">=</span> <span class="va">data_train</span>,</span>
<span>  newdata <span class="op">=</span> <span class="va">data_test</span></span>
<span><span class="op">)</span></span></code></pre></div>
<p>The model can be described mathematically as follows: <span class="math display">\[\begin{align*}
\boldsymbol{count}_t &amp; \sim \text{Poisson}(\lambda_t) \\
log(\lambda_t) &amp; = \beta_{year[year_t]} + \beta_{ndvi} *
\boldsymbol{ndvi}_t \\
\beta_{year} &amp; \sim \text{Normal}(\mu_{year}, \sigma_{year}) \\
\beta_{ndvi} &amp; \sim \text{Normal}(0, 1) \end{align*}\]</span></p>
<p>Where the <span class="math inline">\(\beta_{year}\)</span> effects
are the same as before but we now have another predictor <span class="math inline">\((\beta_{ndvi})\)</span> that applies to the
<code>ndvi_ma12</code> value at each timepoint <span class="math inline">\(t\)</span>. Inspect the summary of this model</p>
<div class="sourceCode" id="cb29"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">model2</span><span class="op">)</span></span>
<span><span class="co">#&gt; GAM formula:</span></span>
<span><span class="co">#&gt; count ~ ndvi_ma12 + s(year_fac, bs = "re") - 1</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Family:</span></span>
<span><span class="co">#&gt; poisson</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Link function:</span></span>
<span><span class="co">#&gt; log</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Trend model:</span></span>
<span><span class="co">#&gt; None</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; N series:</span></span>
<span><span class="co">#&gt; 1 </span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; N timepoints:</span></span>
<span><span class="co">#&gt; 80 </span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Status:</span></span>
<span><span class="co">#&gt; Fitted using Stan </span></span>
<span><span class="co">#&gt; 4 chains, each with iter = 1000; warmup = 500; thin = 1 </span></span>
<span><span class="co">#&gt; Total post-warmup draws = 2000</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; GAM coefficient (beta) estimates:</span></span>
<span><span class="co">#&gt;                 2.5%   50% 97.5% Rhat n_eff</span></span>
<span><span class="co">#&gt; ndvi_ma12     -0.410 0.043  0.47    1  1582</span></span>
<span><span class="co">#&gt; s(year_fac).1  0.920 1.300  1.60    1  2230</span></span>
<span><span class="co">#&gt; s(year_fac).2  0.860 1.200  1.50    1  2421</span></span>
<span><span class="co">#&gt; s(year_fac).3  0.061 0.590  1.10    1  2217</span></span>
<span><span class="co">#&gt; s(year_fac).4  2.000 2.300  2.50    1  2076</span></span>
<span><span class="co">#&gt; s(year_fac).5  1.100 1.500  1.80    1  2270</span></span>
<span><span class="co">#&gt; s(year_fac).6  1.600 1.800  2.10    1  2140</span></span>
<span><span class="co">#&gt; s(year_fac).7 -0.120 1.400  2.70    1   988</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; GAM group-level estimates:</span></span>
<span><span class="co">#&gt;                   2.5%  50% 97.5% Rhat n_eff</span></span>
<span><span class="co">#&gt; mean(s(year_fac)) 0.67 1.40   1.9 1.02   373</span></span>
<span><span class="co">#&gt; sd(s(year_fac))   0.33 0.58   1.3 1.02   329</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Approximate significance of GAM smooths:</span></span>
<span><span class="co">#&gt;              edf Ref.df Chi.sq p-value    </span></span>
<span><span class="co">#&gt; s(year_fac) 5.24      7    179  &lt;2e-16 ***</span></span>
<span><span class="co">#&gt; ---</span></span>
<span><span class="co">#&gt; Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Stan MCMC diagnostics:</span></span>
<span><span class="co">#&gt; ✔ No issues with effective samples per iteration</span></span>
<span><span class="co">#&gt; ✔ Rhat looks good for all parameters</span></span>
<span><span class="co">#&gt; ✔ No issues with divergences</span></span>
<span><span class="co">#&gt; ✔ No issues with maximum tree depth</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Samples were drawn using sampling(hmc). For each parameter, n_eff is a</span></span>
<span><span class="co">#&gt;   crude measure of effective sample size, and Rhat is the potential scale</span></span>
<span><span class="co">#&gt;   reduction factor on split MCMC chains (at convergence, Rhat = 1)</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Use how_to_cite() to get started describing this model</span></span></code></pre></div>
<p>Rather than printing the summary each time, we can also quickly look
at the posterior empirical quantiles for the fixed effect of
<code>ndvi</code> (and other linear predictor coefficients) using
<code>coef</code>:</p>
<div class="sourceCode" id="cb30"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/stats/coef.html" class="external-link">coef</a></span><span class="op">(</span><span class="va">model2</span><span class="op">)</span></span>
<span><span class="co">#&gt;                      2.5%        50%     97.5% Rhat n_eff</span></span>
<span><span class="co">#&gt; ndvi_ma12     -0.40996485 0.04283945 0.4673025    1  1582</span></span>
<span><span class="co">#&gt; s(year_fac).1  0.91901945 1.26033000 1.5707212    1  2230</span></span>
<span><span class="co">#&gt; s(year_fac).2  0.86327525 1.20950500 1.5203245    1  2421</span></span>
<span><span class="co">#&gt; s(year_fac).3  0.06073426 0.59372800 1.0606170    1  2217</span></span>
<span><span class="co">#&gt; s(year_fac).4  2.02198850 2.27009500 2.4819213    1  2076</span></span>
<span><span class="co">#&gt; s(year_fac).5  1.10297525 1.45693500 1.7714813    1  2270</span></span>
<span><span class="co">#&gt; s(year_fac).6  1.58039150 1.84542500 2.1097990    1  2140</span></span>
<span><span class="co">#&gt; s(year_fac).7 -0.11933482 1.39343500 2.7083200    1   988</span></span></code></pre></div>
<p>Look at the estimated effect of <code>ndvi</code> using using a
histogram. This can be done by first extracting the posterior
coefficients:</p>
<div class="sourceCode" id="cb31"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">beta_post</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/as.data.frame.html" class="external-link">as.data.frame</a></span><span class="op">(</span><span class="va">model2</span>, variable <span class="op">=</span> <span class="st">"betas"</span><span class="op">)</span></span>
<span><span class="fu">dplyr</span><span class="fu">::</span><span class="fu"><a href="https://pillar.r-lib.org/reference/glimpse.html" class="external-link">glimpse</a></span><span class="op">(</span><span class="va">beta_post</span><span class="op">)</span></span>
<span><span class="co">#&gt; Rows: 2,000</span></span>
<span><span class="co">#&gt; Columns: 8</span></span>
<span><span class="co">#&gt; $ ndvi_ma12       <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span> 0.15092000, -0.07224160, -0.01072470, 0.06178290, 0.32…</span></span>
<span><span class="co">#&gt; $ `s(year_fac).1` <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span> 1.260620, 1.237480, 1.336680, 1.391520, 1.176470, 1.13…</span></span>
<span><span class="co">#&gt; $ `s(year_fac).2` <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span> 0.986840, 1.238950, 1.241640, 1.344040, 1.203340, 1.26…</span></span>
<span><span class="co">#&gt; $ `s(year_fac).3` <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span> 0.6400060, 0.5338640, 0.5596370, 0.5185390, 0.5265630,…</span></span>
<span><span class="co">#&gt; $ `s(year_fac).4` <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span> 2.49096, 2.25690, 2.16193, 2.27607, 2.36063, 2.29226, …</span></span>
<span><span class="co">#&gt; $ `s(year_fac).5` <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span> 1.49968, 1.45541, 1.40851, 1.39896, 1.48283, 1.51829, …</span></span>
<span><span class="co">#&gt; $ `s(year_fac).6` <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span> 1.87853, 1.90285, 1.79225, 1.76814, 1.93750, 1.87616, …</span></span>
<span><span class="co">#&gt; $ `s(year_fac).7` <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span> 1.384440, 1.273460, 0.672738, 1.240540, 0.947571, 1.05…</span></span></code></pre></div>
<p>The posterior distribution for the effect of <code>ndvi</code> is
stored in the <code>ndvi_ma12</code> column. A quick histogram confirms
our inference that <code>log(counts)</code> respond positively to
increases in <code>ndvi</code>:</p>
<div class="sourceCode" id="cb32"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/graphics/hist.html" class="external-link">hist</a></span><span class="op">(</span><span class="va">beta_post</span><span class="op">$</span><span class="va">ndvi_ma12</span>,</span>
<span>  xlim <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span></span>
<span>    <span class="op">-</span><span class="fl">1</span> <span class="op">*</span> <span class="fu"><a href="https://rdrr.io/r/base/Extremes.html" class="external-link">max</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/MathFun.html" class="external-link">abs</a></span><span class="op">(</span><span class="va">beta_post</span><span class="op">$</span><span class="va">ndvi_ma12</span><span class="op">)</span><span class="op">)</span>,</span>
<span>    <span class="fu"><a href="https://rdrr.io/r/base/Extremes.html" class="external-link">max</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/MathFun.html" class="external-link">abs</a></span><span class="op">(</span><span class="va">beta_post</span><span class="op">$</span><span class="va">ndvi</span><span class="op">)</span><span class="op">)</span></span>
<span>  <span class="op">)</span>,</span>
<span>  col <span class="op">=</span> <span class="st">"darkred"</span>,</span>
<span>  border <span class="op">=</span> <span class="st">"white"</span>,</span>
<span>  xlab <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/expression.html" class="external-link">expression</a></span><span class="op">(</span><span class="va">beta</span><span class="op">[</span><span class="va">NDVI</span><span class="op">]</span><span class="op">)</span>,</span>
<span>  ylab <span class="op">=</span> <span class="st">""</span>,</span>
<span>  yaxt <span class="op">=</span> <span class="st">"n"</span>,</span>
<span>  main <span class="op">=</span> <span class="st">""</span>,</span>
<span>  lwd <span class="op">=</span> <span class="fl">2</span></span>
<span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/abline.html" class="external-link">abline</a></span><span class="op">(</span>v <span class="op">=</span> <span class="fl">0</span>, lwd <span class="op">=</span> <span class="fl">2.5</span><span class="op">)</span></span></code></pre></div>
<p><img src="mvgam_overview_files/figure-html/Histogram%20of%20NDVI%20effects-1.png" width="60%" style="display: block; margin: auto;"></p>
<div class="section level3">
<h3 id="marginaleffects-support">
<code>marginaleffects</code> support<a class="anchor" aria-label="anchor" href="#marginaleffects-support"></a>
</h3>
<p>Given our model used a nonlinear link function (log link in this
example), it can still be difficult to fully understand what
relationship our model is estimating between a predictor and the
response. Fortunately, the <code>marginaleffects</code> package makes
this relatively straightforward. Objects of class <code>mvgam</code> can
be used with <code>marginaleffects</code> to inspect contrasts,
scenario-based predictions, conditional and marginal effects, all on the
outcome scale. Like <code>brms</code>, <code>mvgam</code> has the simple
<code>conditional_effects</code> function to make quick and informative
plots for main effects, which rely on <code>marginaleffects</code>
support. This will likely be your go-to function for quickly
understanding patterns from fitted <code>mvgam</code> models</p>
<div class="sourceCode" id="cb33"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://paulbuerkner.com/brms/reference/conditional_effects.brmsfit.html" class="external-link">conditional_effects</a></span><span class="op">(</span><span class="va">model2</span><span class="op">)</span></span></code></pre></div>
<p><img src="mvgam_overview_files/figure-html/unnamed-chunk-21-1.png" width="60%" style="display: block; margin: auto;"><img src="mvgam_overview_files/figure-html/unnamed-chunk-21-2.png" width="60%" style="display: block; margin: auto;"></p>
</div>
</div>
<div class="section level2">
<h2 id="adding-predictors-as-smooths">Adding predictors as smooths<a class="anchor" aria-label="anchor" href="#adding-predictors-as-smooths"></a>
</h2>
<p>Smooth functions, using penalized splines, are a major feature of
<code>mvgam</code>. Nonlinear splines are commonly viewed as variations
of random effects in which the coefficients that control the shape of
the spline are drawn from a joint, penalized distribution. This strategy
is very often used in ecological time series analysis to capture smooth
temporal variation in the processes we seek to study. When we construct
smoothing splines, the workhorse package <code>mgcv</code> will
calculate a set of basis functions that will collectively control the
shape and complexity of the resulting spline. It is often helpful to
visualize these basis functions to get a better sense of how splines
work. We’ll create a set of 6 basis functions to represent possible
variation in the effect of <code>time</code> on our outcome.In addition
to constructing the basis functions, <code>mgcv</code> also creates a
penalty matrix <span class="math inline">\(S\)</span>, which contains
<strong>known</strong> coefficients that work to constrain the
wiggliness of the resulting smooth function. When fitting a GAM to data,
we must estimate the smoothing parameters (<span class="math inline">\(\lambda\)</span>) that will penalize these
matrices, resulting in constrained basis coefficients and smoother
functions that are less likely to overfit the data. This is the key to
fitting GAMs in a Bayesian framework, as we can jointly estimate the
<span class="math inline">\(\lambda\)</span>’s using informative priors
to prevent overfitting and expand the complexity of models we can
tackle. To see this in practice, we can now fit a model that replaces
the yearly random effects with a smooth function of <code>time</code>.
We will need a reasonably complex function (large <code>k</code>) to try
and accommodate the temporal variation in our observations. Following
some <a href="https://fromthebottomoftheheap.net/2020/06/03/extrapolating-with-gams/" target="_blank" class="external-link">useful advice by Gavin Simpson</a>, we will use a
b-spline basis for the temporal smooth. Because we no longer have
intercepts for each year, we also retain the primary intercept term in
this model (there is no <code>-1</code> in the formula now):</p>
<div class="sourceCode" id="cb34"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">model3</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/mvgam.html">mvgam</a></span><span class="op">(</span></span>
<span>  <span class="va">count</span> <span class="op">~</span> <span class="fu"><a href="https://rdrr.io/pkg/mgcv/man/s.html" class="external-link">s</a></span><span class="op">(</span><span class="va">time</span>, bs <span class="op">=</span> <span class="st">"bs"</span>, k <span class="op">=</span> <span class="fl">15</span><span class="op">)</span> <span class="op">+</span></span>
<span>    <span class="va">ndvi_ma12</span>,</span>
<span>  family <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/family.html" class="external-link">poisson</a></span><span class="op">(</span><span class="op">)</span>,</span>
<span>  data <span class="op">=</span> <span class="va">data_train</span>,</span>
<span>  newdata <span class="op">=</span> <span class="va">data_test</span></span>
<span><span class="op">)</span></span></code></pre></div>
<p>The model can be described mathematically as follows: <span class="math display">\[\begin{align*}
\boldsymbol{count}_t &amp; \sim \text{Poisson}(\lambda_t) \\
log(\lambda_t) &amp; = f(\boldsymbol{time})_t + \beta_{ndvi} *
\boldsymbol{ndvi}_t  \\
f(\boldsymbol{time}) &amp; = \sum_{k=1}^{K}b * \beta_{smooth} \\
\beta_{smooth} &amp; \sim \text{MVNormal}(0, (\Omega * \lambda)^{-1}) \\
\beta_{ndvi} &amp; \sim \text{Normal}(0, 1) \end{align*}\]</span></p>
<p>Where the smooth function <span class="math inline">\(f_{time}\)</span> is built by summing across a set
of weighted basis functions. The basis functions <span class="math inline">\((b)\)</span> are constructed using a thin plate
regression basis in <code>mgcv</code>. The weights <span class="math inline">\((\beta_{smooth})\)</span> are drawn from a
penalized multivariate normal distribution where the precision matrix
<span class="math inline">\((\Omega\)</span>) is multiplied by a
smoothing penalty <span class="math inline">\((\lambda)\)</span>. If
<span class="math inline">\(\lambda\)</span> becomes large, this acts to
<em>squeeze</em> the covariances among the weights <span class="math inline">\((\beta_{smooth})\)</span>, leading to a less
wiggly spline. Note that sometimes there are multiple smoothing
penalties that contribute to the covariance matrix, but I am only
showing one here for simplicity. View the summary as before</p>
<div class="sourceCode" id="cb35"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">model3</span><span class="op">)</span></span>
<span><span class="co">#&gt; GAM formula:</span></span>
<span><span class="co">#&gt; count ~ s(time, bs = "bs", k = 15) + ndvi_ma12</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Family:</span></span>
<span><span class="co">#&gt; poisson</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Link function:</span></span>
<span><span class="co">#&gt; log</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Trend model:</span></span>
<span><span class="co">#&gt; None</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; N series:</span></span>
<span><span class="co">#&gt; 1 </span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; N timepoints:</span></span>
<span><span class="co">#&gt; 80 </span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Status:</span></span>
<span><span class="co">#&gt; Fitted using Stan </span></span>
<span><span class="co">#&gt; 4 chains, each with iter = 1000; warmup = 500; thin = 1 </span></span>
<span><span class="co">#&gt; Total post-warmup draws = 2000</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; GAM coefficient (beta) estimates:</span></span>
<span><span class="co">#&gt;               2.5%    50% 97.5% Rhat n_eff</span></span>
<span><span class="co">#&gt; (Intercept)   0.80  1.100  1.30 1.00   927</span></span>
<span><span class="co">#&gt; ndvi_ma12     0.39  1.900  3.50 1.00  1225</span></span>
<span><span class="co">#&gt; s(time).1    -9.80 -5.800 -2.40 1.00   668</span></span>
<span><span class="co">#&gt; s(time).2     1.20  3.500  5.90 1.01   389</span></span>
<span><span class="co">#&gt; s(time).3   -10.00 -6.200 -2.80 1.00   580</span></span>
<span><span class="co">#&gt; s(time).4    -1.60  0.830  3.20 1.01   374</span></span>
<span><span class="co">#&gt; s(time).5    -3.00 -0.400  2.30 1.01   387</span></span>
<span><span class="co">#&gt; s(time).6    -6.70 -3.700 -1.20 1.01   486</span></span>
<span><span class="co">#&gt; s(time).7    -1.70  0.610  3.00 1.01   365</span></span>
<span><span class="co">#&gt; s(time).8    -2.40 -0.077  2.20 1.01   368</span></span>
<span><span class="co">#&gt; s(time).9    -0.55  2.100  4.80 1.01   377</span></span>
<span><span class="co">#&gt; s(time).10   -5.60 -3.300 -0.88 1.01   476</span></span>
<span><span class="co">#&gt; s(time).11   -2.60  0.570  3.80 1.01   434</span></span>
<span><span class="co">#&gt; s(time).12   -6.80 -5.000 -3.10 1.00   712</span></span>
<span><span class="co">#&gt; s(time).13    1.80  5.000  8.50 1.01   361</span></span>
<span><span class="co">#&gt; s(time).14  -11.00 -3.300  4.50 1.01   339</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Approximate significance of GAM smooths:</span></span>
<span><span class="co">#&gt;          edf Ref.df Chi.sq p-value    </span></span>
<span><span class="co">#&gt; s(time) 11.5     14    106  &lt;2e-16 ***</span></span>
<span><span class="co">#&gt; ---</span></span>
<span><span class="co">#&gt; Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Stan MCMC diagnostics:</span></span>
<span><span class="co">#&gt; ✔ No issues with effective samples per iteration</span></span>
<span><span class="co">#&gt; ✔ Rhat looks good for all parameters</span></span>
<span><span class="co">#&gt; ✔ No issues with divergences</span></span>
<span><span class="co">#&gt; ✔ No issues with maximum tree depth</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Samples were drawn using sampling(hmc). For each parameter, n_eff is a</span></span>
<span><span class="co">#&gt;   crude measure of effective sample size, and Rhat is the potential scale</span></span>
<span><span class="co">#&gt;   reduction factor on split MCMC chains (at convergence, Rhat = 1)</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Use how_to_cite() to get started describing this model</span></span></code></pre></div>
<p>The summary above now contains posterior estimates for the smoothing
parameters as well as the basis coefficients for the nonlinear effect of
<code>time</code>. We can visualize <code>conditional_effects</code> as
before:</p>
<div class="sourceCode" id="cb36"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://paulbuerkner.com/brms/reference/conditional_effects.brmsfit.html" class="external-link">conditional_effects</a></span><span class="op">(</span><span class="va">model3</span>, type <span class="op">=</span> <span class="st">"link"</span><span class="op">)</span></span></code></pre></div>
<p><img src="mvgam_overview_files/figure-html/unnamed-chunk-24-1.png" width="60%" style="display: block; margin: auto;"><img src="mvgam_overview_files/figure-html/unnamed-chunk-24-2.png" width="60%" style="display: block; margin: auto;"></p>
<p>Inspect the underlying <code>Stan</code> code to gain some idea of
how the spline is being penalized:</p>
<div class="sourceCode" id="cb37"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/code.html">code</a></span><span class="op">(</span><span class="va">model3</span><span class="op">)</span></span>
<span><span class="co">#&gt; // Stan model code generated by package mvgam</span></span>
<span><span class="co">#&gt; data {</span></span>
<span><span class="co">#&gt;   int&lt;lower=0&gt; total_obs; // total number of observations</span></span>
<span><span class="co">#&gt;   int&lt;lower=0&gt; n; // number of timepoints per series</span></span>
<span><span class="co">#&gt;   int&lt;lower=0&gt; n_sp; // number of smoothing parameters</span></span>
<span><span class="co">#&gt;   int&lt;lower=0&gt; n_series; // number of series</span></span>
<span><span class="co">#&gt;   int&lt;lower=0&gt; num_basis; // total number of basis coefficients</span></span>
<span><span class="co">#&gt;   vector[num_basis] zero; // prior locations for basis coefficients</span></span>
<span><span class="co">#&gt;   matrix[total_obs, num_basis] X; // mgcv GAM design matrix</span></span>
<span><span class="co">#&gt;   array[n, n_series] int&lt;lower=0&gt; ytimes; // time-ordered matrix (which col in X belongs to each [time, series] observation?)</span></span>
<span><span class="co">#&gt;   matrix[14, 28] S1; // mgcv smooth penalty matrix S1</span></span>
<span><span class="co">#&gt;   int&lt;lower=0&gt; n_nonmissing; // number of nonmissing observations</span></span>
<span><span class="co">#&gt;   array[n_nonmissing] int&lt;lower=0&gt; flat_ys; // flattened nonmissing observations</span></span>
<span><span class="co">#&gt;   matrix[n_nonmissing, num_basis] flat_xs; // X values for nonmissing observations</span></span>
<span><span class="co">#&gt;   array[n_nonmissing] int&lt;lower=0&gt; obs_ind; // indices of nonmissing observations</span></span>
<span><span class="co">#&gt; }</span></span>
<span><span class="co">#&gt; parameters {</span></span>
<span><span class="co">#&gt;   // raw basis coefficients</span></span>
<span><span class="co">#&gt;   vector[num_basis] b_raw;</span></span>
<span><span class="co">#&gt;   </span></span>
<span><span class="co">#&gt;   // smoothing parameters</span></span>
<span><span class="co">#&gt;   vector&lt;lower=0&gt;[n_sp] lambda;</span></span>
<span><span class="co">#&gt; }</span></span>
<span><span class="co">#&gt; transformed parameters {</span></span>
<span><span class="co">#&gt;   // basis coefficients</span></span>
<span><span class="co">#&gt;   vector[num_basis] b;</span></span>
<span><span class="co">#&gt;   b[1 : num_basis] = b_raw[1 : num_basis];</span></span>
<span><span class="co">#&gt; }</span></span>
<span><span class="co">#&gt; model {</span></span>
<span><span class="co">#&gt;   // prior for (Intercept)...</span></span>
<span><span class="co">#&gt;   b_raw[1] ~ student_t(3, 1.4, 2.5);</span></span>
<span><span class="co">#&gt;   </span></span>
<span><span class="co">#&gt;   // prior for ndvi_ma12...</span></span>
<span><span class="co">#&gt;   b_raw[2] ~ student_t(3, 0, 2);</span></span>
<span><span class="co">#&gt;   </span></span>
<span><span class="co">#&gt;   // prior for s(time)...</span></span>
<span><span class="co">#&gt;   b_raw[3 : 16] ~ multi_normal_prec(zero[3 : 16],</span></span>
<span><span class="co">#&gt;                                     S1[1 : 14, 1 : 14] * lambda[1]</span></span>
<span><span class="co">#&gt;                                     + S1[1 : 14, 15 : 28] * lambda[2]);</span></span>
<span><span class="co">#&gt;   </span></span>
<span><span class="co">#&gt;   // priors for smoothing parameters</span></span>
<span><span class="co">#&gt;   lambda ~ normal(5, 30);</span></span>
<span><span class="co">#&gt;   {</span></span>
<span><span class="co">#&gt;     // likelihood functions</span></span>
<span><span class="co">#&gt;     flat_ys ~ poisson_log_glm(flat_xs, 0.0, b);</span></span>
<span><span class="co">#&gt;   }</span></span>
<span><span class="co">#&gt; }</span></span>
<span><span class="co">#&gt; generated quantities {</span></span>
<span><span class="co">#&gt;   vector[total_obs] eta;</span></span>
<span><span class="co">#&gt;   matrix[n, n_series] mus;</span></span>
<span><span class="co">#&gt;   vector[n_sp] rho;</span></span>
<span><span class="co">#&gt;   array[n, n_series] int ypred;</span></span>
<span><span class="co">#&gt;   rho = log(lambda);</span></span>
<span><span class="co">#&gt;   </span></span>
<span><span class="co">#&gt;   // posterior predictions</span></span>
<span><span class="co">#&gt;   eta = X * b;</span></span>
<span><span class="co">#&gt;   for (s in 1 : n_series) {</span></span>
<span><span class="co">#&gt;     mus[1 : n, s] = eta[ytimes[1 : n, s]];</span></span>
<span><span class="co">#&gt;     ypred[1 : n, s] = poisson_log_rng(mus[1 : n, s]);</span></span>
<span><span class="co">#&gt;   }</span></span>
<span><span class="co">#&gt; }</span></span></code></pre></div>
<p>The line below <code>// prior for s(time)...</code> shows how the
spline basis coefficients are drawn from a zero-centred multivariate
normal distribution. The precision matrix <span class="math inline">\(S\)</span> is penalized by two different smoothing
parameters (the <span class="math inline">\(\lambda\)</span>’s) to
enforce smoothness and reduce overfitting</p>
</div>
<div class="section level2">
<h2 id="latent-dynamics-in-mvgam">Latent dynamics in <code>mvgam</code><a class="anchor" aria-label="anchor" href="#latent-dynamics-in-mvgam"></a>
</h2>
<p>Forecasts from the above model are not ideal:</p>
<div class="sourceCode" id="cb38"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">model3</span>, type <span class="op">=</span> <span class="st">"forecast"</span>, newdata <span class="op">=</span> <span class="va">data_test</span><span class="op">)</span></span></code></pre></div>
<p><img src="mvgam_overview_files/figure-html/unnamed-chunk-26-1.png" width="60%" style="display: block; margin: auto;"></p>
<p>Why is this happening? The forecasts are driven almost entirely by
variation in the temporal spline, which is extrapolating linearly
<em>forever</em> beyond the edge of the training data. Any slight
wiggles near the end of the training set will result in wildly different
forecasts. To visualize this, we can plot the extrapolated temporal
functions into the out-of-sample test set for the two models. Here are
the extrapolated functions for the first model, with 15 basis
functions:</p>
<div class="sourceCode" id="cb39"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/plot_mvgam_smooth.html">plot_mvgam_smooth</a></span><span class="op">(</span><span class="va">model3</span>,</span>
<span>  smooth <span class="op">=</span> <span class="st">"s(time)"</span>,</span>
<span>  <span class="co"># feed newdata to the plot function to generate</span></span>
<span>  <span class="co"># predictions of the temporal smooth to the end of the</span></span>
<span>  <span class="co"># testing period</span></span>
<span>  newdata <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span></span>
<span>    time <span class="op">=</span> <span class="fl">1</span><span class="op">:</span><span class="fu"><a href="https://rdrr.io/r/base/Extremes.html" class="external-link">max</a></span><span class="op">(</span><span class="va">data_test</span><span class="op">$</span><span class="va">time</span><span class="op">)</span>,</span>
<span>    ndvi_ma12 <span class="op">=</span> <span class="fl">0</span></span>
<span>  <span class="op">)</span></span>
<span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/abline.html" class="external-link">abline</a></span><span class="op">(</span>v <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/Extremes.html" class="external-link">max</a></span><span class="op">(</span><span class="va">data_train</span><span class="op">$</span><span class="va">time</span><span class="op">)</span>, lty <span class="op">=</span> <span class="st">"dashed"</span>, lwd <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span></code></pre></div>
<p><img src="mvgam_overview_files/figure-html/Plot%20extrapolated%20temporal%20functions%20using%20newdata-1.png" width="60%" style="display: block; margin: auto;"></p>
<p>This model is not doing well. Clearly we need to somehow account for
the strong temporal autocorrelation when modelling these data without
using a smooth function of <code>time</code>. Now onto another prominent
feature of <code>mvgam</code>: the ability to include (possibly latent)
autocorrelated residuals in regression models. To do so, we use the
<code>trend_model</code> argument (see <code><a href="../reference/mvgam_trends.html">?mvgam_trends</a></code> for
details of different dynamic trend models that are supported). This
model will use a separate sub-model for latent residuals that evolve as
an AR1 process (i.e. the error in the current time point is a function
of the error in the previous time point, plus some stochastic noise). We
also include a smooth function of <code>ndvi_ma12</code> in this model,
rather than the parametric term that was used above, to showcase that
<code>mvgam</code> can include combinations of smooths and dynamic
components:</p>
<div class="sourceCode" id="cb40"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">model4</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/mvgam.html">mvgam</a></span><span class="op">(</span><span class="va">count</span> <span class="op">~</span> <span class="fu"><a href="https://rdrr.io/pkg/mgcv/man/s.html" class="external-link">s</a></span><span class="op">(</span><span class="va">ndvi_ma12</span>, k <span class="op">=</span> <span class="fl">6</span><span class="op">)</span>,</span>
<span>  family <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/family.html" class="external-link">poisson</a></span><span class="op">(</span><span class="op">)</span>,</span>
<span>  data <span class="op">=</span> <span class="va">data_train</span>,</span>
<span>  newdata <span class="op">=</span> <span class="va">data_test</span>,</span>
<span>  trend_model <span class="op">=</span> <span class="fu"><a href="../reference/RW.html">AR</a></span><span class="op">(</span><span class="op">)</span></span>
<span><span class="op">)</span></span></code></pre></div>
<p>The model can be described mathematically as follows: <span class="math display">\[\begin{align*}
\boldsymbol{count}_t &amp; \sim \text{Poisson}(\lambda_t) \\
log(\lambda_t) &amp; = f(\boldsymbol{ndvi})_t + z_t \\
z_t &amp; \sim \text{Normal}(ar1 * z_{t-1}, \sigma_{error}) \\
ar1 &amp; \sim \text{Normal}(0, 1)[-1, 1] \\
\sigma_{error} &amp; \sim \text{Exponential}(2) \\
f(\boldsymbol{ndvi}) &amp; = \sum_{k=1}^{K}b * \beta_{smooth} \\
\beta_{smooth} &amp; \sim \text{MVNormal}(0, (\Omega * \lambda)^{-1})
\end{align*}\]</span></p>
<p>Here the term <span class="math inline">\(z_t\)</span> captures
autocorrelated latent residuals, which are modelled using an AR1
process. You can also notice that this model is estimating
autocorrelated errors for the full time period, even though some of
these time points have missing observations. This is useful for getting
more realistic estimates of the residual autocorrelation parameters.
Summarise the model to see how it now returns posterior summaries for
the latent AR1 process:</p>
<div class="sourceCode" id="cb41"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">model4</span><span class="op">)</span></span>
<span><span class="co">#&gt; GAM formula:</span></span>
<span><span class="co">#&gt; count ~ s(ndvi_ma12, k = 6)</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Family:</span></span>
<span><span class="co">#&gt; poisson</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Link function:</span></span>
<span><span class="co">#&gt; log</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Trend model:</span></span>
<span><span class="co">#&gt; AR()</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; N series:</span></span>
<span><span class="co">#&gt; 1 </span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; N timepoints:</span></span>
<span><span class="co">#&gt; 80 </span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Status:</span></span>
<span><span class="co">#&gt; Fitted using Stan </span></span>
<span><span class="co">#&gt; 4 chains, each with iter = 1000; warmup = 500; thin = 1 </span></span>
<span><span class="co">#&gt; Total post-warmup draws = 2000</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; GAM coefficient (beta) estimates:</span></span>
<span><span class="co">#&gt;                  2.5%     50% 97.5% Rhat n_eff</span></span>
<span><span class="co">#&gt; (Intercept)    -0.790  0.6900 2.000 1.01   108</span></span>
<span><span class="co">#&gt; s(ndvi_ma12).1 -0.150  0.0090 0.240 1.01   487</span></span>
<span><span class="co">#&gt; s(ndvi_ma12).2 -0.270 -0.0080 0.160 1.02   321</span></span>
<span><span class="co">#&gt; s(ndvi_ma12).3 -0.084 -0.0026 0.056 1.02   326</span></span>
<span><span class="co">#&gt; s(ndvi_ma12).4 -0.370  0.0270 0.870 1.02   258</span></span>
<span><span class="co">#&gt; s(ndvi_ma12).5 -0.290  0.0800 0.520 1.01   630</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Approximate significance of GAM smooths:</span></span>
<span><span class="co">#&gt;              edf Ref.df Chi.sq p-value</span></span>
<span><span class="co">#&gt; s(ndvi_ma12) 1.4      5   0.55    0.99</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Latent trend parameter AR estimates:</span></span>
<span><span class="co">#&gt;          2.5%  50% 97.5% Rhat n_eff</span></span>
<span><span class="co">#&gt; ar1[1]   0.62 0.83  0.98 1.01   297</span></span>
<span><span class="co">#&gt; sigma[1] 0.58 0.79  1.10 1.01   304</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Stan MCMC diagnostics:</span></span>
<span><span class="co">#&gt; ✔ No issues with effective samples per iteration</span></span>
<span><span class="co">#&gt; ✔ Rhat looks good for all parameters</span></span>
<span><span class="co">#&gt; ✔ No issues with divergences</span></span>
<span><span class="co">#&gt; ✔ No issues with maximum tree depth</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Samples were drawn using sampling(hmc). For each parameter, n_eff is a</span></span>
<span><span class="co">#&gt;   crude measure of effective sample size, and Rhat is the potential scale</span></span>
<span><span class="co">#&gt;   reduction factor on split MCMC chains (at convergence, Rhat = 1)</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Use how_to_cite() to get started describing this model</span></span></code></pre></div>
<p>View posterior hindcasts / forecasts and compare against the out of
sample test data</p>
<div class="sourceCode" id="cb42"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">model4</span>, type <span class="op">=</span> <span class="st">"forecast"</span>, newdata <span class="op">=</span> <span class="va">data_test</span><span class="op">)</span></span></code></pre></div>
<p><img src="mvgam_overview_files/figure-html/unnamed-chunk-28-1.png" width="60%" style="display: block; margin: auto;"></p>
<p>The trend is evolving as an AR1 process, which we can also view:</p>
<div class="sourceCode" id="cb43"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">model4</span>, type <span class="op">=</span> <span class="st">"trend"</span>, newdata <span class="op">=</span> <span class="va">data_test</span><span class="op">)</span></span></code></pre></div>
<p><img src="mvgam_overview_files/figure-html/unnamed-chunk-29-1.png" width="60%" style="display: block; margin: auto;"></p>
<p>In-sample model performance can be interrogated using leave-one-out
cross-validation utilities from the <code>loo</code> package (a higher
value is preferred for this metric):</p>
<div class="sourceCode" id="cb44"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://mc-stan.org/loo/reference/loo_compare.html" class="external-link">loo_compare</a></span><span class="op">(</span><span class="va">model3</span>, <span class="va">model4</span><span class="op">)</span></span>
<span><span class="co">#&gt;        elpd_diff se_diff</span></span>
<span><span class="co">#&gt; model4  0.0       0.0   </span></span>
<span><span class="co">#&gt; model3 -3.1       5.4</span></span></code></pre></div>
<p>The higher estimated log predictive density (ELPD) value for the
dynamic model suggests it provides a better fit to the in-sample
data.</p>
<p>Though it should be obvious that this model provides better
forecasts, we can quantify forecast performance for models 3 and 4 using
the <code>forecast</code> and <code>score</code> functions. Here we will
compare models based on their Discrete Ranked Probability Scores (a
lower value is preferred for this metric)</p>
<div class="sourceCode" id="cb45"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">fc_mod3</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/forecast.mvgam.html">forecast</a></span><span class="op">(</span><span class="va">model3</span><span class="op">)</span></span>
<span><span class="va">fc_mod4</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/forecast.mvgam.html">forecast</a></span><span class="op">(</span><span class="va">model4</span><span class="op">)</span></span>
<span><span class="va">score_mod3</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/score.mvgam_forecast.html">score</a></span><span class="op">(</span><span class="va">fc_mod3</span>, score <span class="op">=</span> <span class="st">"drps"</span><span class="op">)</span></span>
<span><span class="va">score_mod4</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/score.mvgam_forecast.html">score</a></span><span class="op">(</span><span class="va">fc_mod4</span>, score <span class="op">=</span> <span class="st">"drps"</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/sum.html" class="external-link">sum</a></span><span class="op">(</span><span class="va">score_mod4</span><span class="op">$</span><span class="va">PP</span><span class="op">$</span><span class="va">score</span>, na.rm <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span> <span class="op">-</span> <span class="fu"><a href="https://rdrr.io/r/base/sum.html" class="external-link">sum</a></span><span class="op">(</span><span class="va">score_mod3</span><span class="op">$</span><span class="va">PP</span><span class="op">$</span><span class="va">score</span>, na.rm <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] -685.8634</span></span></code></pre></div>
<p>A strongly negative value here suggests the score for the dynamic
model (model 4) is much smaller than the score for the model with a
smooth function of time (model 3)</p>
</div>
<div class="section level2">
<h2 id="further-reading">Further reading<a class="anchor" aria-label="anchor" href="#further-reading"></a>
</h2>
<p>The following papers and resources offer useful material about
Dynamic GAMs and how they can be applied in practice:</p>
<p>Clark, Nicholas J. and Wells, K. <a href="https://doi.org/10.1111/2041-210X.13974" class="external-link">Dynamic Generalized
Additive Models (DGAMs) for forecasting discrete ecological time
series</a>. <em>Methods in Ecology and Evolution</em>. (2023): 14,
771-784.</p>
<p>Clark, Nicholas J., et al. <a href="https://peerj.com/articles/18929/" class="external-link">Beyond single-species models:
leveraging multispecies forecasts to navigate the dynamics of ecological
predictability</a>. <em>PeerJ</em>. (2025): 13:e18929</p>
<p>de Sousa, Heitor C., et al. <a href="https://doi.org/10.1111/1365-2656.14188" class="external-link">Severe fire regimes
decrease resilience of ectothermic populations</a>. <em>Journal of
Animal Ecology</em> (2024): 93(11), 1656-1669.</p>
<p>Hannaford, Naomi E., et al. <a href="https://doi.org/10.1016/j.csda.2022.107659" class="external-link">A sparse Bayesian
hierarchical vector autoregressive model for microbial dynamics in a
wastewater treatment plant.</a> <em>Computational Statistics &amp; Data
Analysis</em> (2023): 179, 107659.</p>
<p>Karunarathna, K.A.N.K., et al. <a href="https://doi.org/10.1016/j.ecolmodel.2024.110648" class="external-link">Modelling
nonlinear responses of a desert rodent species to environmental change
with hierarchical dynamic generalized additive models</a>.
<em>Ecological Modelling</em> (2024): 490, 110648.</p>
<p>Zhu, L., et al. <a href="https://doi.org/10.1111/1365-2435.14711" class="external-link">Responses of a widespread
pest insect to extreme high temperatures are stage-dependent and
divergent among seasonal cohorts</a>. <em>Functional Ecology</em>
(2025): 39, 165–180. <a href="https://doi.org/10.1111/1365-2435.14711" class="external-link uri">https://doi.org/10.1111/1365-2435.14711</a></p>
</div>
<div class="section level2">
<h2 id="interested-in-contributing">Interested in contributing?<a class="anchor" aria-label="anchor" href="#interested-in-contributing"></a>
</h2>
<p>I’m actively seeking PhD students and other researchers to work in
the areas of ecological forecasting, multivariate model evaluation and
development of <code>mvgam</code>. Please see <a href="https://ecogambler.netlify.app/opportunities/" class="external-link">this small list of
opportunities on my website</a> and do reach out if you are interested
(n.clark’at’uq.edu.au)</p>
</div>
  </main><aside class="col-md-3"><nav id="toc"><h2>On this page</h2>
    </nav></aside>
</div>



    <footer><div class="pkgdown-footer-left">
  <p>Developed by <a href="https://researchers.uq.edu.au/researcher/15140" class="external-link">Nicholas J Clark</a>.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.0.9.</p>
</div>

    </footer>
</div>

  

  

  </body>
</html>
