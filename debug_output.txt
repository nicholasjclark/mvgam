Loading required package: usethis
Warning messages:
1: package 'devtools' was built under R version 4.4.2 
2: package 'usethis' was built under R version 4.4.2 
Loading required package: Rcpp
Loading 'brms' package (version 2.22.9). Useful instructions
can be found by typing help('brms'). A more detailed introduction
to the package is available through vignette('brms_overview').

Attaching package: 'brms'

The following object is masked from 'package:stats':

    ar

Warning message:
package 'Rcpp' was built under R version 4.4.2 
ℹ Loading mvgam
Loading 'mvgam' (version 2.0.0). Useful instructions can be found by
  typing help('mvgam'). A more detailed introduction to the package is
  available through vignette('mvgam_overview'). Full brms compatibility is
  now enabled.
Warning message:
package 'testthat' was built under R version 4.4.2 
🔍 COMPREHENSIVE MU_TREND INTERNAL DEBUGGING SCRIPT
====================================================================

📊 TESTING DATA STRUCTURE:
🔍 Test Data Summary:
   univariate_rows: 24
   multivariate_rows: 72
   univariate_columns: time, series, y, x, temperature, income
   multivariate_columns: time, series, count, biomass, presence, x, temperature, income
   y_range: 2 to 11
   time_range_uni: 1 to 24
   time_range_multi: 1 to 24

🧪 RUNNING COMPREHENSIVE TESTS ACROSS TREND FORMULA COMPLEXITIES
====================================================================

🔬 SCENARIO: RW Simple (from target_generation.R)
   Main Formula: structure(list(formula = y ~ x, pforms = list(), pfix = list(), 
    Main Formula:     family = structure(list(family = "poisson", link = "log", 
    Main Formula:         linkfun = function (mu) 
    Main Formula:         link(mu, link = slink), linkinv = function (eta) 
    Main Formula:         inv_link(eta, link = slink), dpars = "mu", type = "int", 
    Main Formula:         ybounds = c(0, Inf), closed = c(TRUE, NA), ad = c("weights", 
    Main Formula:         "subset", "cens", "trunc", "rate", "index"), specials = "sbi_log"), class = c("brmsfamily", 
    Main Formula:     "family")), resp = "y"), class = c("brmsformula", "bform"
    Main Formula: ))
   Trend Formula: ~1
   Data Type: univariate

🔍 Running full mvgam pipeline:
   RW_simple

🔍 MVGAM FORMULA CREATED:
   formula: structure(list(formula = y ~ x, pforms = list(), pfix = list(), ;     family = structure(list(family = "poisson", link = "log", ;         linkfun = function (mu) ;         link(mu, link = slink), linkinv = function (eta) ;         inv_link(eta, link = slink), dpars = "mu", type = "int", ;         ybounds = c(0, Inf), closed = c(TRUE, NA), ad = c("weights", ;         "subset", "cens", "trunc", "rate", "index"), specials = "sbi_log"), class = c("brmsfamily", ;     "family")), resp = "y"), class = c("brmsformula", "bform"; ))
   trend_formula: ~1
   data_rows: 24

  🔍 EXTRACT_AND_RENAME INPUT:
     scenario: RW_simple
     suffix: _trend
     is_multivariate: FALSE
     response_names: 
     stancode_preview: // generated with brms 2.22.9
functions {
}
data {
  int<lower=1> N;  // total number of observations
  vector[N] Y;  // response variable
  int prior_only;  // should the likelihood be ignored?
}
transformed data {
}
parameters {
  real Intercept;  // temporary intercept for centered predictors
  r
     mapping_summary: original_to_renamed: 0 items, renamed_to_original: 0 items

  🔍 EXTRACT_COMPUTED_VARIABLES:
     scenario: RW_simple
     found_variables: NONE FOUND

  🔍 EXTRACT_COMPUTED_VARIABLES:
     scenario: RW_simple
     found_variables: NONE FOUND

  🔍 EXTRACT_COMPUTED_VARIABLES:
     scenario: RW_simple
     found_variables: NONE FOUND

  🔍 EXTRACT_MU_CONSTRUCTION INPUT:
     scenario: RW_simple
     stancode_length: 941
     stancode_preview: // generated with brms 2.22.9
functions {
}
data {
  int<lower=1> N;  // total number of observations
  vector[N] Y;  // response variable
  int prior_only;  // should the likelihood be ignored?
}
tra

  🔍 FIND_VARIABLE_DECLARATIONS INPUT:
     scenario: RW_simple
     stancode_length: 941
     referenced_vars_count: 3
     referenced_vars: N, mu, Intercept

  🔍 FIND_VARIABLE_DECLARATIONS OUTPUT:
     found_declarations_count: 3
     found_declarations: int<lower=1> N;  // total number of observations; vector[N] Y;  // response variable; real Intercept;  // temporary intercept for centered predictors
     missing_vars: N, mu, Intercept

  🔍 EXTRACT_MU_CONSTRUCTION OUTPUT:
     mu_construction_count: 2
     mu_construction: vector[N] mu = rep_vector(0.0, N);; mu += Intercept;
     supporting_declarations_count: 3
     supporting_declarations: int<lower=1> N;  // total number of observations; vector[N] Y;  // response variable; real Intercept;  // temporary intercept for centered predictors
     referenced_variables_count: 3
     referenced_variables: N; mu; Intercept

  🔍 EXTRACT_COMPUTED_VARIABLES:
     scenario: RW_simple
     found_variables: mu; b_Intercept

  🔍 FIND_VARIABLE_DECLARATIONS INPUT:
     scenario: RW_simple
     stancode_length: 941
     referenced_vars_count: 1
     referenced_vars: mu

  🔍 FIND_VARIABLE_DECLARATIONS OUTPUT:
     found_declarations_count: 0
     found_declarations: NONE FOUND
     missing_vars: mu

  🔍 RECONSTRUCT_MU_TREND INPUT:
     scenario: RW_simple
     mu_construction_count: 2
     mu_construction: vector[N] mu = rep_vector(0.0, N);; mu += Intercept;
     supporting_declarations_count: 3
     supporting_declarations: int<lower=1> N;  // total number of observations; vector[N] Y;  // response variable; real Intercept;  // temporary intercept for centered predictors
     variable_mapping_count: 3
     variable_mapping: N -> N_trend; Intercept -> Intercept_trend; mu -> mu_trend
     time_param: N_trend

    🔍 STEP-BY-STEP RECONSTRUCTION ANALYSIS:
       step: 1_INPUT_ANALYSIS
       original_mu_expressions: vector[N] mu = rep_vector(0.0, N);; mu += Intercept;
       has_mu_initialization: TRUE
       has_mu_assignments: TRUE
       has_variable_declarations: TRUE

    🔍 STEP-BY-STEP RECONSTRUCTION ANALYSIS:
       step: 2_OUTPUT_ANALYSIS
       transformed_expressions: vector[N_trend] mu_trend = rep_vector(0.0, N_trend);; mu_trend += Intercept_trend;
       has_mu_trend_initialization: TRUE
       mu_trend_init_count: 1
       has_mu_trend_assignments: TRUE
       duplicate_initialization_detected: FALSE

      🔍 RECONSTRUCTION LINE ANALYSIS:
         line_number: 1
         content: vector[N_trend] mu_trend = rep_vector(0.0, N_trend);
         is_mu_trend_init: TRUE
         is_mu_trend_assignment: FALSE
         is_supporting_declaration: FALSE
         line_type: INITIALIZATION

      🔍 RECONSTRUCTION LINE ANALYSIS:
         line_number: 2
         content: mu_trend += Intercept_trend;
         is_mu_trend_init: FALSE
         is_mu_trend_assignment: TRUE
         is_supporting_declaration: FALSE
         line_type: ASSIGNMENT

  🔍 RECONSTRUCT_MU_TREND OUTPUT:
     result_length: 2
     result: vector[N_trend] mu_trend = rep_vector(0.0, N_trend);; mu_trend += Intercept_trend;

  🔍 STANVAR CREATION DECISION:
     has_mu_construction: FALSE
     logic: Fallback system should create stanvar

  🔍 EXTRACT_AND_RENAME OUTPUT:
     stanvars_count: 3
     stanvar_names: ; ; 
     mapping_updated: original_to_renamed: 3 items, renamed_to_original: 3 items

🔍 LINEAR PREDICTOR INJECTION:
   scenario: RW_simple
   message: Checking if Enhanced system or GLM bypass will be used

🔍 GLM BYPASS DETECTED:
   scenario: RW_simple
   message: GLM path bypassing Enhanced mu_trend Construction System
   args_count: 3

🔍 GLM BYPASS RESULT:
   scenario: RW_simple
   result_length: 3253

🔍 LINEAR PREDICTOR RESULT:
   scenario: RW_simple
   result_type: character; brmsmodel
   glm_bypass_occurred: FALSE

🔍 ERROR IN SCENARIO:
No traceback available 
   scenario: RW_simple
   error: Error: Assertion on 'formula' failed: One of the following must apply:
 * checkmate::check_class(formula): Must inherit from class 'formula',
 * but has classes 'brmsformula','bform'
 * checkmate::check_class(formula): Must inherit from class
 * 'mvbrmsformula', but has classes 'brmsformula','bform'.

   traceback: 

────────────────────────────────────────────────────────────────────

🔬 SCENARIO: VARMA Complex (from target_generation.R)
   Main Formula: structure(list(forms = list(count = structure(list(formula = count ~ 
    Main Formula:     s(x), pforms = list(), pfix = list(), resp = "count", family = NULL), class = c("brmsformula", 
    Main Formula: "bform")), biomass = structure(list(formula = biomass ~ s(x), 
    Main Formula:     pforms = list(), pfix = list(), resp = "biomass", family = NULL), class = c("brmsformula", 
    Main Formula: "bform"))), responses = c("count", "biomass"), rescor = FALSE), class = c("mvbrmsformula", 
    Main Formula: "bform"))
   Trend Formula: ~presence + VAR(p = 2, ma = TRUE)
   Data Type: multivariate

🔍 Running full mvgam pipeline:
   VARMA_complex

🔍 MVGAM FORMULA CREATED:
   formula: structure(list(forms = list(count = structure(list(formula = count ~ ;     s(x), pforms = list(), pfix = list(), resp = "count", family = NULL), class = c("brmsformula", ; "bform")), biomass = structure(list(formula = biomass ~ s(x), ;     pforms = list(), pfix = list(), resp = "biomass", family = NULL), class = c("brmsformula", ; "bform"))), responses = c("count", "biomass"), rescor = FALSE), class = c("mvbrmsformula", ; "bform"))
   trend_formula: ~presence + VAR(p = 2, ma = TRUE)
   data_rows: 72

  🔍 EXTRACT_AND_RENAME INPUT:
     scenario: VARMA_complex
     suffix: _trend
     is_multivariate: FALSE
     response_names: 
     stancode_preview: // generated with brms 2.22.9
functions {
}
data {
  int<lower=1> N;  // total number of observations
  vector[N] Y;  // response variable
  int<lower=1> K;  // number of population-level effects
  matrix[N, K] X;  // population-level design matrix
  int<lower=1> Kc;  // number of population-level e
     mapping_summary: original_to_renamed: 0 items, renamed_to_original: 0 items

  🔍 EXTRACT_COMPUTED_VARIABLES:
     scenario: VARMA_complex
     found_variables: NONE FOUND

  🔍 EXTRACT_COMPUTED_VARIABLES:
     scenario: VARMA_complex
     found_variables: NONE FOUND

  🔍 EXTRACT_COMPUTED_VARIABLES:
     scenario: VARMA_complex
     found_variables: NONE FOUND

  🔍 EXTRACT_COMPUTED_VARIABLES:
     scenario: VARMA_complex
     found_variables: NONE FOUND

  🔍 EXTRACT_MU_CONSTRUCTION INPUT:
     scenario: VARMA_complex
     stancode_length: 1342
     stancode_preview: // generated with brms 2.22.9
functions {
}
data {
  int<lower=1> N;  // total number of observations
  vector[N] Y;  // response variable
  int<lower=1> K;  // number of population-level effects
  ma

  🔍 EXTRACT_MU_CONSTRUCTION OUTPUT:
     mu_construction_count: 0
     mu_construction: NONE FOUND
     supporting_declarations_count: 0
     supporting_declarations: NONE FOUND
     referenced_variables_count: 0
     referenced_variables: NONE FOUND

  🔍 STANVAR CREATION DECISION:
     has_mu_construction: FALSE
     logic: Fallback system should create stanvar

  🔍 EXTRACT_AND_RENAME OUTPUT:
     stanvars_count: 4
     stanvar_names: ; ; ; 
     mapping_updated: original_to_renamed: 10 items, renamed_to_original: 10 items

🔍 STANCODE GENERATED:
   stancode_length: 22902
   contains_mu_trend: TRUE
   mu_trend_count: 12
   contains_gp_pred: FALSE
   contains_vector_mu_trend: TRUE
   stancode_preview: // generated with brms 2.22.9
functions {
  
      /**
       * Compute matrix square root using eigendecomposition
       * Following Heaps 2022 methodology for stationary VAR/VARMA
       * @param A Symmetric positive definite matrix (m x m)
       * @return Matrix square root of A
       */
      matrix sqrtm(matrix A) {
        int m = rows(A);
        vector[m] eigenvals = eigenvalues_sym(A);

        // Numerical stability check for positive definiteness
        if (min(eigenvals) <= 1e-12) {
          reject("Matrix must be positive definite for square root computation");
        }

        vector[m] root_root_evals = sqrt(sqrt(eigenvals));
        matrix[m, m] evecs = eigenvectors_sym(A);
        matrix[m, m] eprod = diag_post_multiply(evecs, root_root_evals);
        return tcrossprod(eprod);
      }

      /**
       * Transform P_real to P matrix using partial autocorrelation approach
       * Heaps 2022 transformation for stationarity constraints
       * @param P_real Real

🔍 MU_TREND PATTERN ANALYSIS:
   total_mu_trend_lines: 12
   mu_trend_declarations: 1
   mu_trend_assignments: 1
   mu_trend_references: 7
   sample_lines:   array[2] vector[1] Amu_trend;     // Shared means; array[2] vector[1] Dmu_trend;           // Means for D_raw_trend elements;   vector[N_trend] mu_trend = rep_vector(0.0, N_trend);

────────────────────────────────────────────────────────────────────

🔬 SCENARIO: GP + CAR Complex (from target_generation.R)
   Main Formula: structure(list(formula = y ~ (1 | series), pforms = list(), pfix = list(), 
    Main Formula:     family = structure(list(family = "poisson", link = "log", 
    Main Formula:         linkfun = function (mu) 
    Main Formula:         link(mu, link = slink), linkinv = function (eta) 
    Main Formula:         inv_link(eta, link = slink), dpars = "mu", type = "int", 
    Main Formula:         ybounds = c(0, Inf), closed = c(TRUE, NA), ad = c("weights", 
    Main Formula:         "subset", "cens", "trunc", "rate", "index"), specials = "sbi_log"), class = c("brmsfamily", 
    Main Formula:     "family")), resp = "y"), class = c("brmsformula", "bform"
    Main Formula: ))
   Trend Formula: ~gp(x) + CAR()
   Data Type: univariate

🔍 Running full mvgam pipeline:
   GP_CAR_complex

🔍 MVGAM FORMULA CREATED:
   formula: structure(list(formula = y ~ (1 | series), pforms = list(), pfix = list(), ;     family = structure(list(family = "poisson", link = "log", ;         linkfun = function (mu) ;         link(mu, link = slink), linkinv = function (eta) ;         inv_link(eta, link = slink), dpars = "mu", type = "int", ;         ybounds = c(0, Inf), closed = c(TRUE, NA), ad = c("weights", ;         "subset", "cens", "trunc", "rate", "index"), specials = "sbi_log"), class = c("brmsfamily", ;     "family")), resp = "y"), class = c("brmsformula", "bform"; ))
   trend_formula: ~gp(x) + CAR()
   data_rows: 24

  🔍 EXTRACT_AND_RENAME INPUT:
     scenario: GP_CAR_complex
     suffix: _trend
     is_multivariate: FALSE
     response_names: 
     stancode_preview: // generated with brms 2.22.9
functions {
  /* compute a latent Gaussian process with squared exponential kernel
   * Args:
   *   x: array of continuous predictor values
   *   sdgp: marginal SD parameter
   *   lscale: length-scale parameter
   *   zgp: vector of independent standard normal variab
     mapping_summary: original_to_renamed: 0 items, renamed_to_original: 0 items

  🔍 EXTRACT_COMPUTED_VARIABLES:
     scenario: GP_CAR_complex
     found_variables: NONE FOUND

  🔍 EXTRACT_COMPUTED_VARIABLES:
     scenario: GP_CAR_complex
     found_variables: NONE FOUND

  🔍 EXTRACT_COMPUTED_VARIABLES:
     scenario: GP_CAR_complex
     found_variables: NONE FOUND

  🔍 EXTRACT_MU_CONSTRUCTION INPUT:
     scenario: GP_CAR_complex
     stancode_length: 2742
     stancode_preview: // generated with brms 2.22.9
functions {
  /* compute a latent Gaussian process with squared exponential kernel
   * Args:
   *   x: array of continuous predictor values
   *   sdgp: marginal SD para

  🔍 FIND_VARIABLE_DECLARATIONS INPUT:
     scenario: GP_CAR_complex
     stancode_length: 2742
     referenced_vars_count: 5
     referenced_vars: N, mu, Intercept, gp_pred_1, Jgp_1

  🔍 FIND_VARIABLE_DECLARATIONS OUTPUT:
     found_declarations_count: 4
     found_declarations: int<lower=1> N;  // total number of observations; vector[N] Y;  // response variable; array[N] int<lower=1> Jgp_1;; real Intercept;  // temporary intercept for centered predictors
     missing_vars: N, mu, Intercept, gp_pred_1, Jgp_1

  🔍 EXTRACT_MU_CONSTRUCTION OUTPUT:
     mu_construction_count: 2
     mu_construction: vector[N] mu = rep_vector(0.0, N);; mu += Intercept + gp_pred_1[Jgp_1];
     supporting_declarations_count: 4
     supporting_declarations: int<lower=1> N;  // total number of observations; vector[N] Y;  // response variable; array[N] int<lower=1> Jgp_1;; real Intercept;  // temporary intercept for centered predictors
     referenced_variables_count: 5
     referenced_variables: N; mu; Intercept; gp_pred_1; Jgp_1

  🔍 EXTRACT_COMPUTED_VARIABLES:
     scenario: GP_CAR_complex
     found_variables: Dls; N; gp_pred_1; mu; b_Intercept; cov gp_exp_quad_cov(x, sdgp, lscale[1]);; cov gp_exp_quad_cov(x[, 1], sdgp, lscale[1]);; cov cov .* gp_exp_quad_cov(x[, d], 1, lscale[d]);

  🔍 FIND_VARIABLE_DECLARATIONS INPUT:
     scenario: GP_CAR_complex
     stancode_length: 2742
     referenced_vars_count: 2
     referenced_vars: mu, gp_pred_1

  🔍 FIND_VARIABLE_DECLARATIONS OUTPUT:
     found_declarations_count: 0
     found_declarations: NONE FOUND
     missing_vars: mu, gp_pred_1

  🔍 RECONSTRUCT_MU_TREND INPUT:
     scenario: GP_CAR_complex
     mu_construction_count: 2
     mu_construction: vector[N] mu = rep_vector(0.0, N);; mu += Intercept + gp_pred_1[Jgp_1];
     supporting_declarations_count: 4
     supporting_declarations: int<lower=1> N;  // total number of observations; vector[N] Y;  // response variable; array[N] int<lower=1> Jgp_1;; real Intercept;  // temporary intercept for centered predictors
     variable_mapping_count: 12
     variable_mapping: Nsubgp_1 -> Nsubgp_1_trend; Kgp_1 -> Kgp_1_trend; Dgp_1 -> Dgp_1_trend; Jgp_1 -> Jgp_1_trend; Xgp_1 -> Xgp_1_trend; N -> N_trend; Intercept -> Intercept_trend; lscale_1 -> lscale_1_trend; sdgp_1 -> sdgp_1_trend; zgp_1 -> zgp_1_trend; mu -> mu_trend; gp_pred_1 -> gp_pred_1_trend
     time_param: N_trend

    🔍 STEP-BY-STEP RECONSTRUCTION ANALYSIS:
       step: 1_INPUT_ANALYSIS
       original_mu_expressions: vector[N] mu = rep_vector(0.0, N);; mu += Intercept + gp_pred_1[Jgp_1];
       has_mu_initialization: TRUE
       has_mu_assignments: TRUE
       has_variable_declarations: TRUE

    🔍 STEP-BY-STEP RECONSTRUCTION ANALYSIS:
       step: 2_OUTPUT_ANALYSIS
       transformed_expressions: vector[N_trend] mu_trend = rep_vector(0.0, N_trend);; mu_trend += Intercept_trend + gp_pred_1_trend[Jgp_1_trend];
       has_mu_trend_initialization: TRUE
       mu_trend_init_count: 1
       has_mu_trend_assignments: TRUE
       duplicate_initialization_detected: FALSE

      🔍 RECONSTRUCTION LINE ANALYSIS:
         line_number: 1
         content: vector[N_trend] mu_trend = rep_vector(0.0, N_trend);
         is_mu_trend_init: TRUE
         is_mu_trend_assignment: FALSE
         is_supporting_declaration: FALSE
         line_type: INITIALIZATION

      🔍 RECONSTRUCTION LINE ANALYSIS:
         line_number: 2
         content: mu_trend += Intercept_trend + gp_pred_1_trend[Jgp_1_trend];
         is_mu_trend_init: FALSE
         is_mu_trend_assignment: TRUE
         is_supporting_declaration: FALSE
         line_type: ASSIGNMENT

  🔍 RECONSTRUCT_MU_TREND OUTPUT:
     result_length: 2
     result: vector[N_trend] mu_trend = rep_vector(0.0, N_trend);; mu_trend += Intercept_trend + gp_pred_1_trend[Jgp_1_trend];

  🔍 STANVAR CREATION DECISION:
     has_mu_construction: FALSE
     logic: Fallback system should create stanvar

  🔍 EXTRACT_AND_RENAME OUTPUT:
     stanvars_count: 3
     stanvar_names: ; ; 
     mapping_updated: original_to_renamed: 12 items, renamed_to_original: 12 items

🔍 LINEAR PREDICTOR INJECTION:
   scenario: GP_CAR_complex
   message: Checking if Enhanced system or GLM bypass will be used

🔍 LINEAR PREDICTOR RESULT:
   scenario: GP_CAR_complex
   result_type: character
   glm_bypass_occurred: FALSE

🔍 ERROR IN SCENARIO:
No traceback available 
   scenario: GP_CAR_complex
   error: Error: Assertion on 'formula' failed: One of the following must apply:
 * checkmate::check_class(formula): Must inherit from class 'formula',
 * but has classes 'brmsformula','bform'
 * checkmate::check_class(formula): Must inherit from class
 * 'mvbrmsformula', but has classes 'brmsformula','bform'.

   traceback: 

────────────────────────────────────────────────────────────────────

🔬 SCENARIO: Spline Multivariate (from target_generation.R)
   Main Formula: structure(list(forms = list(count = structure(list(formula = count ~ 
    Main Formula:     s(x), pforms = list(), pfix = list(), resp = "count", family = NULL), class = c("brmsformula", 
    Main Formula: "bform")), biomass = structure(list(formula = biomass ~ s(x), 
    Main Formula:     pforms = list(), pfix = list(), resp = "biomass", family = NULL), class = c("brmsformula", 
    Main Formula: "bform"))), responses = c("count", "biomass"), rescor = FALSE), class = c("mvbrmsformula", 
    Main Formula: "bform"))
   Trend Formula: ~RW(cor = TRUE)
   Data Type: multivariate

🔍 Running full mvgam pipeline:
   Spline_multivariate

🔍 MVGAM FORMULA CREATED:
   formula: structure(list(forms = list(count = structure(list(formula = count ~ ;     s(x), pforms = list(), pfix = list(), resp = "count", family = NULL), class = c("brmsformula", ; "bform")), biomass = structure(list(formula = biomass ~ s(x), ;     pforms = list(), pfix = list(), resp = "biomass", family = NULL), class = c("brmsformula", ; "bform"))), responses = c("count", "biomass"), rescor = FALSE), class = c("mvbrmsformula", ; "bform"))
   trend_formula: ~RW(cor = TRUE)
   data_rows: 72

  🔍 EXTRACT_AND_RENAME INPUT:
     scenario: Spline_multivariate
     suffix: _trend
     is_multivariate: FALSE
     response_names: 
     stancode_preview: // generated with brms 2.22.9
functions {
}
data {
  int<lower=1> N;  // total number of observations
  vector[N] Y;  // response variable
  int prior_only;  // should the likelihood be ignored?
}
transformed data {
}
parameters {
  real Intercept;  // temporary intercept for centered predictors
  r
     mapping_summary: original_to_renamed: 0 items, renamed_to_original: 0 items

  🔍 EXTRACT_COMPUTED_VARIABLES:
     scenario: Spline_multivariate
     found_variables: NONE FOUND

  🔍 EXTRACT_COMPUTED_VARIABLES:
     scenario: Spline_multivariate
     found_variables: NONE FOUND

  🔍 EXTRACT_COMPUTED_VARIABLES:
     scenario: Spline_multivariate
     found_variables: NONE FOUND

  🔍 EXTRACT_MU_CONSTRUCTION INPUT:
     scenario: Spline_multivariate
     stancode_length: 940
     stancode_preview: // generated with brms 2.22.9
functions {
}
data {
  int<lower=1> N;  // total number of observations
  vector[N] Y;  // response variable
  int prior_only;  // should the likelihood be ignored?
}
tra

  🔍 FIND_VARIABLE_DECLARATIONS INPUT:
     scenario: Spline_multivariate
     stancode_length: 940
     referenced_vars_count: 3
     referenced_vars: N, mu, Intercept

  🔍 FIND_VARIABLE_DECLARATIONS OUTPUT:
     found_declarations_count: 3
     found_declarations: int<lower=1> N;  // total number of observations; vector[N] Y;  // response variable; real Intercept;  // temporary intercept for centered predictors
     missing_vars: N, mu, Intercept

  🔍 EXTRACT_MU_CONSTRUCTION OUTPUT:
     mu_construction_count: 2
     mu_construction: vector[N] mu = rep_vector(0.0, N);; mu += Intercept;
     supporting_declarations_count: 3
     supporting_declarations: int<lower=1> N;  // total number of observations; vector[N] Y;  // response variable; real Intercept;  // temporary intercept for centered predictors
     referenced_variables_count: 3
     referenced_variables: N; mu; Intercept

  🔍 EXTRACT_COMPUTED_VARIABLES:
     scenario: Spline_multivariate
     found_variables: mu; b_Intercept

  🔍 FIND_VARIABLE_DECLARATIONS INPUT:
     scenario: Spline_multivariate
     stancode_length: 940
     referenced_vars_count: 1
     referenced_vars: mu

  🔍 FIND_VARIABLE_DECLARATIONS OUTPUT:
     found_declarations_count: 0
     found_declarations: NONE FOUND
     missing_vars: mu

  🔍 RECONSTRUCT_MU_TREND INPUT:
     scenario: Spline_multivariate
     mu_construction_count: 2
     mu_construction: vector[N] mu = rep_vector(0.0, N);; mu += Intercept;
     supporting_declarations_count: 3
     supporting_declarations: int<lower=1> N;  // total number of observations; vector[N] Y;  // response variable; real Intercept;  // temporary intercept for centered predictors
     variable_mapping_count: 3
     variable_mapping: N -> N_trend; Intercept -> Intercept_trend; mu -> mu_trend
     time_param: N_trend

    🔍 STEP-BY-STEP RECONSTRUCTION ANALYSIS:
       step: 1_INPUT_ANALYSIS
       original_mu_expressions: vector[N] mu = rep_vector(0.0, N);; mu += Intercept;
       has_mu_initialization: TRUE
       has_mu_assignments: TRUE
       has_variable_declarations: TRUE

    🔍 STEP-BY-STEP RECONSTRUCTION ANALYSIS:
       step: 2_OUTPUT_ANALYSIS
       transformed_expressions: vector[N_trend] mu_trend = rep_vector(0.0, N_trend);; mu_trend += Intercept_trend;
       has_mu_trend_initialization: TRUE
       mu_trend_init_count: 1
       has_mu_trend_assignments: TRUE
       duplicate_initialization_detected: FALSE

      🔍 RECONSTRUCTION LINE ANALYSIS:
         line_number: 1
         content: vector[N_trend] mu_trend = rep_vector(0.0, N_trend);
         is_mu_trend_init: TRUE
         is_mu_trend_assignment: FALSE
         is_supporting_declaration: FALSE
         line_type: INITIALIZATION

      🔍 RECONSTRUCTION LINE ANALYSIS:
         line_number: 2
         content: mu_trend += Intercept_trend;
         is_mu_trend_init: FALSE
         is_mu_trend_assignment: TRUE
         is_supporting_declaration: FALSE
         line_type: ASSIGNMENT

  🔍 RECONSTRUCT_MU_TREND OUTPUT:
     result_length: 2
     result: vector[N_trend] mu_trend = rep_vector(0.0, N_trend);; mu_trend += Intercept_trend;

  🔍 STANVAR CREATION DECISION:
     has_mu_construction: FALSE
     logic: Fallback system should create stanvar

  🔍 EXTRACT_AND_RENAME OUTPUT:
     stanvars_count: 3
     stanvar_names: ; ; 
     mapping_updated: original_to_renamed: 3 items, renamed_to_original: 3 items

🔍 STANCODE GENERATED:
   stancode_length: 6143
   contains_mu_trend: TRUE
   mu_trend_count: 4
   contains_gp_pred: FALSE
   contains_vector_mu_trend: TRUE
   stancode_preview: // generated with brms 2.22.9
functions {
}
data {
  int<lower=1> N;  // total number of observations
  int<lower=1> N_count;  // number of observations
  vector[N_count] Y_count;  // response variable
  // data for splines
  int Ks_count;  // number of linear effects
  matrix[N_count, Ks_count] Xs_count;  // design matrix for the linear effects
  // data for spline 1
  int nb_count_1;  // number of bases
  array[nb_count_1] int knots_count_1;  // number of knots
  // basis function matrices
  matrix[N_count, knots_count_1[1]] Zs_count_1_1;
  int<lower=1> N_biomass;  // number of observations
  vector[N_biomass] Y_biomass;  // response variable
  // data for splines
  int Ks_biomass;  // number of linear effects
  matrix[N_biomass, Ks_biomass] Xs_biomass;  // design matrix for the linear effects
  // data for spline 1
  int nb_biomass_1;  // number of bases
  array[nb_biomass_1] int knots_biomass_1;  // number of knots
  // basis function matrices
  matrix[N_biomass, knots_biomass_1[1]

🔍 MU_TREND PATTERN ANALYSIS:
   total_mu_trend_lines: 4
   mu_trend_declarations: 1
   mu_trend_assignments: 1
   mu_trend_references: 1
   sample_lines:   vector[N_trend] mu_trend = rep_vector(0.0, N_trend);; mu_trend += Intercept_trend;;   // dot_product captures dynamic component, mu_trend captures trend_formula

────────────────────────────────────────────────────────────────────

🔬 SCENARIO: Monotonic CAR (Target 7 - failing)
   Main Formula: structure(list(formula = y ~ (1 | series), pforms = list(), pfix = list(), 
    Main Formula:     family = structure(list(family = "poisson", link = "log", 
    Main Formula:         linkfun = function (mu) 
    Main Formula:         link(mu, link = slink), linkinv = function (eta) 
    Main Formula:         inv_link(eta, link = slink), dpars = "mu", type = "int", 
    Main Formula:         ybounds = c(0, Inf), closed = c(TRUE, NA), ad = c("weights", 
    Main Formula:         "subset", "cens", "trunc", "rate", "index"), specials = "sbi_log"), class = c("brmsfamily", 
    Main Formula:     "family")), resp = "y"), class = c("brmsformula", "bform"
    Main Formula: ))
   Trend Formula: ~mo(income) + CAR()
   Data Type: univariate

🔍 Running full mvgam pipeline:
   Monotonic_CAR

🔍 MVGAM FORMULA CREATED:
   formula: structure(list(formula = y ~ (1 | series), pforms = list(), pfix = list(), ;     family = structure(list(family = "poisson", link = "log", ;         linkfun = function (mu) ;         link(mu, link = slink), linkinv = function (eta) ;         inv_link(eta, link = slink), dpars = "mu", type = "int", ;         ybounds = c(0, Inf), closed = c(TRUE, NA), ad = c("weights", ;         "subset", "cens", "trunc", "rate", "index"), specials = "sbi_log"), class = c("brmsfamily", ;     "family")), resp = "y"), class = c("brmsformula", "bform"; ))
   trend_formula: ~mo(income) + CAR()
   data_rows: 24

  🔍 EXTRACT_AND_RENAME INPUT:
     scenario: Monotonic_CAR
     suffix: _trend
     is_multivariate: FALSE
     response_names: 
     stancode_preview: // generated with brms 2.22.9
functions {
  /* compute monotonic effects
   * Args:
   *   scale: a simplex parameter
   *   i: index to sum over the simplex
   * Returns:
   *   a scalar between 0 and rows(scale)
   */
  real mo(vector scale, int i) {
    if (i == 0) {
      return 0;
    } else {

     mapping_summary: original_to_renamed: 0 items, renamed_to_original: 0 items

  🔍 EXTRACT_COMPUTED_VARIABLES:
     scenario: Monotonic_CAR
     found_variables: NONE FOUND

  🔍 EXTRACT_COMPUTED_VARIABLES:
     scenario: Monotonic_CAR
     found_variables: NONE FOUND

  🔍 EXTRACT_COMPUTED_VARIABLES:
     scenario: Monotonic_CAR
     found_variables: NONE FOUND

  🔍 EXTRACT_MU_CONSTRUCTION INPUT:
     scenario: Monotonic_CAR
     stancode_length: 1808
     stancode_preview: // generated with brms 2.22.9
functions {
  /* compute monotonic effects
   * Args:
   *   scale: a simplex parameter
   *   i: index to sum over the simplex
   * Returns:
   *   a scalar between 0 an

  🔍 FIND_VARIABLE_DECLARATIONS INPUT:
     scenario: Monotonic_CAR
     stancode_length: 1808
     referenced_vars_count: 6
     referenced_vars: N, mu, Intercept, bsp, simo_1, Xmo_1

  🔍 FIND_VARIABLE_DECLARATIONS OUTPUT:
     found_declarations_count: 5
     found_declarations: int<lower=1> N;  // total number of observations; vector[N] Y;  // response variable; array[N] int Xmo_1;  // monotonic variable; real Intercept;  // temporary intercept for centered predictors; vector[Ksp] bsp;  // special effects coefficients
     missing_vars: N, mu, Intercept, bsp, simo_1, Xmo_1

  🔍 EXTRACT_MU_CONSTRUCTION OUTPUT:
     mu_construction_count: 3
     mu_construction: vector[N] mu = rep_vector(0.0, N);; mu += Intercept;; mu[n] += (bsp[1]) * mo(simo_1, Xmo_1[n]);
     supporting_declarations_count: 5
     supporting_declarations: int<lower=1> N;  // total number of observations; vector[N] Y;  // response variable; array[N] int Xmo_1;  // monotonic variable; real Intercept;  // temporary intercept for centered predictors; vector[Ksp] bsp;  // special effects coefficients
     referenced_variables_count: 6
     referenced_variables: N; mu; Intercept; bsp; simo_1; Xmo_1

  🔍 EXTRACT_COMPUTED_VARIABLES:
     scenario: Monotonic_CAR
     found_variables: mu; b_Intercept

  🔍 FIND_VARIABLE_DECLARATIONS INPUT:
     scenario: Monotonic_CAR
     stancode_length: 1808
     referenced_vars_count: 1
     referenced_vars: mu

  🔍 FIND_VARIABLE_DECLARATIONS OUTPUT:
     found_declarations_count: 0
     found_declarations: NONE FOUND
     missing_vars: mu

  🔍 RECONSTRUCT_MU_TREND INPUT:
     scenario: Monotonic_CAR
     mu_construction_count: 3
     mu_construction: vector[N] mu = rep_vector(0.0, N);; mu += Intercept;; mu[n] += (bsp[1]) * mo(simo_1, Xmo_1[n]);
     supporting_declarations_count: 5
     supporting_declarations: int<lower=1> N;  // total number of observations; vector[N] Y;  // response variable; array[N] int Xmo_1;  // monotonic variable; real Intercept;  // temporary intercept for centered predictors; vector[Ksp] bsp;  // special effects coefficients
     variable_mapping_count: 10
     variable_mapping: con_simo_1 -> con_simo_1_trend; Xmo_1 -> Xmo_1_trend; Ksp -> Ksp_trend; Imo -> Imo_trend; Jmo -> Jmo_trend; N -> N_trend; Intercept -> Intercept_trend; simo_1 -> simo_1_trend; bsp -> bsp_trend; mu -> mu_trend
     time_param: N_trend

    🔍 STEP-BY-STEP RECONSTRUCTION ANALYSIS:
       step: 1_INPUT_ANALYSIS
       original_mu_expressions: vector[N] mu = rep_vector(0.0, N);; mu += Intercept;; mu[n] += (bsp[1]) * mo(simo_1, Xmo_1[n]);
       has_mu_initialization: TRUE
       has_mu_assignments: TRUE
       has_variable_declarations: TRUE

    🔍 STEP-BY-STEP RECONSTRUCTION ANALYSIS:
       step: 2_OUTPUT_ANALYSIS
       transformed_expressions: vector[N_trend] mu_trend = rep_vector(0.0, N_trend);; mu_trend += Intercept_trend;; ; for (n in 1:N_trend) {;   mu_trend[n] += (bsp_trend[1]) * mo(simo_1_trend, Xmo_1_trend[n]);; }
       has_mu_trend_initialization: TRUE
       mu_trend_init_count: 1
       has_mu_trend_assignments: TRUE
       duplicate_initialization_detected: FALSE

      🔍 RECONSTRUCTION LINE ANALYSIS:
         line_number: 1
         content: vector[N_trend] mu_trend = rep_vector(0.0, N_trend);
         is_mu_trend_init: TRUE
         is_mu_trend_assignment: FALSE
         is_supporting_declaration: FALSE
         line_type: INITIALIZATION

      🔍 RECONSTRUCTION LINE ANALYSIS:
         line_number: 2
         content: mu_trend += Intercept_trend;
         is_mu_trend_init: FALSE
         is_mu_trend_assignment: TRUE
         is_supporting_declaration: FALSE
         line_type: ASSIGNMENT

      🔍 RECONSTRUCTION LINE ANALYSIS:
         line_number: 3
         content: 
         is_mu_trend_init: FALSE
         is_mu_trend_assignment: FALSE
         is_supporting_declaration: FALSE
         line_type: OTHER

      🔍 RECONSTRUCTION LINE ANALYSIS:
         line_number: 4
         content: for (n in 1:N_trend) {
         is_mu_trend_init: FALSE
         is_mu_trend_assignment: FALSE
         is_supporting_declaration: FALSE
         line_type: OTHER

      🔍 RECONSTRUCTION LINE ANALYSIS:
         line_number: 5
         content:   mu_trend[n] += (bsp_trend[1]) * mo(simo_1_trend, Xmo_1_trend[n]);
         is_mu_trend_init: FALSE
         is_mu_trend_assignment: FALSE
         is_supporting_declaration: FALSE
         line_type: OTHER

      🔍 RECONSTRUCTION LINE ANALYSIS:
         line_number: 6
         content: }
         is_mu_trend_init: FALSE
         is_mu_trend_assignment: FALSE
         is_supporting_declaration: FALSE
         line_type: OTHER

  🔍 RECONSTRUCT_MU_TREND OUTPUT:
     result_length: 6
     result: vector[N_trend] mu_trend = rep_vector(0.0, N_trend);; mu_trend += Intercept_trend;; ; for (n in 1:N_trend) {;   mu_trend[n] += (bsp_trend[1]) * mo(simo_1_trend, Xmo_1_trend[n]);; }

  🔍 STANVAR CREATION DECISION:
     has_mu_construction: FALSE
     logic: Fallback system should create stanvar

  🔍 EXTRACT_AND_RENAME OUTPUT:
     stanvars_count: 3
     stanvar_names: ; ; 
     mapping_updated: original_to_renamed: 10 items, renamed_to_original: 10 items

🔍 LINEAR PREDICTOR INJECTION:
   scenario: Monotonic_CAR
   message: Checking if Enhanced system or GLM bypass will be used

🔍 LINEAR PREDICTOR RESULT:
   scenario: Monotonic_CAR
   result_type: character
   glm_bypass_occurred: FALSE

🔍 ERROR IN SCENARIO:
No traceback available 
   scenario: Monotonic_CAR
   error: Error: Assertion on 'formula' failed: One of the following must apply:
 * checkmate::check_class(formula): Must inherit from class 'formula',
 * but has classes 'brmsformula','bform'
 * checkmate::check_class(formula): Must inherit from class
 * 'mvbrmsformula', but has classes 'brmsformula','bform'.

   traceback: 

────────────────────────────────────────────────────────────────────

There were 16 warnings (use warnings() to see them)
📈 COMPREHENSIVE ANALYSIS ACROSS ALL SCENARIOS
====================================================================

📋 SCENARIO ANALYSIS: RW_simple
🔍 Generated Stan Code Analysis:
   scenario_completed: FALSE
   monkey_patches_triggered: FALSE

🔍 Mu Construction Extraction:
   NOT TRIGGERED - Enhanced system bypassed

🔍 Reconstruction Process:
   NOT TRIGGERED

🔍 Stanvar Creation Process:
   NOT TRIGGERED

🔍 GLM BYPASS ANALYSIS:
   glm_bypass_used: FALSE
   impact: Enhanced system should be active


📋 SCENARIO ANALYSIS: VARMA_complex
🔍 Generated Stan Code Analysis:
   scenario_completed: FALSE
   monkey_patches_triggered: FALSE

🔍 Mu Construction Extraction:
   NOT TRIGGERED - Enhanced system bypassed

🔍 Reconstruction Process:
   NOT TRIGGERED

🔍 Stanvar Creation Process:
   NOT TRIGGERED

🔍 GLM BYPASS ANALYSIS:
   glm_bypass_used: FALSE
   impact: Enhanced system should be active


📋 SCENARIO ANALYSIS: GP_CAR_complex
🔍 Generated Stan Code Analysis:
   scenario_completed: FALSE
   monkey_patches_triggered: FALSE

🔍 Mu Construction Extraction:
   NOT TRIGGERED - Enhanced system bypassed

🔍 Reconstruction Process:
   NOT TRIGGERED

🔍 Stanvar Creation Process:
   NOT TRIGGERED

🔍 GLM BYPASS ANALYSIS:
   glm_bypass_used: FALSE
   impact: Enhanced system should be active


📋 SCENARIO ANALYSIS: Spline_multivariate
🔍 Generated Stan Code Analysis:
   scenario_completed: FALSE
   monkey_patches_triggered: FALSE

🔍 Mu Construction Extraction:
   NOT TRIGGERED - Enhanced system bypassed

🔍 Reconstruction Process:
   NOT TRIGGERED

🔍 Stanvar Creation Process:
   NOT TRIGGERED

🔍 GLM BYPASS ANALYSIS:
   glm_bypass_used: FALSE
   impact: Enhanced system should be active


📋 SCENARIO ANALYSIS: Monotonic_CAR
🔍 Generated Stan Code Analysis:
   scenario_completed: FALSE
   monkey_patches_triggered: FALSE

🔍 Mu Construction Extraction:
   NOT TRIGGERED - Enhanced system bypassed

🔍 Reconstruction Process:
   NOT TRIGGERED

🔍 Stanvar Creation Process:
   NOT TRIGGERED

🔍 GLM BYPASS ANALYSIS:
   glm_bypass_used: FALSE
   impact: Enhanced system should be active


🎯 KEY FINDINGS AND RECOMMENDATIONS
====================================================================
🔍 CROSS-SCENARIO ANALYSIS:
   total_scenarios: 5
   scenarios_with_mu_construction: NONE
   scenarios_with_reconstruction: NONE
   scenarios_with_stanvar: NONE
   scenarios_with_glm_bypass: NONE
   enhanced_vs_glm_conflict: FALSE


🔧 CRITICAL FINDINGS:
   ✅ No GLM bypass detected - Enhanced system should be working

🔧 DEBUGGING RECOMMENDATIONS:
   1. GLM bypass scenarios need mu_trend integration in GLM path
   2. Enhanced system scenarios should use reconstruction properly
   3. No scenario should have both Enhanced system AND GLM bypass
   4. All scenarios should result in proper mu_trend declaration via ONE path
   5. Fix GLM bypass to include mu_trend or disable GLM optimization

✅ COMPREHENSIVE DEBUGGING COMPLETE
   Original functions restored
   Results available in debug_state$results
====================================================================
