Loading required package: usethis
Warning messages:
1: package 'devtools' was built under R version 4.4.2 
2: package 'usethis' was built under R version 4.4.2 
Loading required package: Rcpp
Loading 'brms' package (version 2.22.9). Useful instructions
can be found by typing help('brms'). A more detailed introduction
to the package is available through vignette('brms_overview').

Attaching package: 'brms'

The following object is masked from 'package:stats':

    ar

Warning message:
package 'Rcpp' was built under R version 4.4.2 
â„¹ Loading mvgam
Loading 'mvgam' (version 2.0.0). Useful instructions can be found by
  typing help('mvgam'). A more detailed introduction to the package is
  available through vignette('mvgam_overview'). Full brms compatibility is
  now enabled.
Warning message:
package 'testthat' was built under R version 4.4.2 
ğŸ” COMPREHENSIVE MU_TREND INTERNAL DEBUGGING SCRIPT
====================================================================

ğŸ“Š TESTING DATA STRUCTURE:
ğŸ” Test Data Summary:
   univariate_rows: 24
   multivariate_rows: 72
   univariate_columns: time, series, y, x, temperature, income
   multivariate_columns: time, series, count, biomass, presence, x, temperature, income
   y_range: 2 to 11
   time_range_uni: 1 to 24
   time_range_multi: 1 to 24

ğŸ§ª RUNNING COMPREHENSIVE TESTS ACROSS TREND FORMULA COMPLEXITIES
====================================================================

ğŸ”¬ SCENARIO: RW Simple (from target_generation.R)
   Main Formula: structure(list(formula = y ~ x, pforms = list(), pfix = list(), 
    Main Formula:     family = structure(list(family = "poisson", link = "log", 
    Main Formula:         linkfun = function (mu) 
    Main Formula:         link(mu, link = slink), linkinv = function (eta) 
    Main Formula:         inv_link(eta, link = slink), dpars = "mu", type = "int", 
    Main Formula:         ybounds = c(0, Inf), closed = c(TRUE, NA), ad = c("weights", 
    Main Formula:         "subset", "cens", "trunc", "rate", "index"), specials = "sbi_log"), class = c("brmsfamily", 
    Main Formula:     "family")), resp = "y"), class = c("brmsformula", "bform"
    Main Formula: ))
   Trend Formula: ~1
   Data Type: univariate

ğŸ” Running full mvgam pipeline:
   RW_simple

ğŸ” MVGAM FORMULA CREATED:
   formula: structure(list(formula = y ~ x, pforms = list(), pfix = list(), ;     family = structure(list(family = "poisson", link = "log", ;         linkfun = function (mu) ;         link(mu, link = slink), linkinv = function (eta) ;         inv_link(eta, link = slink), dpars = "mu", type = "int", ;         ybounds = c(0, Inf), closed = c(TRUE, NA), ad = c("weights", ;         "subset", "cens", "trunc", "rate", "index"), specials = "sbi_log"), class = c("brmsfamily", ;     "family")), resp = "y"), class = c("brmsformula", "bform"; ))
   trend_formula: ~1
   data_rows: 24

  ğŸ” EXTRACT_AND_RENAME INPUT:
     scenario: RW_simple
     suffix: _trend
     is_multivariate: FALSE
     response_names: 
     stancode_preview: // generated with brms 2.22.9
functions {
}
data {
  int<lower=1> N;  // total number of observations
  vector[N] Y;  // response variable
  int prior_only;  // should the likelihood be ignored?
}
transformed data {
}
parameters {
  real Intercept;  // temporary intercept for centered predictors
  r
     mapping_summary: original_to_renamed: 0 items, renamed_to_original: 0 items

  ğŸ” EXTRACT_COMPUTED_VARIABLES:
     scenario: RW_simple
     found_variables: NONE FOUND

  ğŸ” EXTRACT_COMPUTED_VARIABLES:
     scenario: RW_simple
     found_variables: NONE FOUND

  ğŸ” EXTRACT_COMPUTED_VARIABLES:
     scenario: RW_simple
     found_variables: NONE FOUND

  ğŸ” EXTRACT_MU_CONSTRUCTION INPUT:
     scenario: RW_simple
     stancode_length: 941
     stancode_preview: // generated with brms 2.22.9
functions {
}
data {
  int<lower=1> N;  // total number of observations
  vector[N] Y;  // response variable
  int prior_only;  // should the likelihood be ignored?
}
tra

  ğŸ” FIND_VARIABLE_DECLARATIONS INPUT:
     scenario: RW_simple
     stancode_length: 941
     referenced_vars_count: 3
     referenced_vars: N, mu, Intercept

  ğŸ” FIND_VARIABLE_DECLARATIONS OUTPUT:
     found_declarations_count: 3
     found_declarations: int<lower=1> N;  // total number of observations; vector[N] Y;  // response variable; real Intercept;  // temporary intercept for centered predictors
     missing_vars: N, mu, Intercept

  ğŸ” EXTRACT_MU_CONSTRUCTION OUTPUT:
     mu_construction_count: 2
     mu_construction: vector[N] mu = rep_vector(0.0, N);; mu += Intercept;
     supporting_declarations_count: 3
     supporting_declarations: int<lower=1> N;  // total number of observations; vector[N] Y;  // response variable; real Intercept;  // temporary intercept for centered predictors
     referenced_variables_count: 3
     referenced_variables: N; mu; Intercept

  ğŸ” EXTRACT_COMPUTED_VARIABLES:
     scenario: RW_simple
     found_variables: mu; b_Intercept

  ğŸ” FIND_VARIABLE_DECLARATIONS INPUT:
     scenario: RW_simple
     stancode_length: 941
     referenced_vars_count: 1
     referenced_vars: mu

  ğŸ” FIND_VARIABLE_DECLARATIONS OUTPUT:
     found_declarations_count: 0
     found_declarations: NONE FOUND
     missing_vars: mu

  ğŸ” RECONSTRUCT_MU_TREND INPUT:
     scenario: RW_simple
     mu_construction_count: 2
     mu_construction: vector[N] mu = rep_vector(0.0, N);; mu += Intercept;
     supporting_declarations_count: 3
     supporting_declarations: int<lower=1> N;  // total number of observations; vector[N] Y;  // response variable; real Intercept;  // temporary intercept for centered predictors
     variable_mapping_count: 3
     variable_mapping: N -> N_trend; Intercept -> Intercept_trend; mu -> mu_trend
     time_param: N_trend

    ğŸ” STEP-BY-STEP RECONSTRUCTION ANALYSIS:
       step: 1_INPUT_ANALYSIS
       original_mu_expressions: vector[N] mu = rep_vector(0.0, N);; mu += Intercept;
       has_mu_initialization: TRUE
       has_mu_assignments: TRUE
       has_variable_declarations: TRUE

    ğŸ” STEP-BY-STEP RECONSTRUCTION ANALYSIS:
       step: 2_OUTPUT_ANALYSIS
       transformed_expressions: vector[N_trend] mu_trend = rep_vector(0.0, N_trend);; mu_trend += Intercept_trend;
       has_mu_trend_initialization: TRUE
       mu_trend_init_count: 1
       has_mu_trend_assignments: TRUE
       duplicate_initialization_detected: FALSE

      ğŸ” RECONSTRUCTION LINE ANALYSIS:
         line_number: 1
         content: vector[N_trend] mu_trend = rep_vector(0.0, N_trend);
         is_mu_trend_init: TRUE
         is_mu_trend_assignment: FALSE
         is_supporting_declaration: FALSE
         line_type: INITIALIZATION

      ğŸ” RECONSTRUCTION LINE ANALYSIS:
         line_number: 2
         content: mu_trend += Intercept_trend;
         is_mu_trend_init: FALSE
         is_mu_trend_assignment: TRUE
         is_supporting_declaration: FALSE
         line_type: ASSIGNMENT

  ğŸ” RECONSTRUCT_MU_TREND OUTPUT:
     result_length: 2
     result: vector[N_trend] mu_trend = rep_vector(0.0, N_trend);; mu_trend += Intercept_trend;

  ğŸ” STANVAR CREATION DECISION:
     has_mu_construction: FALSE
     logic: Fallback system should create stanvar

  ğŸ” EXTRACT_AND_RENAME OUTPUT:
     stanvars_count: 3
     stanvar_names: ; ; 
     mapping_updated: original_to_renamed: 3 items, renamed_to_original: 3 items

ğŸ” LINEAR PREDICTOR INJECTION:
   scenario: RW_simple
   message: Checking if Enhanced system or GLM bypass will be used

ğŸ” GLM BYPASS DETECTED:
   scenario: RW_simple
   message: GLM path bypassing Enhanced mu_trend Construction System
   args_count: 3

ğŸ” GLM BYPASS RESULT:
   scenario: RW_simple
   result_length: 3253

ğŸ” LINEAR PREDICTOR RESULT:
   scenario: RW_simple
   result_type: character; brmsmodel
   glm_bypass_occurred: FALSE

ğŸ” ERROR IN SCENARIO:
No traceback available 
   scenario: RW_simple
   error: Error: Assertion on 'formula' failed: One of the following must apply:
 * checkmate::check_class(formula): Must inherit from class 'formula',
 * but has classes 'brmsformula','bform'
 * checkmate::check_class(formula): Must inherit from class
 * 'mvbrmsformula', but has classes 'brmsformula','bform'.

   traceback: 

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

ğŸ”¬ SCENARIO: VARMA Complex (from target_generation.R)
   Main Formula: structure(list(forms = list(count = structure(list(formula = count ~ 
    Main Formula:     s(x), pforms = list(), pfix = list(), resp = "count", family = NULL), class = c("brmsformula", 
    Main Formula: "bform")), biomass = structure(list(formula = biomass ~ s(x), 
    Main Formula:     pforms = list(), pfix = list(), resp = "biomass", family = NULL), class = c("brmsformula", 
    Main Formula: "bform"))), responses = c("count", "biomass"), rescor = FALSE), class = c("mvbrmsformula", 
    Main Formula: "bform"))
   Trend Formula: ~presence + VAR(p = 2, ma = TRUE)
   Data Type: multivariate

ğŸ” Running full mvgam pipeline:
   VARMA_complex

ğŸ” MVGAM FORMULA CREATED:
   formula: structure(list(forms = list(count = structure(list(formula = count ~ ;     s(x), pforms = list(), pfix = list(), resp = "count", family = NULL), class = c("brmsformula", ; "bform")), biomass = structure(list(formula = biomass ~ s(x), ;     pforms = list(), pfix = list(), resp = "biomass", family = NULL), class = c("brmsformula", ; "bform"))), responses = c("count", "biomass"), rescor = FALSE), class = c("mvbrmsformula", ; "bform"))
   trend_formula: ~presence + VAR(p = 2, ma = TRUE)
   data_rows: 72

  ğŸ” EXTRACT_AND_RENAME INPUT:
     scenario: VARMA_complex
     suffix: _trend
     is_multivariate: FALSE
     response_names: 
     stancode_preview: // generated with brms 2.22.9
functions {
}
data {
  int<lower=1> N;  // total number of observations
  vector[N] Y;  // response variable
  int<lower=1> K;  // number of population-level effects
  matrix[N, K] X;  // population-level design matrix
  int<lower=1> Kc;  // number of population-level e
     mapping_summary: original_to_renamed: 0 items, renamed_to_original: 0 items

  ğŸ” EXTRACT_COMPUTED_VARIABLES:
     scenario: VARMA_complex
     found_variables: NONE FOUND

  ğŸ” EXTRACT_COMPUTED_VARIABLES:
     scenario: VARMA_complex
     found_variables: NONE FOUND

  ğŸ” EXTRACT_COMPUTED_VARIABLES:
     scenario: VARMA_complex
     found_variables: NONE FOUND

  ğŸ” EXTRACT_COMPUTED_VARIABLES:
     scenario: VARMA_complex
     found_variables: NONE FOUND

  ğŸ” EXTRACT_MU_CONSTRUCTION INPUT:
     scenario: VARMA_complex
     stancode_length: 1342
     stancode_preview: // generated with brms 2.22.9
functions {
}
data {
  int<lower=1> N;  // total number of observations
  vector[N] Y;  // response variable
  int<lower=1> K;  // number of population-level effects
  ma

  ğŸ” EXTRACT_MU_CONSTRUCTION OUTPUT:
     mu_construction_count: 0
     mu_construction: NONE FOUND
     supporting_declarations_count: 0
     supporting_declarations: NONE FOUND
     referenced_variables_count: 0
     referenced_variables: NONE FOUND

  ğŸ” STANVAR CREATION DECISION:
     has_mu_construction: FALSE
     logic: Fallback system should create stanvar

  ğŸ” EXTRACT_AND_RENAME OUTPUT:
     stanvars_count: 4
     stanvar_names: ; ; ; 
     mapping_updated: original_to_renamed: 10 items, renamed_to_original: 10 items

ğŸ” STANCODE GENERATED:
   stancode_length: 22902
   contains_mu_trend: TRUE
   mu_trend_count: 12
   contains_gp_pred: FALSE
   contains_vector_mu_trend: TRUE
   stancode_preview: // generated with brms 2.22.9
functions {
  
      /**
       * Compute matrix square root using eigendecomposition
       * Following Heaps 2022 methodology for stationary VAR/VARMA
       * @param A Symmetric positive definite matrix (m x m)
       * @return Matrix square root of A
       */
      matrix sqrtm(matrix A) {
        int m = rows(A);
        vector[m] eigenvals = eigenvalues_sym(A);

        // Numerical stability check for positive definiteness
        if (min(eigenvals) <= 1e-12) {
          reject("Matrix must be positive definite for square root computation");
        }

        vector[m] root_root_evals = sqrt(sqrt(eigenvals));
        matrix[m, m] evecs = eigenvectors_sym(A);
        matrix[m, m] eprod = diag_post_multiply(evecs, root_root_evals);
        return tcrossprod(eprod);
      }

      /**
       * Transform P_real to P matrix using partial autocorrelation approach
       * Heaps 2022 transformation for stationarity constraints
       * @param P_real Real

ğŸ” MU_TREND PATTERN ANALYSIS:
   total_mu_trend_lines: 12
   mu_trend_declarations: 1
   mu_trend_assignments: 1
   mu_trend_references: 7
   sample_lines:   array[2] vector[1] Amu_trend;     // Shared means; array[2] vector[1] Dmu_trend;           // Means for D_raw_trend elements;   vector[N_trend] mu_trend = rep_vector(0.0, N_trend);

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

ğŸ”¬ SCENARIO: GP + CAR Complex (from target_generation.R)
   Main Formula: structure(list(formula = y ~ (1 | series), pforms = list(), pfix = list(), 
    Main Formula:     family = structure(list(family = "poisson", link = "log", 
    Main Formula:         linkfun = function (mu) 
    Main Formula:         link(mu, link = slink), linkinv = function (eta) 
    Main Formula:         inv_link(eta, link = slink), dpars = "mu", type = "int", 
    Main Formula:         ybounds = c(0, Inf), closed = c(TRUE, NA), ad = c("weights", 
    Main Formula:         "subset", "cens", "trunc", "rate", "index"), specials = "sbi_log"), class = c("brmsfamily", 
    Main Formula:     "family")), resp = "y"), class = c("brmsformula", "bform"
    Main Formula: ))
   Trend Formula: ~gp(x) + CAR()
   Data Type: univariate

ğŸ” Running full mvgam pipeline:
   GP_CAR_complex

ğŸ” MVGAM FORMULA CREATED:
   formula: structure(list(formula = y ~ (1 | series), pforms = list(), pfix = list(), ;     family = structure(list(family = "poisson", link = "log", ;         linkfun = function (mu) ;         link(mu, link = slink), linkinv = function (eta) ;         inv_link(eta, link = slink), dpars = "mu", type = "int", ;         ybounds = c(0, Inf), closed = c(TRUE, NA), ad = c("weights", ;         "subset", "cens", "trunc", "rate", "index"), specials = "sbi_log"), class = c("brmsfamily", ;     "family")), resp = "y"), class = c("brmsformula", "bform"; ))
   trend_formula: ~gp(x) + CAR()
   data_rows: 24

  ğŸ” EXTRACT_AND_RENAME INPUT:
     scenario: GP_CAR_complex
     suffix: _trend
     is_multivariate: FALSE
     response_names: 
     stancode_preview: // generated with brms 2.22.9
functions {
  /* compute a latent Gaussian process with squared exponential kernel
   * Args:
   *   x: array of continuous predictor values
   *   sdgp: marginal SD parameter
   *   lscale: length-scale parameter
   *   zgp: vector of independent standard normal variab
     mapping_summary: original_to_renamed: 0 items, renamed_to_original: 0 items

  ğŸ” EXTRACT_COMPUTED_VARIABLES:
     scenario: GP_CAR_complex
     found_variables: NONE FOUND

  ğŸ” EXTRACT_COMPUTED_VARIABLES:
     scenario: GP_CAR_complex
     found_variables: NONE FOUND

  ğŸ” EXTRACT_COMPUTED_VARIABLES:
     scenario: GP_CAR_complex
     found_variables: NONE FOUND

  ğŸ” EXTRACT_MU_CONSTRUCTION INPUT:
     scenario: GP_CAR_complex
     stancode_length: 2742
     stancode_preview: // generated with brms 2.22.9
functions {
  /* compute a latent Gaussian process with squared exponential kernel
   * Args:
   *   x: array of continuous predictor values
   *   sdgp: marginal SD para

  ğŸ” FIND_VARIABLE_DECLARATIONS INPUT:
     scenario: GP_CAR_complex
     stancode_length: 2742
     referenced_vars_count: 5
     referenced_vars: N, mu, Intercept, gp_pred_1, Jgp_1

  ğŸ” FIND_VARIABLE_DECLARATIONS OUTPUT:
     found_declarations_count: 4
     found_declarations: int<lower=1> N;  // total number of observations; vector[N] Y;  // response variable; array[N] int<lower=1> Jgp_1;; real Intercept;  // temporary intercept for centered predictors
     missing_vars: N, mu, Intercept, gp_pred_1, Jgp_1

  ğŸ” EXTRACT_MU_CONSTRUCTION OUTPUT:
     mu_construction_count: 2
     mu_construction: vector[N] mu = rep_vector(0.0, N);; mu += Intercept + gp_pred_1[Jgp_1];
     supporting_declarations_count: 4
     supporting_declarations: int<lower=1> N;  // total number of observations; vector[N] Y;  // response variable; array[N] int<lower=1> Jgp_1;; real Intercept;  // temporary intercept for centered predictors
     referenced_variables_count: 5
     referenced_variables: N; mu; Intercept; gp_pred_1; Jgp_1

  ğŸ” EXTRACT_COMPUTED_VARIABLES:
     scenario: GP_CAR_complex
     found_variables: Dls; N; gp_pred_1; mu; b_Intercept; cov gp_exp_quad_cov(x, sdgp, lscale[1]);; cov gp_exp_quad_cov(x[, 1], sdgp, lscale[1]);; cov cov .* gp_exp_quad_cov(x[, d], 1, lscale[d]);

  ğŸ” FIND_VARIABLE_DECLARATIONS INPUT:
     scenario: GP_CAR_complex
     stancode_length: 2742
     referenced_vars_count: 2
     referenced_vars: mu, gp_pred_1

  ğŸ” FIND_VARIABLE_DECLARATIONS OUTPUT:
     found_declarations_count: 0
     found_declarations: NONE FOUND
     missing_vars: mu, gp_pred_1

  ğŸ” RECONSTRUCT_MU_TREND INPUT:
     scenario: GP_CAR_complex
     mu_construction_count: 2
     mu_construction: vector[N] mu = rep_vector(0.0, N);; mu += Intercept + gp_pred_1[Jgp_1];
     supporting_declarations_count: 4
     supporting_declarations: int<lower=1> N;  // total number of observations; vector[N] Y;  // response variable; array[N] int<lower=1> Jgp_1;; real Intercept;  // temporary intercept for centered predictors
     variable_mapping_count: 12
     variable_mapping: Nsubgp_1 -> Nsubgp_1_trend; Kgp_1 -> Kgp_1_trend; Dgp_1 -> Dgp_1_trend; Jgp_1 -> Jgp_1_trend; Xgp_1 -> Xgp_1_trend; N -> N_trend; Intercept -> Intercept_trend; lscale_1 -> lscale_1_trend; sdgp_1 -> sdgp_1_trend; zgp_1 -> zgp_1_trend; mu -> mu_trend; gp_pred_1 -> gp_pred_1_trend
     time_param: N_trend

    ğŸ” STEP-BY-STEP RECONSTRUCTION ANALYSIS:
       step: 1_INPUT_ANALYSIS
       original_mu_expressions: vector[N] mu = rep_vector(0.0, N);; mu += Intercept + gp_pred_1[Jgp_1];
       has_mu_initialization: TRUE
       has_mu_assignments: TRUE
       has_variable_declarations: TRUE

    ğŸ” STEP-BY-STEP RECONSTRUCTION ANALYSIS:
       step: 2_OUTPUT_ANALYSIS
       transformed_expressions: vector[N_trend] mu_trend = rep_vector(0.0, N_trend);; mu_trend += Intercept_trend + gp_pred_1_trend[Jgp_1_trend];
       has_mu_trend_initialization: TRUE
       mu_trend_init_count: 1
       has_mu_trend_assignments: TRUE
       duplicate_initialization_detected: FALSE

      ğŸ” RECONSTRUCTION LINE ANALYSIS:
         line_number: 1
         content: vector[N_trend] mu_trend = rep_vector(0.0, N_trend);
         is_mu_trend_init: TRUE
         is_mu_trend_assignment: FALSE
         is_supporting_declaration: FALSE
         line_type: INITIALIZATION

      ğŸ” RECONSTRUCTION LINE ANALYSIS:
         line_number: 2
         content: mu_trend += Intercept_trend + gp_pred_1_trend[Jgp_1_trend];
         is_mu_trend_init: FALSE
         is_mu_trend_assignment: TRUE
         is_supporting_declaration: FALSE
         line_type: ASSIGNMENT

  ğŸ” RECONSTRUCT_MU_TREND OUTPUT:
     result_length: 2
     result: vector[N_trend] mu_trend = rep_vector(0.0, N_trend);; mu_trend += Intercept_trend + gp_pred_1_trend[Jgp_1_trend];

  ğŸ” STANVAR CREATION DECISION:
     has_mu_construction: FALSE
     logic: Fallback system should create stanvar

  ğŸ” EXTRACT_AND_RENAME OUTPUT:
     stanvars_count: 3
     stanvar_names: ; ; 
     mapping_updated: original_to_renamed: 12 items, renamed_to_original: 12 items

ğŸ” LINEAR PREDICTOR INJECTION:
   scenario: GP_CAR_complex
   message: Checking if Enhanced system or GLM bypass will be used

ğŸ” LINEAR PREDICTOR RESULT:
   scenario: GP_CAR_complex
   result_type: character
   glm_bypass_occurred: FALSE

ğŸ” ERROR IN SCENARIO:
No traceback available 
   scenario: GP_CAR_complex
   error: Error: Assertion on 'formula' failed: One of the following must apply:
 * checkmate::check_class(formula): Must inherit from class 'formula',
 * but has classes 'brmsformula','bform'
 * checkmate::check_class(formula): Must inherit from class
 * 'mvbrmsformula', but has classes 'brmsformula','bform'.

   traceback: 

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

ğŸ”¬ SCENARIO: Spline Multivariate (from target_generation.R)
   Main Formula: structure(list(forms = list(count = structure(list(formula = count ~ 
    Main Formula:     s(x), pforms = list(), pfix = list(), resp = "count", family = NULL), class = c("brmsformula", 
    Main Formula: "bform")), biomass = structure(list(formula = biomass ~ s(x), 
    Main Formula:     pforms = list(), pfix = list(), resp = "biomass", family = NULL), class = c("brmsformula", 
    Main Formula: "bform"))), responses = c("count", "biomass"), rescor = FALSE), class = c("mvbrmsformula", 
    Main Formula: "bform"))
   Trend Formula: ~RW(cor = TRUE)
   Data Type: multivariate

ğŸ” Running full mvgam pipeline:
   Spline_multivariate

ğŸ” MVGAM FORMULA CREATED:
   formula: structure(list(forms = list(count = structure(list(formula = count ~ ;     s(x), pforms = list(), pfix = list(), resp = "count", family = NULL), class = c("brmsformula", ; "bform")), biomass = structure(list(formula = biomass ~ s(x), ;     pforms = list(), pfix = list(), resp = "biomass", family = NULL), class = c("brmsformula", ; "bform"))), responses = c("count", "biomass"), rescor = FALSE), class = c("mvbrmsformula", ; "bform"))
   trend_formula: ~RW(cor = TRUE)
   data_rows: 72

  ğŸ” EXTRACT_AND_RENAME INPUT:
     scenario: Spline_multivariate
     suffix: _trend
     is_multivariate: FALSE
     response_names: 
     stancode_preview: // generated with brms 2.22.9
functions {
}
data {
  int<lower=1> N;  // total number of observations
  vector[N] Y;  // response variable
  int prior_only;  // should the likelihood be ignored?
}
transformed data {
}
parameters {
  real Intercept;  // temporary intercept for centered predictors
  r
     mapping_summary: original_to_renamed: 0 items, renamed_to_original: 0 items

  ğŸ” EXTRACT_COMPUTED_VARIABLES:
     scenario: Spline_multivariate
     found_variables: NONE FOUND

  ğŸ” EXTRACT_COMPUTED_VARIABLES:
     scenario: Spline_multivariate
     found_variables: NONE FOUND

  ğŸ” EXTRACT_COMPUTED_VARIABLES:
     scenario: Spline_multivariate
     found_variables: NONE FOUND

  ğŸ” EXTRACT_MU_CONSTRUCTION INPUT:
     scenario: Spline_multivariate
     stancode_length: 940
     stancode_preview: // generated with brms 2.22.9
functions {
}
data {
  int<lower=1> N;  // total number of observations
  vector[N] Y;  // response variable
  int prior_only;  // should the likelihood be ignored?
}
tra

  ğŸ” FIND_VARIABLE_DECLARATIONS INPUT:
     scenario: Spline_multivariate
     stancode_length: 940
     referenced_vars_count: 3
     referenced_vars: N, mu, Intercept

  ğŸ” FIND_VARIABLE_DECLARATIONS OUTPUT:
     found_declarations_count: 3
     found_declarations: int<lower=1> N;  // total number of observations; vector[N] Y;  // response variable; real Intercept;  // temporary intercept for centered predictors
     missing_vars: N, mu, Intercept

  ğŸ” EXTRACT_MU_CONSTRUCTION OUTPUT:
     mu_construction_count: 2
     mu_construction: vector[N] mu = rep_vector(0.0, N);; mu += Intercept;
     supporting_declarations_count: 3
     supporting_declarations: int<lower=1> N;  // total number of observations; vector[N] Y;  // response variable; real Intercept;  // temporary intercept for centered predictors
     referenced_variables_count: 3
     referenced_variables: N; mu; Intercept

  ğŸ” EXTRACT_COMPUTED_VARIABLES:
     scenario: Spline_multivariate
     found_variables: mu; b_Intercept

  ğŸ” FIND_VARIABLE_DECLARATIONS INPUT:
     scenario: Spline_multivariate
     stancode_length: 940
     referenced_vars_count: 1
     referenced_vars: mu

  ğŸ” FIND_VARIABLE_DECLARATIONS OUTPUT:
     found_declarations_count: 0
     found_declarations: NONE FOUND
     missing_vars: mu

  ğŸ” RECONSTRUCT_MU_TREND INPUT:
     scenario: Spline_multivariate
     mu_construction_count: 2
     mu_construction: vector[N] mu = rep_vector(0.0, N);; mu += Intercept;
     supporting_declarations_count: 3
     supporting_declarations: int<lower=1> N;  // total number of observations; vector[N] Y;  // response variable; real Intercept;  // temporary intercept for centered predictors
     variable_mapping_count: 3
     variable_mapping: N -> N_trend; Intercept -> Intercept_trend; mu -> mu_trend
     time_param: N_trend

    ğŸ” STEP-BY-STEP RECONSTRUCTION ANALYSIS:
       step: 1_INPUT_ANALYSIS
       original_mu_expressions: vector[N] mu = rep_vector(0.0, N);; mu += Intercept;
       has_mu_initialization: TRUE
       has_mu_assignments: TRUE
       has_variable_declarations: TRUE

    ğŸ” STEP-BY-STEP RECONSTRUCTION ANALYSIS:
       step: 2_OUTPUT_ANALYSIS
       transformed_expressions: vector[N_trend] mu_trend = rep_vector(0.0, N_trend);; mu_trend += Intercept_trend;
       has_mu_trend_initialization: TRUE
       mu_trend_init_count: 1
       has_mu_trend_assignments: TRUE
       duplicate_initialization_detected: FALSE

      ğŸ” RECONSTRUCTION LINE ANALYSIS:
         line_number: 1
         content: vector[N_trend] mu_trend = rep_vector(0.0, N_trend);
         is_mu_trend_init: TRUE
         is_mu_trend_assignment: FALSE
         is_supporting_declaration: FALSE
         line_type: INITIALIZATION

      ğŸ” RECONSTRUCTION LINE ANALYSIS:
         line_number: 2
         content: mu_trend += Intercept_trend;
         is_mu_trend_init: FALSE
         is_mu_trend_assignment: TRUE
         is_supporting_declaration: FALSE
         line_type: ASSIGNMENT

  ğŸ” RECONSTRUCT_MU_TREND OUTPUT:
     result_length: 2
     result: vector[N_trend] mu_trend = rep_vector(0.0, N_trend);; mu_trend += Intercept_trend;

  ğŸ” STANVAR CREATION DECISION:
     has_mu_construction: FALSE
     logic: Fallback system should create stanvar

  ğŸ” EXTRACT_AND_RENAME OUTPUT:
     stanvars_count: 3
     stanvar_names: ; ; 
     mapping_updated: original_to_renamed: 3 items, renamed_to_original: 3 items

ğŸ” STANCODE GENERATED:
   stancode_length: 6143
   contains_mu_trend: TRUE
   mu_trend_count: 4
   contains_gp_pred: FALSE
   contains_vector_mu_trend: TRUE
   stancode_preview: // generated with brms 2.22.9
functions {
}
data {
  int<lower=1> N;  // total number of observations
  int<lower=1> N_count;  // number of observations
  vector[N_count] Y_count;  // response variable
  // data for splines
  int Ks_count;  // number of linear effects
  matrix[N_count, Ks_count] Xs_count;  // design matrix for the linear effects
  // data for spline 1
  int nb_count_1;  // number of bases
  array[nb_count_1] int knots_count_1;  // number of knots
  // basis function matrices
  matrix[N_count, knots_count_1[1]] Zs_count_1_1;
  int<lower=1> N_biomass;  // number of observations
  vector[N_biomass] Y_biomass;  // response variable
  // data for splines
  int Ks_biomass;  // number of linear effects
  matrix[N_biomass, Ks_biomass] Xs_biomass;  // design matrix for the linear effects
  // data for spline 1
  int nb_biomass_1;  // number of bases
  array[nb_biomass_1] int knots_biomass_1;  // number of knots
  // basis function matrices
  matrix[N_biomass, knots_biomass_1[1]

ğŸ” MU_TREND PATTERN ANALYSIS:
   total_mu_trend_lines: 4
   mu_trend_declarations: 1
   mu_trend_assignments: 1
   mu_trend_references: 1
   sample_lines:   vector[N_trend] mu_trend = rep_vector(0.0, N_trend);; mu_trend += Intercept_trend;;   // dot_product captures dynamic component, mu_trend captures trend_formula

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

ğŸ”¬ SCENARIO: Monotonic CAR (Target 7 - failing)
   Main Formula: structure(list(formula = y ~ (1 | series), pforms = list(), pfix = list(), 
    Main Formula:     family = structure(list(family = "poisson", link = "log", 
    Main Formula:         linkfun = function (mu) 
    Main Formula:         link(mu, link = slink), linkinv = function (eta) 
    Main Formula:         inv_link(eta, link = slink), dpars = "mu", type = "int", 
    Main Formula:         ybounds = c(0, Inf), closed = c(TRUE, NA), ad = c("weights", 
    Main Formula:         "subset", "cens", "trunc", "rate", "index"), specials = "sbi_log"), class = c("brmsfamily", 
    Main Formula:     "family")), resp = "y"), class = c("brmsformula", "bform"
    Main Formula: ))
   Trend Formula: ~mo(income) + CAR()
   Data Type: univariate

ğŸ” Running full mvgam pipeline:
   Monotonic_CAR

ğŸ” MVGAM FORMULA CREATED:
   formula: structure(list(formula = y ~ (1 | series), pforms = list(), pfix = list(), ;     family = structure(list(family = "poisson", link = "log", ;         linkfun = function (mu) ;         link(mu, link = slink), linkinv = function (eta) ;         inv_link(eta, link = slink), dpars = "mu", type = "int", ;         ybounds = c(0, Inf), closed = c(TRUE, NA), ad = c("weights", ;         "subset", "cens", "trunc", "rate", "index"), specials = "sbi_log"), class = c("brmsfamily", ;     "family")), resp = "y"), class = c("brmsformula", "bform"; ))
   trend_formula: ~mo(income) + CAR()
   data_rows: 24

  ğŸ” EXTRACT_AND_RENAME INPUT:
     scenario: Monotonic_CAR
     suffix: _trend
     is_multivariate: FALSE
     response_names: 
     stancode_preview: // generated with brms 2.22.9
functions {
  /* compute monotonic effects
   * Args:
   *   scale: a simplex parameter
   *   i: index to sum over the simplex
   * Returns:
   *   a scalar between 0 and rows(scale)
   */
  real mo(vector scale, int i) {
    if (i == 0) {
      return 0;
    } else {

     mapping_summary: original_to_renamed: 0 items, renamed_to_original: 0 items

  ğŸ” EXTRACT_COMPUTED_VARIABLES:
     scenario: Monotonic_CAR
     found_variables: NONE FOUND

  ğŸ” EXTRACT_COMPUTED_VARIABLES:
     scenario: Monotonic_CAR
     found_variables: NONE FOUND

  ğŸ” EXTRACT_COMPUTED_VARIABLES:
     scenario: Monotonic_CAR
     found_variables: NONE FOUND

  ğŸ” EXTRACT_MU_CONSTRUCTION INPUT:
     scenario: Monotonic_CAR
     stancode_length: 1808
     stancode_preview: // generated with brms 2.22.9
functions {
  /* compute monotonic effects
   * Args:
   *   scale: a simplex parameter
   *   i: index to sum over the simplex
   * Returns:
   *   a scalar between 0 an

  ğŸ” FIND_VARIABLE_DECLARATIONS INPUT:
     scenario: Monotonic_CAR
     stancode_length: 1808
     referenced_vars_count: 6
     referenced_vars: N, mu, Intercept, bsp, simo_1, Xmo_1

  ğŸ” FIND_VARIABLE_DECLARATIONS OUTPUT:
     found_declarations_count: 5
     found_declarations: int<lower=1> N;  // total number of observations; vector[N] Y;  // response variable; array[N] int Xmo_1;  // monotonic variable; real Intercept;  // temporary intercept for centered predictors; vector[Ksp] bsp;  // special effects coefficients
     missing_vars: N, mu, Intercept, bsp, simo_1, Xmo_1

  ğŸ” EXTRACT_MU_CONSTRUCTION OUTPUT:
     mu_construction_count: 3
     mu_construction: vector[N] mu = rep_vector(0.0, N);; mu += Intercept;; mu[n] += (bsp[1]) * mo(simo_1, Xmo_1[n]);
     supporting_declarations_count: 5
     supporting_declarations: int<lower=1> N;  // total number of observations; vector[N] Y;  // response variable; array[N] int Xmo_1;  // monotonic variable; real Intercept;  // temporary intercept for centered predictors; vector[Ksp] bsp;  // special effects coefficients
     referenced_variables_count: 6
     referenced_variables: N; mu; Intercept; bsp; simo_1; Xmo_1

  ğŸ” EXTRACT_COMPUTED_VARIABLES:
     scenario: Monotonic_CAR
     found_variables: mu; b_Intercept

  ğŸ” FIND_VARIABLE_DECLARATIONS INPUT:
     scenario: Monotonic_CAR
     stancode_length: 1808
     referenced_vars_count: 1
     referenced_vars: mu

  ğŸ” FIND_VARIABLE_DECLARATIONS OUTPUT:
     found_declarations_count: 0
     found_declarations: NONE FOUND
     missing_vars: mu

  ğŸ” RECONSTRUCT_MU_TREND INPUT:
     scenario: Monotonic_CAR
     mu_construction_count: 3
     mu_construction: vector[N] mu = rep_vector(0.0, N);; mu += Intercept;; mu[n] += (bsp[1]) * mo(simo_1, Xmo_1[n]);
     supporting_declarations_count: 5
     supporting_declarations: int<lower=1> N;  // total number of observations; vector[N] Y;  // response variable; array[N] int Xmo_1;  // monotonic variable; real Intercept;  // temporary intercept for centered predictors; vector[Ksp] bsp;  // special effects coefficients
     variable_mapping_count: 10
     variable_mapping: con_simo_1 -> con_simo_1_trend; Xmo_1 -> Xmo_1_trend; Ksp -> Ksp_trend; Imo -> Imo_trend; Jmo -> Jmo_trend; N -> N_trend; Intercept -> Intercept_trend; simo_1 -> simo_1_trend; bsp -> bsp_trend; mu -> mu_trend
     time_param: N_trend

    ğŸ” STEP-BY-STEP RECONSTRUCTION ANALYSIS:
       step: 1_INPUT_ANALYSIS
       original_mu_expressions: vector[N] mu = rep_vector(0.0, N);; mu += Intercept;; mu[n] += (bsp[1]) * mo(simo_1, Xmo_1[n]);
       has_mu_initialization: TRUE
       has_mu_assignments: TRUE
       has_variable_declarations: TRUE

    ğŸ” STEP-BY-STEP RECONSTRUCTION ANALYSIS:
       step: 2_OUTPUT_ANALYSIS
       transformed_expressions: vector[N_trend] mu_trend = rep_vector(0.0, N_trend);; mu_trend += Intercept_trend;; ; for (n in 1:N_trend) {;   mu_trend[n] += (bsp_trend[1]) * mo(simo_1_trend, Xmo_1_trend[n]);; }
       has_mu_trend_initialization: TRUE
       mu_trend_init_count: 1
       has_mu_trend_assignments: TRUE
       duplicate_initialization_detected: FALSE

      ğŸ” RECONSTRUCTION LINE ANALYSIS:
         line_number: 1
         content: vector[N_trend] mu_trend = rep_vector(0.0, N_trend);
         is_mu_trend_init: TRUE
         is_mu_trend_assignment: FALSE
         is_supporting_declaration: FALSE
         line_type: INITIALIZATION

      ğŸ” RECONSTRUCTION LINE ANALYSIS:
         line_number: 2
         content: mu_trend += Intercept_trend;
         is_mu_trend_init: FALSE
         is_mu_trend_assignment: TRUE
         is_supporting_declaration: FALSE
         line_type: ASSIGNMENT

      ğŸ” RECONSTRUCTION LINE ANALYSIS:
         line_number: 3
         content: 
         is_mu_trend_init: FALSE
         is_mu_trend_assignment: FALSE
         is_supporting_declaration: FALSE
         line_type: OTHER

      ğŸ” RECONSTRUCTION LINE ANALYSIS:
         line_number: 4
         content: for (n in 1:N_trend) {
         is_mu_trend_init: FALSE
         is_mu_trend_assignment: FALSE
         is_supporting_declaration: FALSE
         line_type: OTHER

      ğŸ” RECONSTRUCTION LINE ANALYSIS:
         line_number: 5
         content:   mu_trend[n] += (bsp_trend[1]) * mo(simo_1_trend, Xmo_1_trend[n]);
         is_mu_trend_init: FALSE
         is_mu_trend_assignment: FALSE
         is_supporting_declaration: FALSE
         line_type: OTHER

      ğŸ” RECONSTRUCTION LINE ANALYSIS:
         line_number: 6
         content: }
         is_mu_trend_init: FALSE
         is_mu_trend_assignment: FALSE
         is_supporting_declaration: FALSE
         line_type: OTHER

  ğŸ” RECONSTRUCT_MU_TREND OUTPUT:
     result_length: 6
     result: vector[N_trend] mu_trend = rep_vector(0.0, N_trend);; mu_trend += Intercept_trend;; ; for (n in 1:N_trend) {;   mu_trend[n] += (bsp_trend[1]) * mo(simo_1_trend, Xmo_1_trend[n]);; }

  ğŸ” STANVAR CREATION DECISION:
     has_mu_construction: FALSE
     logic: Fallback system should create stanvar

  ğŸ” EXTRACT_AND_RENAME OUTPUT:
     stanvars_count: 3
     stanvar_names: ; ; 
     mapping_updated: original_to_renamed: 10 items, renamed_to_original: 10 items

ğŸ” LINEAR PREDICTOR INJECTION:
   scenario: Monotonic_CAR
   message: Checking if Enhanced system or GLM bypass will be used

ğŸ” LINEAR PREDICTOR RESULT:
   scenario: Monotonic_CAR
   result_type: character
   glm_bypass_occurred: FALSE

ğŸ” ERROR IN SCENARIO:
No traceback available 
   scenario: Monotonic_CAR
   error: Error: Assertion on 'formula' failed: One of the following must apply:
 * checkmate::check_class(formula): Must inherit from class 'formula',
 * but has classes 'brmsformula','bform'
 * checkmate::check_class(formula): Must inherit from class
 * 'mvbrmsformula', but has classes 'brmsformula','bform'.

   traceback: 

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

There were 16 warnings (use warnings() to see them)
ğŸ“ˆ COMPREHENSIVE ANALYSIS ACROSS ALL SCENARIOS
====================================================================

ğŸ“‹ SCENARIO ANALYSIS: RW_simple
ğŸ” Generated Stan Code Analysis:
   scenario_completed: FALSE
   monkey_patches_triggered: FALSE

ğŸ” Mu Construction Extraction:
   NOT TRIGGERED - Enhanced system bypassed

ğŸ” Reconstruction Process:
   NOT TRIGGERED

ğŸ” Stanvar Creation Process:
   NOT TRIGGERED

ğŸ” GLM BYPASS ANALYSIS:
   glm_bypass_used: FALSE
   impact: Enhanced system should be active


ğŸ“‹ SCENARIO ANALYSIS: VARMA_complex
ğŸ” Generated Stan Code Analysis:
   scenario_completed: FALSE
   monkey_patches_triggered: FALSE

ğŸ” Mu Construction Extraction:
   NOT TRIGGERED - Enhanced system bypassed

ğŸ” Reconstruction Process:
   NOT TRIGGERED

ğŸ” Stanvar Creation Process:
   NOT TRIGGERED

ğŸ” GLM BYPASS ANALYSIS:
   glm_bypass_used: FALSE
   impact: Enhanced system should be active


ğŸ“‹ SCENARIO ANALYSIS: GP_CAR_complex
ğŸ” Generated Stan Code Analysis:
   scenario_completed: FALSE
   monkey_patches_triggered: FALSE

ğŸ” Mu Construction Extraction:
   NOT TRIGGERED - Enhanced system bypassed

ğŸ” Reconstruction Process:
   NOT TRIGGERED

ğŸ” Stanvar Creation Process:
   NOT TRIGGERED

ğŸ” GLM BYPASS ANALYSIS:
   glm_bypass_used: FALSE
   impact: Enhanced system should be active


ğŸ“‹ SCENARIO ANALYSIS: Spline_multivariate
ğŸ” Generated Stan Code Analysis:
   scenario_completed: FALSE
   monkey_patches_triggered: FALSE

ğŸ” Mu Construction Extraction:
   NOT TRIGGERED - Enhanced system bypassed

ğŸ” Reconstruction Process:
   NOT TRIGGERED

ğŸ” Stanvar Creation Process:
   NOT TRIGGERED

ğŸ” GLM BYPASS ANALYSIS:
   glm_bypass_used: FALSE
   impact: Enhanced system should be active


ğŸ“‹ SCENARIO ANALYSIS: Monotonic_CAR
ğŸ” Generated Stan Code Analysis:
   scenario_completed: FALSE
   monkey_patches_triggered: FALSE

ğŸ” Mu Construction Extraction:
   NOT TRIGGERED - Enhanced system bypassed

ğŸ” Reconstruction Process:
   NOT TRIGGERED

ğŸ” Stanvar Creation Process:
   NOT TRIGGERED

ğŸ” GLM BYPASS ANALYSIS:
   glm_bypass_used: FALSE
   impact: Enhanced system should be active


ğŸ¯ KEY FINDINGS AND RECOMMENDATIONS
====================================================================
ğŸ” CROSS-SCENARIO ANALYSIS:
   total_scenarios: 5
   scenarios_with_mu_construction: NONE
   scenarios_with_reconstruction: NONE
   scenarios_with_stanvar: NONE
   scenarios_with_glm_bypass: NONE
   enhanced_vs_glm_conflict: FALSE


ğŸ”§ CRITICAL FINDINGS:
   âœ… No GLM bypass detected - Enhanced system should be working

ğŸ”§ DEBUGGING RECOMMENDATIONS:
   1. GLM bypass scenarios need mu_trend integration in GLM path
   2. Enhanced system scenarios should use reconstruction properly
   3. No scenario should have both Enhanced system AND GLM bypass
   4. All scenarios should result in proper mu_trend declaration via ONE path
   5. Fix GLM bypass to include mu_trend or disable GLM optimization

âœ… COMPREHENSIVE DEBUGGING COMPLETE
   Original functions restored
   Results available in debug_state$results
====================================================================
