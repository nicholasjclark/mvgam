#' Stan Code Assembly for mvgam
#'
#' @description
#' Two-stage Stan code assembly system that combines brms-generated Stan code
#' with trend stanvars to create complete mvgam models.
#'
#' @details
#' This system follows the refactoring plan's two-stage approach:
#' 1. Generate complete trend stanvars using existing registry generators
#' 2. Integrate stanvars with brms Stan code generation for final assembly

#' Assemble Complete mvgam Stan Code
#'
#' @description
#' Combines brms-generated Stan code with trend stanvars to create complete
#' mvgam Stan model code. Handles proper integration of trend components
#' into brms code structure.
#'
#' @param obs_formula Formula for observation model (passed to brms)
#' @param trend_stanvars List of stanvars generated by trend system
#' @param data Data frame for model fitting
#' @param family brms family specification
#' @param ... Additional arguments passed to brms
#' @return Character string containing complete Stan model code
#' @noRd
assemble_mvgam_stan_code <- function(obs_formula, trend_stanvars, data, 
                                    family = gaussian(), ...) {
  checkmate::assert_formula(obs_formula)
  checkmate::assert_list(trend_stanvars, names = "named")
  checkmate::assert_data_frame(data, min.rows = 1)
  
  # Generate base brms Stan code with trend stanvars included
  base_stancode <- generate_base_brms_stancode(obs_formula, trend_stanvars, 
                                              data, family, ...)
  
  # Validate base Stan code structure
  validate_stan_code_structure(base_stancode)
  
  # Inject trend-specific modifications
  final_stancode <- inject_trend_modifications(base_stancode, trend_stanvars)
  
  # Final validation
  validate_stan_syntax(final_stancode)
  
  return(final_stancode)
}

#' Assemble Complete mvgam Stan Data
#'
#' @description
#' Combines brms-generated Stan data with trend data requirements.
#' Ensures all data components needed by trends are available.
#'
#' @param obs_formula Formula for observation model (passed to brms)
#' @param trend_stanvars List of stanvars generated by trend system
#' @param data Data frame for model fitting
#' @param family brms family specification
#' @param ... Additional arguments passed to brms
#' @return List containing complete Stan data
#' @noRd
assemble_mvgam_stan_data <- function(obs_formula, trend_stanvars, data,
                                    family = gaussian(), ...) {
  checkmate::assert_formula(obs_formula)
  checkmate::assert_list(trend_stanvars, names = "named")
  checkmate::assert_data_frame(data, min.rows = 1)
  
  # Generate base brms Stan data with trend stanvars included
  base_standata <- generate_base_brms_standata(obs_formula, trend_stanvars,
                                              data, family, ...)
  
  # Add trend-specific data components
  trend_data <- extract_trend_data_components(trend_stanvars, data)
  
  # Merge data ensuring no conflicts
  final_standata <- merge_stan_data(base_standata, trend_data)
  
  # Validate final data structure
  validate_stan_data_structure(final_standata)
  
  return(final_standata)
}

#' Generate Base brms Stan Code
#'
#' @description
#' Generates brms Stan code with trend stanvars integrated.
#' Uses brms::stancode() with stanvars parameter.
#'
#' @param obs_formula Formula for observation model
#' @param trend_stanvars List of trend stanvars
#' @param data Data frame
#' @param family brms family
#' @param ... Additional brms arguments
#' @return Character string with base Stan code
#' @noRd
generate_base_brms_stancode <- function(obs_formula, trend_stanvars, data,
                                       family, ...) {
  # Prepare stanvars for brms
  brms_stanvars <- prepare_stanvars_for_brms(trend_stanvars)
  
  # Generate brms Stan code with integrated stanvars
  if (requireNamespace("brms", quietly = TRUE)) {
    stan_code <- brms::stancode(
      formula = obs_formula,
      data = data,
      family = family,
      stanvars = brms_stanvars,
      ...
    )
  } else {
    stop(insight::format_error("Package {.pkg brms} required for Stan code generation"))
  }
  
  return(stan_code)
}

#' Generate Base brms Stan Data
#'
#' @description
#' Generates brms Stan data with trend stanvars integrated.
#' Uses brms::standata() with stanvars parameter.
#'
#' @param obs_formula Formula for observation model
#' @param trend_stanvars List of trend stanvars
#' @param data Data frame
#' @param family brms family
#' @param ... Additional brms arguments
#' @return List with base Stan data
#' @noRd
generate_base_brms_standata <- function(obs_formula, trend_stanvars, data,
                                       family, ...) {
  # Prepare stanvars for brms
  brms_stanvars <- prepare_stanvars_for_brms(trend_stanvars)
  
  # Generate brms Stan data with integrated stanvars
  if (requireNamespace("brms", quietly = TRUE)) {
    stan_data <- brms::standata(
      formula = obs_formula,
      data = data,
      family = family,
      stanvars = brms_stanvars,
      ...
    )
  } else {
    stop(insight::format_error("Package {.pkg brms} required for Stan data generation"))
  }
  
  return(stan_data)
}

#' Extract Trend Stanvars from brms Setup
#' 
#' @description
#' Stage 1 of two-stage assembly: Generate complete trend Stan code and extract
#' stanvars for injection into the base brms observation model.
#' 
#' @param trend_setup List containing brms setup components for trend model
#' @param trend_spec List containing trend specification details
#' @return List of stanvars containing trend parameters and functions
#' @noRd
extract_trend_stanvars_from_setup <- function(trend_setup, trend_spec) {
  checkmate::assert_list(trend_setup, names = "named")
  checkmate::assert_list(trend_spec, names = "named")
  
  # Extract data information from trend_setup
  data_info <- extract_data_info_from_setup(trend_setup)
  
  # Generate trend injection stanvars that add temporal dynamics to brms code
  # brms provides: trend_mus = X_trend * b_trend
  # we add: temporal dynamics applied to LV using trend_mus as mean
  trend_stanvars <- generate_trend_injection_stanvars(
    trend_spec = trend_spec,
    data_info = data_info
  )
  
  return(trend_stanvars)
}

#' Extract Data Information from Setup
#' 
#' @description
#' Extracts data structure information needed for trend Stan code generation.
#' 
#' @param trend_setup brms setup object containing standata
#' @return List of data information
#' @noRd
extract_data_info_from_setup <- function(trend_setup) {
  standata <- trend_setup$standata
  
  data_info <- list(
    n_times = standata$N %||% standata$n %||% 10,
    n_series = standata$n_series %||% 1,
    n_lv = standata$n_lv %||% standata$n_series %||% 1,  # Critical for LV models
    time_vals = standata$time_vals %||% seq_len(standata$N %||% 10),
    ytimes = standata$ytimes %||% NULL,
    ytimes_trend = standata$ytimes_trend %||% NULL  # Critical for trend indexing
  )
  
  return(data_info)
}

#' Parse Trend Stan Code
#' 
#' @description
#' Parses generated trend Stan code to extract components for stanvar creation.
#' 
#' @param stan_code Character string of trend Stan code
#' @param trend_spec Trend specification
#' @return List of parsed trend components
#' @noRd
parse_trend_stan_code <- function(stan_code, trend_spec) {
  code_lines <- strsplit(stan_code, "\n")[[1]]
  
  # Extract functions block
  functions_block <- extract_code_block(code_lines, "functions")
  
  # Extract data block 
  data_block <- extract_code_block(code_lines, "data")
  
  # Extract parameters block
  parameters_block <- extract_code_block(code_lines, "parameters")
  
  # Extract transformed parameters block
  transformed_parameters_block <- extract_code_block(code_lines, "transformed parameters")
  
  # Extract model block
  model_block <- extract_code_block(code_lines, "model")
  
  # Extract generated quantities block
  generated_quantities_block <- extract_code_block(code_lines, "generated quantities")
  
  return(list(
    functions = functions_block,
    data = data_block,
    parameters = parameters_block,
    transformed_parameters = transformed_parameters_block,
    model = model_block,
    generated_quantities = generated_quantities_block,
    trend_type = trend_spec$type
  ))
}

#' Create Trend Stanvars
#' 
#' @description
#' Creates brms stanvars from parsed trend components.
#' 
#' @param trend_components List of parsed trend components
#' @param standata Original standata from trend setup
#' @return List of stanvars for injection
#' @noRd
create_trend_stanvars <- function(trend_components, standata) {
  stanvars <- list()
  
  # Add functions stanvar if functions exist
  if (!is.null(trend_components$functions) && nchar(trend_components$functions) > 0) {
    stanvars$functions <- stanvar(
      x = NULL, 
      name = "trend_functions", 
      scode = trend_components$functions
    )
  }
  
  # Add data stanvars
  if (!is.null(trend_components$data)) {
    data_vars <- extract_data_declarations(trend_components$data)
    for (var_name in names(data_vars)) {
      if (var_name %in% names(standata)) {
        stanvars[[paste0("data_", var_name)]] <- stanvar(
          x = standata[[var_name]],
          name = var_name,
          scode = "data"
        )
      }
    }
  }
  
  # Add parameter stanvars as generated quantities
  if (!is.null(trend_components$parameters)) {
    stanvars$trend_parameters <- stanvar(
      x = NULL,
      name = "trend_parameters", 
      scode = trend_components$parameters
    )
  }
  
  # Add transformed parameters
  if (!is.null(trend_components$transformed_parameters)) {
    stanvars$trend_transformed <- stanvar(
      x = NULL,
      name = "trend_transformed",
      scode = trend_components$transformed_parameters
    )
  }
  
  # Add model block contributions
  if (!is.null(trend_components$model)) {
    stanvars$trend_model <- stanvar(
      x = NULL,
      name = "trend_model_contributions",
      scode = trend_components$model
    )
  }
  
  # Add generated quantities
  if (!is.null(trend_components$generated_quantities)) {
    stanvars$trend_generated <- stanvar(
      x = NULL,
      name = "trend_generated_quantities",
      scode = trend_components$generated_quantities
    )
  }
  
  return(stanvars)
}

#' Extract Trend Parameters from Stan Code
#' 
#' @description
#' Parses trend Stan code to extract parameter declarations.
#' 
#' @param stancode Character string containing trend Stan code
#' @param trend_spec List containing trend specification
#' @return List of trend parameter information
#' @noRd
extract_trend_parameters <- function(stancode, trend_spec) {
  checkmate::assert_string(stancode, min.chars = 1)
  checkmate::assert_list(trend_spec)
  
  # Split Stan code into lines for parsing
  code_lines <- strsplit(stancode, "\n")[[1]]
  
  # Find parameters block
  param_start <- grep("^\\s*parameters\\s*\\{", code_lines)
  param_end <- find_matching_brace(code_lines, param_start)
  
  if (length(param_start) == 0 || length(param_end) == 0) {
    # No parameters block found, return empty structure
    return(list(
      trend_raw = NULL,
      trend_pars = NULL
    ))
  }
  
  param_lines <- code_lines[param_start:param_end]
  
  # Extract trend-related parameters
  trend_raw_lines <- grep("trend_raw", param_lines, value = TRUE)
  trend_par_lines <- grep("trend_.*(?<!_raw)", param_lines, value = TRUE, perl = TRUE)
  
  return(list(
    trend_raw = parse_parameter_declarations(trend_raw_lines),
    trend_pars = parse_parameter_declarations(trend_par_lines)
  ))
}

#' Extract Trend Functions from Stan Code
#' 
#' @description
#' Parses trend Stan code to extract custom function definitions.
#' 
#' @param stancode Character string containing trend Stan code
#' @param trend_spec List containing trend specification
#' @return Character vector of function definitions
#' @noRd
extract_trend_functions <- function(stancode, trend_spec) {
  checkmate::assert_string(stancode, min.chars = 1)
  checkmate::assert_list(trend_spec)
  
  # Split Stan code into lines for parsing
  code_lines <- strsplit(stancode, "\n")[[1]]
  
  # Find functions block
  func_start <- grep("^\\s*functions\\s*\\{", code_lines)
  
  if (length(func_start) == 0) {
    return(character(0))
  }
  
  func_end <- find_matching_brace(code_lines, func_start)
  
  if (length(func_end) == 0) {
    return(character(0))
  }
  
  # Extract function block content
  func_lines <- code_lines[func_start:func_end]
  
  # Return as single string
  return(paste(func_lines, collapse = "\n"))
}

#' Extract Trend Data from standata
#' 
#' @description
#' Extracts trend-related data components from brms standata.
#' 
#' @param standata List containing brms stan data
#' @param trend_spec List containing trend specification
#' @return List of trend data components
#' @noRd
extract_trend_data <- function(standata, trend_spec) {
  checkmate::assert_list(standata)
  checkmate::assert_list(trend_spec)
  
  # Extract trend-related data elements
  trend_data_names <- grep("^trend_", names(standata), value = TRUE)
  trend_data <- standata[trend_data_names]
  
  # Add missing data pattern information if available
  if ("obs_ind" %in% names(standata)) {
    trend_data$obs_ind <- standata$obs_ind
  }
  
  # Add time structure information
  if ("n" %in% names(standata)) {
    trend_data$n_times <- standata$n
  }
  
  if ("n_series" %in% names(standata)) {
    trend_data$n_series <- standata$n_series
  }
  
  return(trend_data)
}

#' Inject Trend into Linear Predictor
#' 
#' @description
#' Stage 2 of two-stage assembly: Modify brms Stan code to integrate temporal dynamics.
#' Key steps:
#' 1. Rename trend model's 'mu' to 'mu_trend' 
#' 2. Add LV temporal dynamics using mu_trend as mean
#' 3. Create trend effects and combine with observation mu
#' 
#' @param base_stancode Character string containing base brms Stan code
#' @param trend_stanvars List of trend stanvars from Stage 1
#' @param trend_spec List containing trend specification
#' @return Character string of modified Stan code
#' @noRd
inject_trend_into_linear_predictor <- function(base_stancode, trend_stanvars, trend_spec) {
  checkmate::assert_string(base_stancode, min.chars = 1)
  checkmate::assert_list(trend_stanvars)
  checkmate::assert_list(trend_spec)
  
  # Parse base Stan code
  code_lines <- strsplit(base_stancode, "\n")[[1]]
  
  # Step 1: Rename trend model's 'mu' to 'mu_trend'
  # This preserves brms trend formula effects as mu_trend
  modified_code <- rename_trend_mu_to_mu_trend(code_lines)
  
  # Step 2: Add LV array and trend computation in transformed parameters
  modified_code <- add_lv_and_trend_computation(modified_code, trend_spec)
  
  # Step 3: Inject temporal dynamics into model block
  modified_code <- inject_temporal_dynamics(modified_code, trend_stanvars)
  
  # Step 4: Modify observation likelihood to use combined effects
  modified_code <- modify_observation_likelihood(modified_code, trend_spec)
  
  # Validate the modified code
  final_code <- paste(modified_code, collapse = "\n")
  
  return(final_code)
}

#' Rename Trend Model mu to mu_trend
#' 
#' @description
#' Renames the trend model's 'mu' variable to 'mu_trend' to distinguish it
#' from the observation model's 'mu'. This preserves brms trend formula effects.
#' 
#' @param code_lines Character vector of Stan code lines
#' @return Character vector of modified Stan code lines
#' @noRd
rename_trend_mu_to_mu_trend <- function(code_lines) {
  checkmate::assert_character(code_lines)
  
  # Find where mu is declared and initialized in model block
  model_start <- grep("^\\s*model\\s*\\{", code_lines)
  model_end <- find_matching_brace(code_lines, model_start)
  
  if (length(model_start) == 0 || length(model_end) == 0) {
    return(code_lines)
  }
  
  # Within model block, rename mu declarations and assignments to mu_trend
  for (i in model_start:model_end) {
    # Pattern: vector[N] mu = rep_vector(0.0, N);
    if (grepl("vector\\[.*\\]\\s+mu\\s*=\\s*rep_vector", code_lines[i])) {
      code_lines[i] <- gsub("\\bmu\\b", "mu_trend", code_lines[i])
    }
    # Pattern: mu += ...
    if (grepl("^\\s*mu\\s*\\+=", code_lines[i])) {
      code_lines[i] <- gsub("\\bmu\\b", "mu_trend", code_lines[i])
    }
  }
  
  return(code_lines)
}

#' Add LV Array and Trend Computation
#' 
#' @description
#' Adds LV array declaration and trend computation in transformed parameters.
#' This creates the latent variable structure needed for temporal dynamics.
#' 
#' @param code_lines Character vector of Stan code lines
#' @param trend_spec Trend specification
#' @return Character vector of modified Stan code lines
#' @noRd
add_lv_and_trend_computation <- function(code_lines, trend_spec) {
  checkmate::assert_character(code_lines)
  checkmate::assert_list(trend_spec)
  
  # Find transformed parameters block
  trans_param_start <- grep("^\\s*transformed\\s+parameters\\s*\\{", code_lines)
  
  if (length(trans_param_start) == 0) {
    # Create transformed parameters block if it doesn't exist
    param_end <- grep("^\\s*parameters\\s*\\{", code_lines)
    param_end <- find_matching_brace(code_lines, param_end)
    
    if (length(param_end) == 0) {
      return(code_lines)
    }
    
    # Insert new transformed parameters block
    lv_and_trend_block <- c(
      "transformed parameters {",
      "  // latent states for temporal dynamics",
      "  array[n] vector[n_lv] LV;",
      "  // trend effects mapped from latent states", 
      "  matrix[n, n_series] trend;",
      "  // loading matrix",
      "  matrix[n_series, n_lv] lv_coefs = Z;",
      "}"
    )
    
    modified_lines <- c(
      code_lines[1:param_end],
      lv_and_trend_block,
      code_lines[(param_end + 1):length(code_lines)]
    )
    
  } else {
    # Add to existing transformed parameters block
    trans_param_end <- find_matching_brace(code_lines, trans_param_start)
    
    lv_declarations <- c(
      "  // latent states for temporal dynamics",
      "  array[n] vector[n_lv] LV;",
      "  // trend effects mapped from latent states",
      "  matrix[n, n_series] trend;", 
      "  // loading matrix",
      "  matrix[n_series, n_lv] lv_coefs = Z;",
      "",
      "  // compute trend effects from latent states",
      "  for (i in 1:n) {",
      "    for (s in 1:n_series) {",
      "      trend[i, s] = dot_product(lv_coefs[s, :], LV[i, :]);",
      "    }",
      "  }"
    )
    
    # Insert before closing brace
    modified_lines <- c(
      code_lines[1:(trans_param_end - 1)],
      lv_declarations,
      code_lines[trans_param_end:length(code_lines)]
    )
  }
  
  return(modified_lines)
}

#' Inject Temporal Dynamics
#' 
#' @description
#' Injects temporal dynamics into the model block using the stanvars.
#' This adds the LV evolution equations that use mu_trend as the mean.
#' 
#' @param code_lines Character vector of Stan code lines
#' @param trend_stanvars List of trend stanvars
#' @return Character vector of modified Stan code lines
#' @noRd
inject_temporal_dynamics <- function(code_lines, trend_stanvars) {
  checkmate::assert_character(code_lines)
  checkmate::assert_list(trend_stanvars)
  
  # Find model block
  model_start <- grep("^\\s*model\\s*\\{", code_lines)
  model_end <- find_matching_brace(code_lines, model_start)
  
  if (length(model_start) == 0 || length(model_end) == 0) {
    return(code_lines)
  }
  
  # Extract temporal dynamics code from stanvars
  temporal_code <- c()
  
  for (stanvar in trend_stanvars) {
    if (grepl("model_block", stanvar$name %||% "")) {
      # Extract the temporal dynamics code
      stanvar_code <- stanvar$scode %||% ""
      if (nchar(stanvar_code) > 0) {
        temporal_code <- c(temporal_code, "", "  // Temporal dynamics from stanvar", 
                          paste0("  ", strsplit(stanvar_code, "\n")[[1]]))
      }
    }
  }
  
  if (length(temporal_code) == 0) {
    return(code_lines)
  }
  
  # Insert temporal dynamics before model block closing brace
  modified_lines <- c(
    code_lines[1:(model_end - 1)],
    temporal_code,
    code_lines[model_end:length(code_lines)]
  )
  
  return(modified_lines)
}

#' Modify Observation Likelihood
#' 
#' @description
#' Modifies the observation likelihood to use combined mu + trend effects.
#' Creates the pattern: mu_combined = mu + flat_trends
#' 
#' @param code_lines Character vector of Stan code lines  
#' @param trend_spec Trend specification
#' @return Character vector of modified Stan code lines
#' @noRd
modify_observation_likelihood <- function(code_lines, trend_spec) {
  checkmate::assert_character(code_lines)
  checkmate::assert_list(trend_spec)
  
  # Find where likelihood is computed (look for target += or Y ~ distribution)
  likelihood_lines <- grep("target\\s*\\+=.*_lpdf|~", code_lines)
  
  if (length(likelihood_lines) == 0) {
    return(code_lines)
  }
  
  # Find the last mu computation before likelihood
  likelihood_start <- likelihood_lines[1]
  mu_lines <- grep("vector\\[.*\\]\\s+mu\\s*=|mu\\s*\\+=", code_lines[1:likelihood_start])
  
  if (length(mu_lines) == 0) {
    return(code_lines)
  }
  
  # Insert trend combination after last mu computation
  last_mu_line <- mu_lines[length(mu_lines)]
  
  trend_combination <- c(
    "    // mvgam: combine observation and trend effects",
    "    vector[n_nonmissing] flat_trends = to_vector(trend)[obs_ind];",
    "    // modify mu to include trend effects - this happens in the likelihood"
  )
  
  modified_lines <- c(
    code_lines[1:last_mu_line],
    trend_combination,
    code_lines[(last_mu_line + 1):length(code_lines)]
  )
  
  # Modify the likelihood to use trend effects
  # Look for patterns like: target += normal_lpdf(Y | mu, sigma);
  # Replace with: target += normal_lpdf(Y | mu + flat_trends, sigma);
  for (i in 1:length(modified_lines)) {
    if (grepl("target\\s*\\+=.*\\(Y\\s*\\|\\s*mu[^_]", modified_lines[i])) {
      modified_lines[i] <- gsub("\\(Y\\s*\\|\\s*mu([^_])", "(Y | mu + flat_trends\\1", modified_lines[i])
    }
  }
  
  return(modified_lines)
}

#' Generate Trend Computation Code
#' 
#' @description
#' Generates Stan code for computing trend effects based on trend specification.
#' 
#' @param trend_spec List containing trend specification
#' @return Character string of trend computation code
#' @noRd
generate_trend_computation <- function(trend_spec) {
  checkmate::assert_list(trend_spec)
  
  # Basic template - can be extended for different trend types
  if (trend_spec$type == "RW") {
    return("// Random walk trend computation\nmu_trend = trend_effects;")
  } else if (trend_spec$type == "AR") {
    return("// AR trend computation\nmu_trend = trend_effects;")
  } else if (trend_spec$type == "VAR") {
    return("// VAR trend computation\nmu_trend = trend_effects;")
  } else {
    return("// Generic trend computation\nmu_trend = trend_effects;")
  }
}

#' Add Missing Data Preservation Pattern
#' 
#' @description
#' Implements missing data pattern where trends evolve over ALL timesteps
#' but likelihood only uses non-missing observations.
#' 
#' @param code_lines Character vector of Stan code lines
#' @param trend_spec List containing trend specification
#' @return Character vector of modified Stan code lines
#' @noRd
add_missing_data_pattern <- function(code_lines, trend_spec) {
  checkmate::assert_character(code_lines)
  checkmate::assert_list(trend_spec)
  
  # Find likelihood section
  likelihood_start <- grep("// likelihood", code_lines, ignore.case = TRUE)
  
  if (length(likelihood_start) == 0) {
    # Try to find target += patterns
    likelihood_start <- grep("target\\s*\\+=", code_lines)
  }
  
  if (length(likelihood_start) == 0) {
    insight::format_warning(
      "Could not find likelihood section in Stan code.",
      "Missing data pattern may not be applied correctly."
    )
    return(code_lines)
  }
  
  # Template for missing data pattern
  missing_data_template <- glue::glue("
    // Missing data preservation: likelihood only for non-missing observations
    {{
      vector[n_nonmissing] selected_mu = mu_combined[obs_ind];
      flat_ys ~ {get_family_distribution(trend_spec)}(selected_mu, ...);
    }}
  ")
  
  # This is a placeholder - would need to be customized based on family
  # For now, just add a comment indicating where this would go
  comment_line <- "    // mvgam: Missing data pattern would be applied here"
  
  # Insert comment after first likelihood line
  insert_position <- likelihood_start[1] + 1
  
  modified_lines <- c(
    code_lines[1:(insert_position - 1)],
    comment_line,
    code_lines[insert_position:length(code_lines)]
  )
  
  return(modified_lines)
}

#' Helper Functions for Stan Code Parsing
#'
#' @description
#' Utility functions for parsing Stan code structure.

#' Find Matching Brace
#' 
#' @param code_lines Character vector of code lines
#' @param start_line Line number containing opening brace
#' @return Line number of matching closing brace
#' @noRd
find_matching_brace <- function(code_lines, start_line) {
  if (length(start_line) == 0) return(integer(0))
  
  brace_count <- 0
  start_pos <- start_line[1]
  
  for (i in start_pos:length(code_lines)) {
    open_braces <- length(gregexpr("\\{", code_lines[i])[[1]])
    if (open_braces > 0 && gregexpr("\\{", code_lines[i])[[1]][1] != -1) {
      brace_count <- brace_count + open_braces
    }
    
    close_braces <- length(gregexpr("\\}", code_lines[i])[[1]])
    if (close_braces > 0 && gregexpr("\\}", code_lines[i])[[1]][1] != -1) {
      brace_count <- brace_count - close_braces
    }
    
    if (brace_count == 0 && i > start_pos) {
      return(i)
    }
  }
  
  return(integer(0))
}

#' Parse Parameter Declarations
#' 
#' @param param_lines Character vector of parameter declaration lines
#' @return List of parsed parameter information
#' @noRd
parse_parameter_declarations <- function(param_lines) {
  if (length(param_lines) == 0) {
    return(NULL)
  }
  
  # Basic parsing - would need more sophisticated implementation
  return(param_lines)
}

#' Get Family Distribution Pattern
#' 
#' @param trend_spec List containing trend specification including family
#' @return Character string of distribution pattern
#' @noRd
get_family_distribution <- function(trend_spec) {
  family <- trend_spec$family %||% "gaussian"
  
  switch(family,
    "gaussian" = "normal",
    "poisson" = "poisson",
    "binomial" = "binomial",
    "beta" = "beta",
    "gamma" = "gamma",
    "normal"  # default
  )
}

#' Extract Code Block from Stan Code
#' 
#' @description
#' Extracts a specific block (functions, data, parameters, etc.) from Stan code.
#' 
#' @param code_lines Character vector of Stan code lines
#' @param block_name Name of the block to extract
#' @return Character string of the extracted block content
#' @noRd
extract_code_block <- function(code_lines, block_name) {
  # Find block start
  block_pattern <- paste0("^\\s*", block_name, "\\s*\\{")
  block_start <- grep(block_pattern, code_lines)
  
  if (length(block_start) == 0) {
    return(NULL)
  }
  
  # Find matching closing brace
  block_end <- find_matching_brace(code_lines, block_start[1])
  
  if (length(block_end) == 0) {
    return(NULL)
  }
  
  # Extract block content (including braces)
  block_content <- code_lines[block_start[1]:block_end[1]]
  
  return(paste(block_content, collapse = "\n"))
}

#' Extract Data Declarations from Data Block
#' 
#' @description
#' Parses data block to extract variable declarations.
#' 
#' @param data_block Character string of data block
#' @return Named list of data variables
#' @noRd
extract_data_declarations <- function(data_block) {
  if (is.null(data_block)) {
    return(list())
  }
  
  # Simple parsing - extract variable names
  # This is a basic implementation that could be made more sophisticated
  lines <- strsplit(data_block, "\n")[[1]]
  
  # Remove braces and comments
  lines <- gsub("\\{|\\}", "", lines)
  lines <- gsub("//.*$", "", lines)
  lines <- trimws(lines)
  lines <- lines[nchar(lines) > 0]
  
  # Extract variable names (simplified)
  var_names <- character()
  for (line in lines) {
    if (grepl(";", line)) {
      # Extract variable name after type declaration
      parts <- strsplit(line, "\\s+")[[1]]
      if (length(parts) >= 2) {
        var_part <- parts[length(parts)]
        var_name <- gsub(";.*", "", var_part)
        var_names <- c(var_names, var_name)
      }
    }
  }
  
  # Return as named list
  result <- as.list(rep(TRUE, length(var_names)))
  names(result) <- var_names
  
  return(result)
}

#' Prepare Stanvars for brms Integration
#'
#' @description
#' Converts trend stanvars to format expected by brms.
#' Ensures proper naming and structure for brms integration.
#'
#' @param trend_stanvars List of trend stanvars
#' @return List of stanvars ready for brms
#' @noRd
prepare_stanvars_for_brms <- function(trend_stanvars) {
  checkmate::assert_list(trend_stanvars, names = "named")
  
  # Extract stanvars that are actual brms stanvar objects
  brms_stanvars <- list()
  
  for (name in names(trend_stanvars)) {
    stanvar_obj <- trend_stanvars[[name]]
    
    # Check if it's a proper stanvar object
    if (is_valid_stanvar(stanvar_obj)) {
      brms_stanvars[[name]] <- stanvar_obj
    } else {
      rlang::warn(
        paste0("Skipping invalid stanvar: ", name),
        .frequency = "once",
        .frequency_id = paste0("invalid_stanvar_", name)
      )
    }
  }
  
  return(brms_stanvars)
}

#' Validate Stanvar Object
#'
#' @description
#' Checks if object is a valid brms stanvar.
#'
#' @param obj Object to validate
#' @return Logical indicating validity
#' @noRd
is_valid_stanvar <- function(obj) {
  # Basic structure checks for stanvar objects
  if (!is.list(obj)) return(FALSE)
  
  # Check for required stanvar components
  required_components <- c("name", "scode")
  has_required <- all(required_components %in% names(obj))
  
  # Check for valid scode
  valid_scode <- is.character(obj$scode) && length(obj$scode) == 1 && 
                 nchar(obj$scode) > 0
  
  return(has_required && valid_scode)
}

#' Inject Trend Modifications into Stan Code
#'
#' @description
#' Applies trend-specific modifications to brms-generated Stan code.
#' This handles special cases not covered by stanvars alone.
#'
#' @param base_stancode Base Stan code from brms
#' @param trend_stanvars Trend stanvars for reference
#' @return Modified Stan code
#' @noRd
inject_trend_modifications <- function(base_stancode, trend_stanvars) {
  checkmate::assert_string(base_stancode, min.chars = 1)
  checkmate::assert_list(trend_stanvars, names = "named")
  
  modified_code <- base_stancode
  
  # Apply trend-specific modifications
  modified_code <- inject_missing_data_handling(modified_code)
  modified_code <- inject_trend_linear_predictor(modified_code)
  
  return(modified_code)
}

#' Inject Missing Data Handling
#'
#' @description
#' Modifies Stan code to handle missing data patterns in trend context.
#' Ensures likelihood only evaluates for non-missing observations.
#'
#' @param stan_code Stan code to modify
#' @return Modified Stan code
#' @noRd
inject_missing_data_handling <- function(stan_code) {
  checkmate::assert_string(stan_code, min.chars = 1)
  
  # For now, return unmodified code
  # TODO: Implement missing data patterns when needed
  return(stan_code)
}

#' Inject Trend Linear Predictor
#'
#' @description
#' Modifies observation linear predictor to include trend effects.
#' Implements mu_combined = mu + mu_trend pattern.
#'
#' @param stan_code Stan code to modify
#' @return Modified Stan code
#' @noRd
inject_trend_linear_predictor <- function(stan_code) {
  checkmate::assert_string(stan_code, min.chars = 1)
  
  # For now, return unmodified code
  # TODO: Implement linear predictor modification when needed
  return(stan_code)
}

#' Extract Trend Data Components
#'
#' @description
#' Extracts data components needed by trend stanvars.
#' Processes time variables, series identifiers, and other trend requirements.
#'
#' @param trend_stanvars List of trend stanvars
#' @param data Original data frame
#' @return List of trend-specific data components
#' @noRd
extract_trend_data_components <- function(trend_stanvars, data) {
  checkmate::assert_list(trend_stanvars, names = "named")
  checkmate::assert_data_frame(data, min.rows = 1)
  
  trend_data <- list()
  
  # Extract common trend data components
  if (has_time_component(trend_stanvars)) {
    trend_data$time_data <- extract_time_data(data)
  }
  
  if (has_series_component(trend_stanvars)) {
    trend_data$series_data <- extract_series_data(data)
  }
  
  if (has_correlation_component(trend_stanvars)) {
    trend_data$correlation_data <- extract_correlation_data(data)
  }
  
  return(trend_data)
}

#' Check for Time Component in Stanvars
#'
#' @description
#' Checks if any stanvars require time-related data.
#'
#' @param trend_stanvars List of trend stanvars
#' @return Logical indicating if time data needed
#' @noRd
has_time_component <- function(trend_stanvars) {
  # Check stanvar names and scode for time-related requirements
  time_indicators <- c("time", "ytimes", "n_time", "time_dis")
  
  for (stanvar in trend_stanvars) {
    if (is_valid_stanvar(stanvar)) {
      if (any(sapply(time_indicators, function(x) grepl(x, stanvar$scode, fixed = TRUE)))) {
        return(TRUE)
      }
    }
  }
  
  return(FALSE)
}

#' Check for Series Component in Stanvars
#'
#' @description
#' Checks if any stanvars require series-related data.
#'
#' @param trend_stanvars List of trend stanvars
#' @return Logical indicating if series data needed
#' @noRd
has_series_component <- function(trend_stanvars) {
  # Check stanvar names and scode for series-related requirements
  series_indicators <- c("series", "n_series", "n_lv")
  
  for (stanvar in trend_stanvars) {
    if (is_valid_stanvar(stanvar)) {
      if (any(sapply(series_indicators, function(x) grepl(x, stanvar$scode, fixed = TRUE)))) {
        return(TRUE)
      }
    }
  }
  
  return(FALSE)
}

#' Check for Correlation Component in Stanvars
#'
#' @description
#' Checks if any stanvars require correlation-related data.
#'
#' @param trend_stanvars List of trend stanvars
#' @return Logical indicating if correlation data needed
#' @noRd
has_correlation_component <- function(trend_stanvars) {
  # Check stanvar names and scode for correlation-related requirements
  corr_indicators <- c("L_Omega", "Sigma", "correlation", "hierarchical")
  
  for (stanvar in trend_stanvars) {
    if (is_valid_stanvar(stanvar)) {
      if (any(sapply(corr_indicators, function(x) grepl(x, stanvar$scode, fixed = TRUE)))) {
        return(TRUE)
      }
    }
  }
  
  return(FALSE)
}

#' Extract Time Data Components
#'
#' @description
#' Extracts time-related data components from data frame.
#'
#' @param data Data frame
#' @return List of time data components
#' @noRd
extract_time_data <- function(data) {
  checkmate::assert_data_frame(data, min.rows = 1)
  
  time_data <- list()
  
  # Look for standard time variable
  if ("time" %in% names(data)) {
    time_data$time <- data$time
    time_data$n_time <- length(unique(data$time))
  }
  
  return(time_data)
}

#' Extract Series Data Components
#'
#' @description
#' Extracts series-related data components from data frame.
#'
#' @param data Data frame
#' @return List of series data components
#' @noRd
extract_series_data <- function(data) {
  checkmate::assert_data_frame(data, min.rows = 1)
  
  series_data <- list()
  
  # Look for standard series variable
  if ("series" %in% names(data)) {
    series_data$series <- data$series
    series_data$n_series <- length(unique(data$series))
  }
  
  return(series_data)
}

#' Extract Correlation Data Components
#'
#' @description
#' Extracts correlation-related data components from data frame.
#'
#' @param data Data frame
#' @return List of correlation data components
#' @noRd
extract_correlation_data <- function(data) {
  checkmate::assert_data_frame(data, min.rows = 1)
  
  corr_data <- list()
  
  # Add correlation-specific data requirements
  # TODO: Implement when correlation data patterns are identified
  
  return(corr_data)
}

#' Merge Stan Data Components
#'
#' @description
#' Merges brms standata with trend data components, checking for conflicts.
#'
#' @param base_standata Base Stan data from brms
#' @param trend_data Trend-specific data components
#' @return Merged Stan data list
#' @noRd
merge_stan_data <- function(base_standata, trend_data) {
  checkmate::assert_list(base_standata, names = "named")
  checkmate::assert_list(trend_data, names = "named")
  
  # Start with base data
  merged_data <- base_standata
  
  # Add trend data, checking for conflicts
  for (component_name in names(trend_data)) {
    component_data <- trend_data[[component_name]]
    
    for (var_name in names(component_data)) {
      if (var_name %in% names(merged_data)) {
        # Check for conflicts
        if (!identical(merged_data[[var_name]], component_data[[var_name]])) {
          rlang::warn(
            paste0("Data conflict for variable: ", var_name, ". Using trend data."),
            .frequency = "once",
            .frequency_id = paste0("data_conflict_", var_name)
          )
        }
      }
      merged_data[[var_name]] <- component_data[[var_name]]
    }
  }
  
  return(merged_data)
}

# Validation Functions
# ====================

#' Validate Stan Code Structure
#'
#' @description
#' Validates that Stan code has expected structure and required blocks.
#'
#' @param stan_code Character string with Stan code
#' @noRd
validate_stan_code_structure <- function(stan_code) {
  checkmate::assert_string(stan_code, min.chars = 1)
  
  # Check for required Stan blocks
  required_blocks <- c("data", "parameters", "model")
  
  for (block in required_blocks) {
    pattern <- paste0(block, "\\s*\\{")
    if (!grepl(pattern, stan_code)) {
      stop(insight::format_error(
        "Missing required Stan block: {.field {block}}",
        "Stan code must contain data, parameters, and model blocks"
      ))
    }
  }
  
  return(invisible(TRUE))
}

#' Validate Stan Syntax
#'
#' @description
#' Basic validation of Stan syntax to catch obvious errors.
#'
#' @param stan_code Character string with Stan code
#' @noRd
validate_stan_syntax <- function(stan_code) {
  checkmate::assert_string(stan_code, min.chars = 1)
  
  # Check for balanced braces
  if (!are_braces_balanced(stan_code)) {
    stop(insight::format_error(
      "Unbalanced braces in Stan code",
      "Check for missing opening or closing braces"
    ))
  }
  
  # Check for common syntax errors
  check_common_stan_errors(stan_code)
  
  return(invisible(TRUE))
}

#' Check for Balanced Braces
#'
#' @description
#' Checks if braces are properly balanced in Stan code.
#'
#' @param stan_code Character string with Stan code
#' @return Logical indicating if braces are balanced
#' @noRd
are_braces_balanced <- function(stan_code) {
  # Count opening and closing braces
  open_count <- lengths(regmatches(stan_code, gregexpr("\\{", stan_code)))
  close_count <- lengths(regmatches(stan_code, gregexpr("\\}", stan_code)))
  
  return(open_count == close_count)
}

#' Check for Common Stan Errors
#'
#' @description
#' Checks for common Stan syntax errors.
#'
#' @param stan_code Character string with Stan code
#' @noRd
check_common_stan_errors <- function(stan_code) {
  # Check for missing semicolons at end of lines (basic check)
  lines <- strsplit(stan_code, "\n")[[1]]
  
  # Look for lines that should end with semicolon but don't
  for (i in seq_along(lines)) {
    line <- trimws(lines[i])
    
    # Skip empty lines and comments
    if (nchar(line) == 0 || grepl("^//", line) || grepl("^/\\*", line)) {
      next
    }
    
    # Skip block declarations and braces
    if (grepl("\\{$", line) || grepl("^\\}$", line) || 
        grepl("^(data|parameters|transformed|model|generated)\\s*\\{", line)) {
      next
    }
    
    # Check if line should end with semicolon but doesn't
    if (!grepl(";$", line) && !grepl("\\{$", line) && !grepl("^\\}$", line)) {
      # This is a very basic check - in practice, Stan parsing is complex
      # For now, just issue a warning rather than error
      rlang::warn(
        paste0("Potential missing semicolon at line ", i, ": ", line),
        .frequency = "once",
        .frequency_id = paste0("missing_semicolon_", i)
      )
    }
  }
  
  return(invisible(TRUE))
}

#' Validate Stan Data Structure
#'
#' @description
#' Validates that Stan data has expected structure and required components.
#'
#' @param stan_data List with Stan data
#' @noRd
validate_stan_data_structure <- function(stan_data) {
  checkmate::assert_list(stan_data, names = "named")
  
  # Check for basic data components
  if (length(stan_data) == 0) {
    stop(insight::format_error(
      "Empty Stan data list",
      "Stan data must contain at least basic data components"
    ))
  }
  
  # Check that all data components are valid types
  for (name in names(stan_data)) {
    value <- stan_data[[name]]
    
    # Check for valid Stan data types
    if (!is.numeric(value) && !is.integer(value) && !is.matrix(value) && !is.array(value)) {
      rlang::warn(
        paste0("Unexpected data type for Stan variable: ", name, " (", class(value)[1], ")"),
        .frequency = "once",
        .frequency_id = paste0("unexpected_data_type_", name)
      )
    }
  }
  
  return(invisible(TRUE))
}

#' Test Stan Code Compilation
#'
#' @description
#' Attempts to compile Stan code to validate syntax and structure.
#' Used for testing purposes.
#'
#' @param stan_code Character string with Stan code
#' @param test_mode Logical, if TRUE uses minimal compilation test
#' @return Logical indicating successful compilation
#' @noRd
test_stan_compilation <- function(stan_code, test_mode = TRUE) {
  checkmate::assert_string(stan_code, min.chars = 1)
  checkmate::assert_logical(test_mode, len = 1)
  
  if (!requireNamespace("rstan", quietly = TRUE)) {
    rlang::warn(
      "rstan not available for compilation testing",
      .frequency = "once",
      .frequency_id = "rstan_unavailable"
    )
    return(TRUE)  # Skip test if rstan not available
  }
  
  if (test_mode) {
    # Basic syntax check only - don't actually compile full model
    tryCatch({
      # This is a placeholder for actual compilation testing
      # In practice, we might use rstan::stan_model() with a timeout
      validate_stan_syntax(stan_code)
      return(TRUE)
    }, error = function(e) {
      return(FALSE)
    })
  } else {
    # Full compilation test (expensive)
    tryCatch({
      model <- rstan::stan_model(model_code = stan_code, model_name = "test_model")
      return(TRUE)
    }, error = function(e) {
      return(FALSE)
    })
  }
}

#' Null Coalescing Operator
#' 
#' @param x First value to check
#' @param y Default value if x is NULL
#' @return x if not NULL, otherwise y
#' @noRd
`%||%` <- function(x, y) {
  if (is.null(x)) y else x
}