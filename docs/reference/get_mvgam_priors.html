<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="description" content="This function lists the parameters that can have their prior distributions
changed for a given mvgam model, as well listing their default distributions"><title>Extract information on default prior distributions for an mvgam model — get_mvgam_priors • mvgam</title><script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><link href="../deps/bootstrap-5.2.2/bootstrap.min.css" rel="stylesheet"><script src="../deps/bootstrap-5.2.2/bootstrap.bundle.min.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous"><!-- bootstrap-toc --><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@v1.0.1/dist/bootstrap-toc.min.js" integrity="sha256-4veVQbu7//Lk5TSmc7YV48MxtMy98e26cf5MrgZYnwo=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- search --><script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/6.4.6/fuse.js" integrity="sha512-zv6Ywkjyktsohkbp9bb45V6tEMoWhzFzXis+LrMehmJZZSys19Yxf1dopHx7WzIKxr5tK2dVcYmaCk2uqdjF4A==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/autocomplete.js/0.38.0/autocomplete.jquery.min.js" integrity="sha512-GU9ayf+66Xx2TmpxqJpliWbT5PiGYxpaG8rfnBEk1LL8l1KGkRShhngwdXK1UgqhAzWpZHSiYPc09/NwDQIGyg==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/mark.min.js" integrity="sha512-5CYOlHXGh6QpOFA/TeTylKLWfB3ftPsde7AnmhuitiTX4K5SqCLBeKro6sPS8ilsz1Q4NRx3v8Ko2IBiszzdww==" crossorigin="anonymous"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="Extract information on default prior distributions for an mvgam model — get_mvgam_priors"><meta property="og:description" content="This function lists the parameters that can have their prior distributions
changed for a given mvgam model, as well listing their default distributions"><!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]--></head><body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>
    

    <nav class="navbar fixed-top navbar-dark navbar-expand-lg bg-primary"><div class="container">
    
    <a class="navbar-brand me-2" href="../index.html">mvgam</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">1.0.8</small>

    
    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto"><li class="active nav-item">
  <a class="nav-link" href="../reference/index.html">Reference</a>
</li>
<li class="nav-item dropdown">
  <a href="#" class="nav-link dropdown-toggle" data-bs-toggle="dropdown" role="button" aria-expanded="false" aria-haspopup="true" id="dropdown-articles">Articles</a>
  <div class="dropdown-menu" aria-labelledby="dropdown-articles">
    <a class="dropdown-item" href="../articles/data_in_mvgam.html">Formatting data for use in mvgam</a>
    <a class="dropdown-item" href="../articles/forecast_evaluation.html">Forecasting and forecast evaluation in mvgam</a>
    <a class="dropdown-item" href="../articles/mvgam_overview.html">Overview of the mvgam package</a>
    <a class="dropdown-item" href="../articles/shared_states.html">Shared latent states in mvgam</a>
    <a class="dropdown-item" href="../articles/time_varying_effects.html">Time-varying effects in mvgam</a>
    <a class="dropdown-item" href="../articles/trend_formulas.html">State-Space models in mvgam</a>
  </div>
</li>
      </ul><form class="form-inline my-2 my-lg-0" role="search">
        <input type="search" class="form-control me-sm-2" aria-label="Toggle navigation" name="search-input" data-search-index="../search.json" id="search-input" placeholder="Search for" autocomplete="off"></form>

      <ul class="navbar-nav"><li class="nav-item">
  <a class="external-link nav-link" href="https://github.com/nicholasjclark/mvgam/" aria-label="github">
    <span class="fab fa fab fa-github fa-lg"></span>
     
  </a>
</li>
      </ul></div>

    
  </div>
</nav><div class="container template-reference-topic">
<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">
      <img src="" class="logo" alt=""><h1>Extract information on default prior distributions for an mvgam model</h1>
      <small class="dont-index">Source: <a href="https://github.com/nicholasjclark/mvgam/blob/HEAD/R/get_mvgam_priors.R" class="external-link"><code>R/get_mvgam_priors.R</code></a></small>
      <div class="d-none name"><code>get_mvgam_priors.Rd</code></div>
    </div>

    <div class="ref-description section level2">
    <p>This function lists the parameters that can have their prior distributions
changed for a given <code>mvgam</code> model, as well listing their default distributions</p>
    </div>

    <div class="section level2">
    <h2 id="ref-usage">Usage<a class="anchor" aria-label="anchor" href="#ref-usage"></a></h2>
    <div class="sourceCode"><pre class="sourceCode r"><code><span><span class="fu">get_mvgam_priors</span><span class="op">(</span></span>
<span>  <span class="va">formula</span>,</span>
<span>  <span class="va">trend_formula</span>,</span>
<span>  <span class="va">data</span>,</span>
<span>  <span class="va">data_train</span>,</span>
<span>  family <span class="op">=</span> <span class="st">"poisson"</span>,</span>
<span>  use_lv <span class="op">=</span> <span class="cn">FALSE</span>,</span>
<span>  <span class="va">n_lv</span>,</span>
<span>  use_stan <span class="op">=</span> <span class="cn">TRUE</span>,</span>
<span>  trend_model <span class="op">=</span> <span class="st">"None"</span>,</span>
<span>  <span class="va">trend_map</span>,</span>
<span>  drift <span class="op">=</span> <span class="cn">FALSE</span></span>
<span><span class="op">)</span></span></code></pre></div>
    </div>

    <div class="section level2">
    <h2 id="arguments">Arguments<a class="anchor" aria-label="anchor" href="#arguments"></a></h2>
    <dl><dt>formula</dt>
<dd><p>A <code>character</code> string specifying the GAM observation model formula. These are exactly like the formula
for a GLM except that smooth terms, <code>s()</code>, <code>te()</code>, <code>ti()</code>, <code>t2()</code>, as well as time-varying
<code><a href="dynamic.html">dynamic()</a></code> terms, can be added to the right hand side
to specify that the linear predictor depends on smooth functions of predictors
(or linear functionals of these). Details of the formula syntax used by <span class="pkg">mvgam</span>
can be found in <code><a href="mvgam_formulae.html">mvgam_formulae</a></code></p></dd>


<dt>trend_formula</dt>
<dd><p>An optional <code>character</code> string specifying the GAM process model formula. If
supplied, a linear predictor will be modelled for the latent trends to capture process model evolution
separately from the observation model. Should not have a response variable specified on the left-hand side
of the formula (i.e. a valid option would be <code>~ season + s(year)</code>). Also note that you should not use
the identifier <code>series</code> in this formula to specify effects that vary across time series. Instead you should use
<code>trend</code>. This will ensure that models in which a <code>trend_map</code> is supplied will still work consistently
(i.e. by allowing effects to vary across process models, even when some time series share the same underlying
process model). This feature is only currently available for <code><a href="RW.html">RW()</a></code>, <code><a href="RW.html">AR()</a></code> and <code><a href="RW.html">VAR()</a></code> trend models</p></dd>


<dt>data</dt>
<dd><p>A <code>dataframe</code> or <code>list</code> containing the model response variable and covariates
required by the GAM <code>formula</code>. Should include columns:
<code>series</code> (a <code>factor</code> index of the series IDs;the number of levels should be identical
to the number of unique series labels (i.e. <code>n_series = length(levels(data$series))</code>))
<code>time</code> (<code>numeric</code> or <code>integer</code> index of the time point for each observation).
Any other variables to be included in the linear predictor of <code>formula</code> must also be present</p></dd>


<dt>data_train</dt>
<dd><p>Deprecated. Still works in place of <code>data</code> but users are recommended to use
<code>data</code> instead for more seamless integration into <code>R</code> workflows</p></dd>


<dt>family</dt>
<dd><p><code>family</code> specifying the exponential observation family for the series. Currently supported
families are:</p><ul><li><p><code>nb()</code> for count data</p></li>
<li><p><code><a href="https://rdrr.io/r/stats/family.html" class="external-link">poisson()</a></code> for count data</p></li>
<li><p><code><a href="https://rdrr.io/r/stats/family.html" class="external-link">gaussian()</a></code> for real-valued data</p></li>
<li><p><code>betar()</code> for proportional data on <code>(0,1)</code></p></li>
<li><p><code>lognormal()</code> for non-negative real-valued data</p></li>
<li><p><code><a href="mvgam_families.html">student_t()</a></code> for real-valued data</p></li>
<li><p><code><a href="https://rdrr.io/r/stats/family.html" class="external-link">Gamma()</a></code> for non-negative real-valued data</p></li>
</ul><p>Note that only <code>nb()</code> and <code><a href="https://rdrr.io/r/stats/family.html" class="external-link">poisson()</a></code> are available if using <code>JAGS</code> as the backend.
Default is <code><a href="https://rdrr.io/r/stats/family.html" class="external-link">poisson()</a></code>.
See <code><a href="mvgam_families.html">mvgam_families</a></code> for more details</p></dd>


<dt>use_lv</dt>
<dd><p><code>logical</code>. If <code>TRUE</code>, use dynamic factors to estimate series'
latent trends in a reduced dimension format. Only available for
<code><a href="RW.html">RW()</a></code>, <code><a href="RW.html">AR()</a></code> and <code><a href="GP.html">GP()</a></code> trend models. Defaults to <code>FALSE</code></p></dd>


<dt>n_lv</dt>
<dd><p><code>integer</code> the number of latent dynamic factors to use if <code>use_lv == TRUE</code>.
Cannot be <code>&gt; n_series</code>. Defaults arbitrarily to <code>min(2, floor(n_series / 2))</code></p></dd>


<dt>use_stan</dt>
<dd><p>Logical. If <code>TRUE</code>, the model will be compiled and sampled using
Hamiltonian Monte Carlo with a call to <code><a href="https://mc-stan.org/cmdstanr/reference/cmdstan_model.html" class="external-link">cmdstan_model</a></code> or
a call to <code><a href="https://mc-stan.org/rstan/reference/stan.html" class="external-link">stan</a></code>. Note that
there are many more options when using <code>Stan</code> vs <code>JAGS</code></p></dd>


<dt>trend_model</dt>
<dd><p><code>character</code> or  <code>function</code> specifying the time series dynamics for the latent trend. Options are:</p><ul><li><p><code>None</code> (no latent trend component; i.e. the GAM component is all that contributes to the linear predictor,
and the observation process is the only source of error; similarly to what is estimated by <code><a href="https://rdrr.io/pkg/mgcv/man/gam.html" class="external-link">gam</a></code>)</p></li>
<li><p><code>'RW'</code> or <code><a href="RW.html">RW()</a></code></p></li>
<li><p><code>'AR1'</code> or <code>AR(p = 1)</code></p></li>
<li><p><code>'AR2'</code> or <code>AR(p = 2)</code></p></li>
<li><p><code>'AR3'</code> or <code>AR(p = 3)</code></p></li>
<li><p><code>'VAR1'</code>  or <code><a href="RW.html">VAR()</a></code>(only available in <code>Stan</code>)</p></li>
<li><p><code>'PWlogistic</code>, <code>'PWlinear'</code> or <code><a href="piecewise_trends.html">PW()</a></code> (only available in <code>Stan</code>)</p></li>
<li><p><code>'GP'</code> or <code><a href="GP.html">GP()</a></code> (Gaussian Process with squared exponential kernel;
only available in <code>Stan</code>)</p></li>
</ul><p>For all trend types apart from <code><a href="GP.html">GP()</a></code> and <code><a href="piecewise_trends.html">PW()</a></code>, moving average and/or correlated
process error terms can also be estimated (for example, <code>RW(cor = TRUE)</code> will set up a
multivariate Random Walk if <code>n_series &gt; 1</code>). See <a href="mvgam_trends.html">mvgam_trends</a> for more details</p></dd>


<dt>trend_map</dt>
<dd><p>Optional <code>data.frame</code> specifying which series should depend on which latent
trends. Useful for allowing multiple series to depend on the same latent trend process, but with
different observation processes. If supplied, a latent factor model is set up by setting
<code>use_lv = TRUE</code> and using the mapping to set up the shared trends. Needs to have column names
<code>series</code> and <code>trend</code>, with integer values in the <code>trend</code> column to state which trend each series
should depend on. The <code>series</code> column should have a single unique entry for each series in the
data (names should perfectly match factor levels of the <code>series</code> variable in <code>data</code>). See examples
for details</p></dd>


<dt>drift</dt>
<dd><p><code>logical</code> estimate a drift parameter in the latent trend components. Useful if the latent
trend is expected to broadly follow a non-zero slope. Only available for
<code><a href="RW.html">RW()</a></code> and <code><a href="RW.html">AR()</a></code> trend models. Note that if the latent trend is more or less stationary,
the drift parameter can become unidentifiable, especially if an intercept term is included in the GAM linear
predictor (which it is by default when calling <code><a href="https://rdrr.io/pkg/mgcv/man/jagam.html" class="external-link">jagam</a></code>). Drift parameters will also likely
be unidentifiable if using dynamic factor models. Therefore this defaults to <code>FALSE</code></p></dd>

</dl></div>
    <div class="section level2">
    <h2 id="value">Value<a class="anchor" aria-label="anchor" href="#value"></a></h2>
    

<p>either a <code>data.frame</code> containing the prior definitions (if any suitable
priors can be altered by the user) or <code>NULL</code>, indicating that no priors in the model
can be modified through the <code>mvgam</code> interface</p>
    </div>
    <div class="section level2">
    <h2 id="details">Details<a class="anchor" aria-label="anchor" href="#details"></a></h2>
    <p>Users can supply a model formula, prior to fitting the model, so that default priors can be inspected and
altered. To make alterations, change the contents of the <code>prior</code> column and supplying this
<code>data.frame</code> to the <code>mvgam</code> function using the argument <code>priors</code>. If using <code>Stan</code> as the backend,
users can also modify the parameter bounds by modifying the <code>new_lowerbound</code> and/or <code>new_upperbound</code> columns.
This will be necessary if using restrictive distributions on some parameters, such as a Beta distribution
for the trend sd parameters for example (Beta only has support on  <code>(0,1)</code>), so the upperbound cannot
be above <code>1</code>. Another option is to make use of the prior modification functions in <code>brms</code>
(i.e. <code><a href="https://paul-buerkner.github.io/brms/reference/set_prior.html" class="external-link">prior</a></code>) to change prior distributions and bounds (just use the name of the parameter that
you'd like to change as the <code>class</code> argument; see examples below)</p>
    </div>
    <div class="section level2">
    <h2 id="note">Note<a class="anchor" aria-label="anchor" href="#note"></a></h2>
    <p>Only the <code>prior</code>, <code>new_lowerbound</code> and/or <code>new_upperbound</code> columns of the output
should be altered when defining the user-defined priors for the <code>mvgam</code> model. Use only if you are
familiar with the underlying probabilistic programming language. There are no sanity checks done to
ensure that the code is legal (i.e. to check that lower bounds are smaller than upper bounds, for
example)</p>
    </div>
    <div class="section level2">
    <h2 id="see-also">See also<a class="anchor" aria-label="anchor" href="#see-also"></a></h2>
    <div class="dont-index"><p><code><a href="mvgam.html">mvgam</a></code>, <code><a href="mvgam_formulae.html">mvgam_formulae</a></code>, <code><a href="https://paul-buerkner.github.io/brms/reference/set_prior.html" class="external-link">prior</a></code></p></div>
    </div>
    <div class="section level2">
    <h2 id="author">Author<a class="anchor" aria-label="anchor" href="#author"></a></h2>
    <p>Nicholas J Clark</p>
    </div>

    <div class="section level2">
    <h2 id="ref-examples">Examples<a class="anchor" aria-label="anchor" href="#ref-examples"></a></h2>
    <div class="sourceCode"><pre class="sourceCode r"><code><span class="r-in"><span><span class="co"># Simulate three integer-valued time series</span></span></span>
<span class="r-in"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://github.com/nicholasjclark/mvgam" class="external-link">mvgam</a></span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="va">dat</span> <span class="op">&lt;-</span> <span class="fu"><a href="sim_mvgam.html">sim_mvgam</a></span><span class="op">(</span>trend_rel <span class="op">=</span> <span class="fl">0.5</span><span class="op">)</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># Get a model file that uses default mvgam priors for inspection (not always necessary,</span></span></span>
<span class="r-in"><span><span class="co"># but this can be useful for testing whether your updated priors are written correctly)</span></span></span>
<span class="r-in"><span><span class="va">mod_default</span> <span class="op">&lt;-</span> <span class="fu"><a href="mvgam.html">mvgam</a></span><span class="op">(</span><span class="va">y</span> <span class="op">~</span> <span class="fu">s</span><span class="op">(</span><span class="va">series</span>, bs <span class="op">=</span> <span class="st">'re'</span><span class="op">)</span> <span class="op">+</span></span></span>
<span class="r-in"><span>              <span class="fu">s</span><span class="op">(</span><span class="va">season</span>, bs <span class="op">=</span> <span class="st">'cc'</span><span class="op">)</span> <span class="op">-</span> <span class="fl">1</span>,</span></span>
<span class="r-in"><span>              family <span class="op">=</span> <span class="st">'nb'</span>,</span></span>
<span class="r-in"><span>              data <span class="op">=</span> <span class="va">dat</span><span class="op">$</span><span class="va">data_train</span>,</span></span>
<span class="r-in"><span>              trend_model <span class="op">=</span> <span class="st">'AR2'</span>,</span></span>
<span class="r-in"><span>              run_model <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># Inspect the model file with default mvgam priors</span></span></span>
<span class="r-in"><span><span class="fu"><a href="code.html">code</a></span><span class="op">(</span><span class="va">mod_default</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // Stan model code generated by package mvgam</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> functions {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector rep_each(vector x, int K) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     int N = rows(x);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     vector[N * K] y;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     int pos = 1;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     for (n in 1 : N) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       for (k in 1 : K) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         y[pos] = x[n];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         pos += 1;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     return y;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> data {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=0&gt; total_obs; // total number of observations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=0&gt; n; // number of timepoints per series</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=0&gt; n_sp; // number of smoothing parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=0&gt; n_series; // number of series</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=0&gt; num_basis; // total number of basis coefficients</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[num_basis] zero; // prior locations for basis coefficients</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[total_obs, num_basis] X; // mgcv GAM design matrix</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   array[n, n_series] int&lt;lower=0&gt; ytimes; // time-ordered matrix (which col in X belongs to each [time, series] observation?)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[8, 8] S1; // mgcv smooth penalty matrix S1</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=0&gt; n_nonmissing; // number of nonmissing observations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   array[n_nonmissing] int&lt;lower=0&gt; flat_ys; // flattened nonmissing observations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[n_nonmissing, num_basis] flat_xs; // X values for nonmissing observations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   array[n_nonmissing] int&lt;lower=0&gt; obs_ind; // indices of nonmissing observations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> parameters {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // raw basis coefficients</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[num_basis] b_raw;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // random effect variances</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector&lt;lower=0&gt;[1] sigma_raw;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // random effect means</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[1] mu_raw;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // negative binomial overdispersion</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector&lt;lower=0&gt;[n_series] phi_inv;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // latent trend AR1 terms</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector&lt;lower=-1.5, upper=1.5&gt;[n_series] ar1;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // latent trend AR2 terms</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector&lt;lower=-1.5, upper=1.5&gt;[n_series] ar2;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // latent trend variance parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector&lt;lower=0&gt;[n_series] sigma;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // latent trends</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[n, n_series] trend;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // smoothing parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector&lt;lower=0&gt;[n_sp] lambda;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> transformed parameters {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // basis coefficients</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[num_basis] b;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   b[1 : 8] = b_raw[1 : 8];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   b[9 : 11] = mu_raw[1] + b_raw[9 : 11] * sigma_raw[1];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> model {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // prior for random effect population variances</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   sigma_raw ~ student_t(3, 0, 2.5);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // prior for random effect population means</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   mu_raw ~ std_normal();</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // prior for s(season)...</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   b_raw[1 : 8] ~ multi_normal_prec(zero[1 : 8], S1[1 : 8, 1 : 8] * lambda[1]);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // prior (non-centred) for s(series)...</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   b_raw[9 : 11] ~ std_normal();</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // priors for AR parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   ar1 ~ std_normal();</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   ar2 ~ std_normal();</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // priors for smoothing parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   lambda ~ normal(5, 30);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // priors for overdispersion parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   phi_inv ~ student_t(3, 0, 0.1);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // priors for latent trend variance parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   sigma ~ student_t(3, 0, 2.5);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // trend estimates</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   trend[1, 1 : n_series] ~ normal(0, sigma);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   trend[2, 1 : n_series] ~ normal(trend[1, 1 : n_series] * ar1, sigma);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   for (s in 1 : n_series) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     trend[3 : n, s] ~ normal(ar1[s] * trend[2 : (n - 1), s]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                              + ar2[s] * trend[1 : (n - 2), s], sigma[s]);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     // likelihood functions</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     vector[n_nonmissing] flat_trends;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     array[n_nonmissing] real flat_phis;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     flat_trends = to_vector(trend)[obs_ind];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     flat_phis = to_array_1d(rep_each(phi_inv, n)[obs_ind]);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     flat_ys ~ neg_binomial_2(exp(append_col(flat_xs, flat_trends)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                                  * append_row(b, 1.0)),</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                              inv(flat_phis));</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> generated quantities {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[total_obs] eta;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[n, n_series] mus;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[n_sp] rho;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[n_series] tau;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   array[n, n_series] int ypred;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[n, n_series] phi_vec;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[n_series] phi;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   phi = inv(phi_inv);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   for (s in 1 : n_series) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     phi_vec[1 : n, s] = rep_vector(phi[s], n);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   rho = log(lambda);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   for (s in 1 : n_series) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     tau[s] = pow(sigma[s], -2.0);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // posterior predictions</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   eta = X * b;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   for (s in 1 : n_series) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     mus[1 : n, s] = eta[ytimes[1 : n, s]] + trend[1 : n, s];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     ypred[1 : n, s] = neg_binomial_2_rng(exp(mus[1 : n, s]), phi_vec[1 : n, s]);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># Look at which priors can be updated in mvgam</span></span></span>
<span class="r-in"><span><span class="va">test_priors</span> <span class="op">&lt;-</span> <span class="fu">get_mvgam_priors</span><span class="op">(</span><span class="va">y</span> <span class="op">~</span> <span class="fu">s</span><span class="op">(</span><span class="va">series</span>, bs <span class="op">=</span> <span class="st">'re'</span><span class="op">)</span> <span class="op">+</span></span></span>
<span class="r-in"><span>                              <span class="fu">s</span><span class="op">(</span><span class="va">season</span>, bs <span class="op">=</span> <span class="st">'cc'</span><span class="op">)</span> <span class="op">-</span> <span class="fl">1</span>,</span></span>
<span class="r-in"><span>                              family <span class="op">=</span> <span class="st">'nb'</span>,</span></span>
<span class="r-in"><span>                              data <span class="op">=</span> <span class="va">dat</span><span class="op">$</span><span class="va">data_train</span>,</span></span>
<span class="r-in"><span>                              trend_model <span class="op">=</span> <span class="st">'AR2'</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="va">test_priors</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                                    param_name param_length</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 1               vector&lt;lower=0&gt;[n_sp] lambda;            2</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 2                           vector[1] mu_raw;            1</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 3               vector&lt;lower=0&gt;[1] sigma_raw;            1</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 4 vector&lt;lower=-1.5,upper=1.5&gt;[n_series] ar1;            3</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 5 vector&lt;lower=-1.5,upper=1.5&gt;[n_series] ar2;            3</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 6            vector&lt;lower=0&gt;[n_series] sigma;            3</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 7          vector&lt;lower=0&gt;[n_series] phi_inv;            3</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                    param_info                             prior</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 1 s(season) smooth parameters           lambda ~ normal(5, 30);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 2          s(series) pop mean            mu_raw ~ std_normal();</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 3            s(series) pop sd sigma_raw ~ student_t(3, 0, 2.5);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 4       trend AR1 coefficient               ar1 ~ std_normal();</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 5       trend AR2 coefficient               ar2 ~ std_normal();</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 6                    trend sd     sigma ~ student_t(3, 0, 2.5);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 7   inverse of NB dispsersion   phi_inv ~ student_t(3, 0, 0.1);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                   example_change new_lowerbound new_upperbound</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 1    lambda ~ exponential(0.95);             NA             NA</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 2   mu_raw ~ normal(-0.7, 0.74);             NA             NA</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 3 sigma_raw ~ exponential(0.58);             NA             NA</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 4       ar1 ~ normal(0.57, 0.7);             NA             NA</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 5      ar2 ~ normal(0.73, 0.91);             NA             NA</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 6     sigma ~ exponential(0.67);             NA             NA</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 7  phi_inv ~ normal(0.04, 0.12);             NA             NA</span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># Make a few changes; first, change the population mean for the series-level</span></span></span>
<span class="r-in"><span><span class="co"># random intercepts</span></span></span>
<span class="r-in"><span><span class="va">test_priors</span><span class="op">$</span><span class="va">prior</span><span class="op">[</span><span class="fl">2</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="st">'mu_raw ~ normal(0.2, 0.5);'</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># Now use stronger regularisation for the series-level AR2 coefficients</span></span></span>
<span class="r-in"><span><span class="va">test_priors</span><span class="op">$</span><span class="va">prior</span><span class="op">[</span><span class="fl">5</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="st">'ar2 ~ normal(0, 0.25);'</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># Check that the changes are made to the model file without any warnings by</span></span></span>
<span class="r-in"><span><span class="co"># setting 'run_model = FALSE'</span></span></span>
<span class="r-in"><span><span class="va">mod</span> <span class="op">&lt;-</span> <span class="fu"><a href="mvgam.html">mvgam</a></span><span class="op">(</span><span class="va">y</span> <span class="op">~</span> <span class="fu">s</span><span class="op">(</span><span class="va">series</span>, bs <span class="op">=</span> <span class="st">'re'</span><span class="op">)</span> <span class="op">+</span></span></span>
<span class="r-in"><span>            <span class="fu">s</span><span class="op">(</span><span class="va">season</span>, bs <span class="op">=</span> <span class="st">'cc'</span><span class="op">)</span> <span class="op">-</span> <span class="fl">1</span>,</span></span>
<span class="r-in"><span>            family <span class="op">=</span> <span class="st">'nb'</span>,</span></span>
<span class="r-in"><span>            data <span class="op">=</span> <span class="va">dat</span><span class="op">$</span><span class="va">data_train</span>,</span></span>
<span class="r-in"><span>            trend_model <span class="op">=</span> <span class="st">'AR2'</span>,</span></span>
<span class="r-in"><span>            priors <span class="op">=</span> <span class="va">test_priors</span>,</span></span>
<span class="r-in"><span>            run_model <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span></span></span>
<span class="r-in"><span>            <span class="fu"><a href="code.html">code</a></span><span class="op">(</span><span class="va">mod</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // Stan model code generated by package mvgam</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> functions {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector rep_each(vector x, int K) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     int N = rows(x);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     vector[N * K] y;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     int pos = 1;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     for (n in 1 : N) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       for (k in 1 : K) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         y[pos] = x[n];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         pos += 1;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     return y;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> data {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=0&gt; total_obs; // total number of observations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=0&gt; n; // number of timepoints per series</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=0&gt; n_sp; // number of smoothing parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=0&gt; n_series; // number of series</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=0&gt; num_basis; // total number of basis coefficients</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[num_basis] zero; // prior locations for basis coefficients</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[total_obs, num_basis] X; // mgcv GAM design matrix</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   array[n, n_series] int&lt;lower=0&gt; ytimes; // time-ordered matrix (which col in X belongs to each [time, series] observation?)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[8, 8] S1; // mgcv smooth penalty matrix S1</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=0&gt; n_nonmissing; // number of nonmissing observations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   array[n_nonmissing] int&lt;lower=0&gt; flat_ys; // flattened nonmissing observations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[n_nonmissing, num_basis] flat_xs; // X values for nonmissing observations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   array[n_nonmissing] int&lt;lower=0&gt; obs_ind; // indices of nonmissing observations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> parameters {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // raw basis coefficients</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[num_basis] b_raw;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // random effect variances</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector&lt;lower=0&gt;[1] sigma_raw;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // random effect means</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[1] mu_raw;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // negative binomial overdispersion</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector&lt;lower=0&gt;[n_series] phi_inv;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // latent trend AR1 terms</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector&lt;lower=-1.5, upper=1.5&gt;[n_series] ar1;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // latent trend AR2 terms</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector&lt;lower=-1.5, upper=1.5&gt;[n_series] ar2;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // latent trend variance parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector&lt;lower=0&gt;[n_series] sigma;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // latent trends</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[n, n_series] trend;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // smoothing parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector&lt;lower=0&gt;[n_sp] lambda;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> transformed parameters {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // basis coefficients</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[num_basis] b;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   b[1 : 8] = b_raw[1 : 8];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   b[9 : 11] = mu_raw[1] + b_raw[9 : 11] * sigma_raw[1];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> model {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // prior for random effect population variances</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   sigma_raw ~ student_t(3, 0, 2.5);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // prior for random effect population means</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   mu_raw ~ normal(0.2, 0.5);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // prior for s(season)...</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   b_raw[1 : 8] ~ multi_normal_prec(zero[1 : 8], S1[1 : 8, 1 : 8] * lambda[1]);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // prior (non-centred) for s(series)...</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   b_raw[9 : 11] ~ std_normal();</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // priors for AR parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   ar1 ~ std_normal();</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   ar2 ~ normal(0, 0.25);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // priors for smoothing parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   lambda ~ normal(5, 30);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // priors for overdispersion parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   phi_inv ~ student_t(3, 0, 0.1);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // priors for latent trend variance parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   sigma ~ student_t(3, 0, 2.5);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // trend estimates</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   trend[1, 1 : n_series] ~ normal(0, sigma);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   trend[2, 1 : n_series] ~ normal(trend[1, 1 : n_series] * ar1, sigma);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   for (s in 1 : n_series) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     trend[3 : n, s] ~ normal(ar1[s] * trend[2 : (n - 1), s]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                              + ar2[s] * trend[1 : (n - 2), s], sigma[s]);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     // likelihood functions</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     vector[n_nonmissing] flat_trends;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     array[n_nonmissing] real flat_phis;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     flat_trends = to_vector(trend)[obs_ind];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     flat_phis = to_array_1d(rep_each(phi_inv, n)[obs_ind]);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     flat_ys ~ neg_binomial_2(exp(append_col(flat_xs, flat_trends)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                                  * append_row(b, 1.0)),</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                              inv(flat_phis));</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> generated quantities {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[total_obs] eta;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[n, n_series] mus;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[n_sp] rho;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[n_series] tau;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   array[n, n_series] int ypred;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[n, n_series] phi_vec;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[n_series] phi;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   phi = inv(phi_inv);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   for (s in 1 : n_series) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     phi_vec[1 : n, s] = rep_vector(phi[s], n);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   rho = log(lambda);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   for (s in 1 : n_series) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     tau[s] = pow(sigma[s], -2.0);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // posterior predictions</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   eta = X * b;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   for (s in 1 : n_series) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     mus[1 : n, s] = eta[ytimes[1 : n, s]] + trend[1 : n, s];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     ypred[1 : n, s] = neg_binomial_2_rng(exp(mus[1 : n, s]), phi_vec[1 : n, s]);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># No warnings, the model is ready for fitting now in the usual way with the addition</span></span></span>
<span class="r-in"><span><span class="co"># of the 'priors' argument</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># The same can be done using brms functions; here we will also change the ar1 prior</span></span></span>
<span class="r-in"><span><span class="co"># and put some bounds on the ar coefficients to enforce stationarity; we set the</span></span></span>
<span class="r-in"><span><span class="co"># prior using the 'class' argument in all brms prior functions</span></span></span>
<span class="r-in"><span><span class="va">brmsprior</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fu">prior</span><span class="op">(</span><span class="fu">normal</span><span class="op">(</span><span class="fl">0.2</span>, <span class="fl">0.5</span><span class="op">)</span>, class <span class="op">=</span> <span class="va">mu_raw</span><span class="op">)</span>,</span></span>
<span class="r-in"><span>              <span class="fu">prior</span><span class="op">(</span><span class="fu">normal</span><span class="op">(</span><span class="fl">0</span>, <span class="fl">0.25</span><span class="op">)</span>, class <span class="op">=</span> <span class="va">ar1</span>, lb <span class="op">=</span> <span class="op">-</span><span class="fl">1</span>, ub <span class="op">=</span> <span class="fl">1</span><span class="op">)</span>,</span></span>
<span class="r-in"><span>              <span class="fu">prior</span><span class="op">(</span><span class="fu">normal</span><span class="op">(</span><span class="fl">0</span>, <span class="fl">0.25</span><span class="op">)</span>, class <span class="op">=</span> <span class="va">ar2</span>, lb <span class="op">=</span> <span class="op">-</span><span class="fl">1</span>, ub <span class="op">=</span> <span class="fl">1</span><span class="op">)</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="va">brmsprior</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             prior  class coef group resp dpar nlpar   lb   ub source</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  normal(0.2, 0.5) mu_raw                            &lt;NA&gt; &lt;NA&gt;   user</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   normal(0, 0.25)    ar1                              -1    1   user</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   normal(0, 0.25)    ar2                              -1    1   user</span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="va">mod</span> <span class="op">&lt;-</span> <span class="fu"><a href="mvgam.html">mvgam</a></span><span class="op">(</span><span class="va">y</span> <span class="op">~</span> <span class="fu">s</span><span class="op">(</span><span class="va">series</span>, bs <span class="op">=</span> <span class="st">'re'</span><span class="op">)</span> <span class="op">+</span></span></span>
<span class="r-in"><span>            <span class="fu">s</span><span class="op">(</span><span class="va">season</span>, bs <span class="op">=</span> <span class="st">'cc'</span><span class="op">)</span> <span class="op">-</span> <span class="fl">1</span>,</span></span>
<span class="r-in"><span>          family <span class="op">=</span> <span class="st">'nb'</span>,</span></span>
<span class="r-in"><span>          data <span class="op">=</span> <span class="va">dat</span><span class="op">$</span><span class="va">data_train</span>,</span></span>
<span class="r-in"><span>          trend_model <span class="op">=</span> <span class="st">'AR2'</span>,</span></span>
<span class="r-in"><span>          priors <span class="op">=</span> <span class="va">brmsprior</span>,</span></span>
<span class="r-in"><span>          run_model <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="fu"><a href="code.html">code</a></span><span class="op">(</span><span class="va">mod</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // Stan model code generated by package mvgam</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> functions {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector rep_each(vector x, int K) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     int N = rows(x);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     vector[N * K] y;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     int pos = 1;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     for (n in 1 : N) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       for (k in 1 : K) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         y[pos] = x[n];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         pos += 1;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     return y;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> data {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=0&gt; total_obs; // total number of observations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=0&gt; n; // number of timepoints per series</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=0&gt; n_sp; // number of smoothing parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=0&gt; n_series; // number of series</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=0&gt; num_basis; // total number of basis coefficients</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[num_basis] zero; // prior locations for basis coefficients</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[total_obs, num_basis] X; // mgcv GAM design matrix</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   array[n, n_series] int&lt;lower=0&gt; ytimes; // time-ordered matrix (which col in X belongs to each [time, series] observation?)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[8, 8] S1; // mgcv smooth penalty matrix S1</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=0&gt; n_nonmissing; // number of nonmissing observations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   array[n_nonmissing] int&lt;lower=0&gt; flat_ys; // flattened nonmissing observations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[n_nonmissing, num_basis] flat_xs; // X values for nonmissing observations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   array[n_nonmissing] int&lt;lower=0&gt; obs_ind; // indices of nonmissing observations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> parameters {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // raw basis coefficients</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[num_basis] b_raw;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // random effect variances</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector&lt;lower=0&gt;[1] sigma_raw;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // random effect means</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[1] mu_raw;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // negative binomial overdispersion</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector&lt;lower=0&gt;[n_series] phi_inv;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // latent trend AR1 terms</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector&lt;lower=-1, upper=1&gt;[n_series] ar1;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // latent trend AR2 terms</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector&lt;lower=-1, upper=1&gt;[n_series] ar2;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // latent trend variance parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector&lt;lower=0&gt;[n_series] sigma;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // latent trends</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[n, n_series] trend;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // smoothing parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector&lt;lower=0&gt;[n_sp] lambda;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> transformed parameters {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // basis coefficients</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[num_basis] b;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   b[1 : 8] = b_raw[1 : 8];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   b[9 : 11] = mu_raw[1] + b_raw[9 : 11] * sigma_raw[1];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> model {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // prior for random effect population variances</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   sigma_raw ~ student_t(3, 0, 2.5);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // prior for random effect population means</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   mu_raw ~ normal(0.2, 0.5);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // prior for s(season)...</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   b_raw[1 : 8] ~ multi_normal_prec(zero[1 : 8], S1[1 : 8, 1 : 8] * lambda[1]);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // prior (non-centred) for s(series)...</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   b_raw[9 : 11] ~ std_normal();</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // priors for AR parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   ar1 ~ normal(0, 0.25);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   ar2 ~ normal(0, 0.25);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // priors for smoothing parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   lambda ~ normal(5, 30);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // priors for overdispersion parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   phi_inv ~ student_t(3, 0, 0.1);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // priors for latent trend variance parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   sigma ~ student_t(3, 0, 2.5);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // trend estimates</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   trend[1, 1 : n_series] ~ normal(0, sigma);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   trend[2, 1 : n_series] ~ normal(trend[1, 1 : n_series] * ar1, sigma);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   for (s in 1 : n_series) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     trend[3 : n, s] ~ normal(ar1[s] * trend[2 : (n - 1), s]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                              + ar2[s] * trend[1 : (n - 2), s], sigma[s]);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     // likelihood functions</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     vector[n_nonmissing] flat_trends;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     array[n_nonmissing] real flat_phis;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     flat_trends = to_vector(trend)[obs_ind];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     flat_phis = to_array_1d(rep_each(phi_inv, n)[obs_ind]);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     flat_ys ~ neg_binomial_2(exp(append_col(flat_xs, flat_trends)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                                  * append_row(b, 1.0)),</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                              inv(flat_phis));</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> generated quantities {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[total_obs] eta;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[n, n_series] mus;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[n_sp] rho;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[n_series] tau;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   array[n, n_series] int ypred;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[n, n_series] phi_vec;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[n_series] phi;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   phi = inv(phi_inv);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   for (s in 1 : n_series) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     phi_vec[1 : n, s] = rep_vector(phi[s], n);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   rho = log(lambda);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   for (s in 1 : n_series) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     tau[s] = pow(sigma[s], -2.0);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // posterior predictions</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   eta = X * b;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   for (s in 1 : n_series) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     mus[1 : n, s] = eta[ytimes[1 : n, s]] + trend[1 : n, s];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     ypred[1 : n, s] = neg_binomial_2_rng(exp(mus[1 : n, s]), phi_vec[1 : n, s]);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># Look at what is returned when an incorrect spelling is used</span></span></span>
<span class="r-in"><span><span class="va">test_priors</span><span class="op">$</span><span class="va">prior</span><span class="op">[</span><span class="fl">5</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="st">'ar2_bananas ~ normal(0, 0.25);'</span></span></span>
<span class="r-in"><span><span class="va">mod</span> <span class="op">&lt;-</span> <span class="fu"><a href="mvgam.html">mvgam</a></span><span class="op">(</span><span class="va">y</span> <span class="op">~</span> <span class="fu">s</span><span class="op">(</span><span class="va">series</span>, bs <span class="op">=</span> <span class="st">'re'</span><span class="op">)</span> <span class="op">+</span></span></span>
<span class="r-in"><span>            <span class="fu">s</span><span class="op">(</span><span class="va">season</span>, bs <span class="op">=</span> <span class="st">'cc'</span><span class="op">)</span> <span class="op">-</span> <span class="fl">1</span>,</span></span>
<span class="r-in"><span>            family <span class="op">=</span> <span class="st">'nb'</span>,</span></span>
<span class="r-in"><span>            data <span class="op">=</span> <span class="va">dat</span><span class="op">$</span><span class="va">data_train</span>,</span></span>
<span class="r-in"><span>            trend_model <span class="op">=</span> <span class="st">'AR2'</span>,</span></span>
<span class="r-in"><span>            priors <span class="op">=</span> <span class="va">test_priors</span>,</span></span>
<span class="r-in"><span>            run_model <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span></span></span>
<span class="r-wrn co"><span class="r-pr">#&gt;</span> <span class="warning">Warning: </span>no match found in model_file for parameter: ar2_bananas</span>
<span class="r-in"><span><span class="fu"><a href="code.html">code</a></span><span class="op">(</span><span class="va">mod</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // Stan model code generated by package mvgam</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> functions {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector rep_each(vector x, int K) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     int N = rows(x);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     vector[N * K] y;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     int pos = 1;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     for (n in 1 : N) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       for (k in 1 : K) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         y[pos] = x[n];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         pos += 1;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     return y;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> data {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=0&gt; total_obs; // total number of observations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=0&gt; n; // number of timepoints per series</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=0&gt; n_sp; // number of smoothing parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=0&gt; n_series; // number of series</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=0&gt; num_basis; // total number of basis coefficients</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[num_basis] zero; // prior locations for basis coefficients</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[total_obs, num_basis] X; // mgcv GAM design matrix</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   array[n, n_series] int&lt;lower=0&gt; ytimes; // time-ordered matrix (which col in X belongs to each [time, series] observation?)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[8, 8] S1; // mgcv smooth penalty matrix S1</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=0&gt; n_nonmissing; // number of nonmissing observations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   array[n_nonmissing] int&lt;lower=0&gt; flat_ys; // flattened nonmissing observations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[n_nonmissing, num_basis] flat_xs; // X values for nonmissing observations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   array[n_nonmissing] int&lt;lower=0&gt; obs_ind; // indices of nonmissing observations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> parameters {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // raw basis coefficients</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[num_basis] b_raw;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // random effect variances</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector&lt;lower=0&gt;[1] sigma_raw;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // random effect means</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[1] mu_raw;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // negative binomial overdispersion</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector&lt;lower=0&gt;[n_series] phi_inv;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // latent trend AR1 terms</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector&lt;lower=-1.5, upper=1.5&gt;[n_series] ar1;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // latent trend AR2 terms</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector&lt;lower=-1.5, upper=1.5&gt;[n_series] ar2;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // latent trend variance parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector&lt;lower=0&gt;[n_series] sigma;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // latent trends</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[n, n_series] trend;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // smoothing parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector&lt;lower=0&gt;[n_sp] lambda;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> transformed parameters {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // basis coefficients</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[num_basis] b;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   b[1 : 8] = b_raw[1 : 8];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   b[9 : 11] = mu_raw[1] + b_raw[9 : 11] * sigma_raw[1];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> model {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // prior for random effect population variances</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   sigma_raw ~ student_t(3, 0, 2.5);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // prior for random effect population means</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   mu_raw ~ normal(0.2, 0.5);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // prior for s(season)...</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   b_raw[1 : 8] ~ multi_normal_prec(zero[1 : 8], S1[1 : 8, 1 : 8] * lambda[1]);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // prior (non-centred) for s(series)...</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   b_raw[9 : 11] ~ std_normal();</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // priors for AR parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   ar1 ~ std_normal();</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   ar2 ~ std_normal();</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // priors for smoothing parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   lambda ~ normal(5, 30);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // priors for overdispersion parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   phi_inv ~ student_t(3, 0, 0.1);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // priors for latent trend variance parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   sigma ~ student_t(3, 0, 2.5);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // trend estimates</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   trend[1, 1 : n_series] ~ normal(0, sigma);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   trend[2, 1 : n_series] ~ normal(trend[1, 1 : n_series] * ar1, sigma);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   for (s in 1 : n_series) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     trend[3 : n, s] ~ normal(ar1[s] * trend[2 : (n - 1), s]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                              + ar2[s] * trend[1 : (n - 2), s], sigma[s]);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     // likelihood functions</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     vector[n_nonmissing] flat_trends;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     array[n_nonmissing] real flat_phis;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     flat_trends = to_vector(trend)[obs_ind];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     flat_phis = to_array_1d(rep_each(phi_inv, n)[obs_ind]);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     flat_ys ~ neg_binomial_2(exp(append_col(flat_xs, flat_trends)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                                  * append_row(b, 1.0)),</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                              inv(flat_phis));</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> generated quantities {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[total_obs] eta;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[n, n_series] mus;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[n_sp] rho;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[n_series] tau;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   array[n, n_series] int ypred;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[n, n_series] phi_vec;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[n_series] phi;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   phi = inv(phi_inv);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   for (s in 1 : n_series) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     phi_vec[1 : n, s] = rep_vector(phi[s], n);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   rho = log(lambda);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   for (s in 1 : n_series) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     tau[s] = pow(sigma[s], -2.0);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // posterior predictions</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   eta = X * b;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   for (s in 1 : n_series) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     mus[1 : n, s] = eta[ytimes[1 : n, s]] + trend[1 : n, s];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     ypred[1 : n, s] = neg_binomial_2_rng(exp(mus[1 : n, s]), phi_vec[1 : n, s]);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># Example of changing parametric (fixed effect) priors</span></span></span>
<span class="r-in"><span><span class="va">simdat</span> <span class="op">&lt;-</span> <span class="fu"><a href="sim_mvgam.html">sim_mvgam</a></span><span class="op">(</span><span class="op">)</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># Add a fake covariate</span></span></span>
<span class="r-in"><span><span class="va">simdat</span><span class="op">$</span><span class="va">data_train</span><span class="op">$</span><span class="va">cov</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/Normal.html" class="external-link">rnorm</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/nrow.html" class="external-link">NROW</a></span><span class="op">(</span><span class="va">simdat</span><span class="op">$</span><span class="va">data_train</span><span class="op">)</span><span class="op">)</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="va">priors</span> <span class="op">&lt;-</span> <span class="fu">get_mvgam_priors</span><span class="op">(</span><span class="va">y</span> <span class="op">~</span> <span class="va">cov</span> <span class="op">+</span> <span class="fu">s</span><span class="op">(</span><span class="va">season</span><span class="op">)</span>,</span></span>
<span class="r-in"><span>                          data <span class="op">=</span> <span class="va">simdat</span><span class="op">$</span><span class="va">data_train</span>,</span></span>
<span class="r-in"><span>                          family <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/family.html" class="external-link">poisson</a></span><span class="op">(</span><span class="op">)</span>,</span></span>
<span class="r-in"><span>                          trend_model <span class="op">=</span> <span class="st">'AR1'</span><span class="op">)</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># Change priors for the intercept and fake covariate effects</span></span></span>
<span class="r-in"><span><span class="va">priors</span><span class="op">$</span><span class="va">prior</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="st">'(Intercept) ~ normal(0, 1);'</span></span></span>
<span class="r-in"><span><span class="va">priors</span><span class="op">$</span><span class="va">prior</span><span class="op">[</span><span class="fl">2</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="st">'cov ~ normal(0, 0.1);'</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="va">mod2</span> <span class="op">&lt;-</span> <span class="fu"><a href="mvgam.html">mvgam</a></span><span class="op">(</span><span class="va">y</span> <span class="op">~</span> <span class="va">cov</span> <span class="op">+</span> <span class="fu">s</span><span class="op">(</span><span class="va">season</span><span class="op">)</span>,</span></span>
<span class="r-in"><span>             data <span class="op">=</span> <span class="va">simdat</span><span class="op">$</span><span class="va">data_train</span>,</span></span>
<span class="r-in"><span>             trend_model <span class="op">=</span> <span class="st">'AR1'</span>,</span></span>
<span class="r-in"><span>             family <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/family.html" class="external-link">poisson</a></span><span class="op">(</span><span class="op">)</span>,</span></span>
<span class="r-in"><span>             priors <span class="op">=</span> <span class="va">priors</span>,</span></span>
<span class="r-in"><span>             run_model <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="fu"><a href="code.html">code</a></span><span class="op">(</span><span class="va">mod2</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // Stan model code generated by package mvgam</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> data {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=0&gt; total_obs; // total number of observations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=0&gt; n; // number of timepoints per series</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=0&gt; n_sp; // number of smoothing parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=0&gt; n_series; // number of series</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=0&gt; num_basis; // total number of basis coefficients</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[num_basis] zero; // prior locations for basis coefficients</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[total_obs, num_basis] X; // mgcv GAM design matrix</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   array[n, n_series] int&lt;lower=0&gt; ytimes; // time-ordered matrix (which col in X belongs to each [time, series] observation?)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[9, 18] S1; // mgcv smooth penalty matrix S1</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=0&gt; n_nonmissing; // number of nonmissing observations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   array[n_nonmissing] int&lt;lower=0&gt; flat_ys; // flattened nonmissing observations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[n_nonmissing, num_basis] flat_xs; // X values for nonmissing observations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   array[n_nonmissing] int&lt;lower=0&gt; obs_ind; // indices of nonmissing observations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> parameters {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // raw basis coefficients</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[num_basis] b_raw;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // latent trend AR1 terms</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector&lt;lower=-1.5, upper=1.5&gt;[n_series] ar1;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // latent trend variance parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector&lt;lower=0&gt;[n_series] sigma;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // latent trends</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[n, n_series] trend;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // smoothing parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector&lt;lower=0&gt;[n_sp] lambda;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> transformed parameters {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // basis coefficients</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[num_basis] b;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   b[1 : num_basis] = b_raw[1 : num_basis];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> model {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // prior for (Intercept)...</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   b_raw[1] ~ normal(0, 1);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // prior for cov...</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   b_raw[2] ~ normal(0, 0.1);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // prior for s(season)...</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   b_raw[3 : 11] ~ multi_normal_prec(zero[3 : 11],</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                                     S1[1 : 9, 1 : 9] * lambda[1]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                                     + S1[1 : 9, 10 : 18] * lambda[2]);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // priors for AR parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   ar1 ~ std_normal();</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // priors for smoothing parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   lambda ~ normal(5, 30);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // priors for latent trend variance parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   sigma ~ student_t(3, 0, 2.5);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // trend estimates</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   trend[1, 1 : n_series] ~ normal(0, sigma);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   for (s in 1 : n_series) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     trend[2 : n, s] ~ normal(ar1[s] * trend[1 : (n - 1), s], sigma[s]);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     // likelihood functions</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     vector[n_nonmissing] flat_trends;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     flat_trends = to_vector(trend)[obs_ind];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     flat_ys ~ poisson_log_glm(append_col(flat_xs, flat_trends), 0.0,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                               append_row(b, 1.0));</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> generated quantities {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[total_obs] eta;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[n, n_series] mus;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[n_sp] rho;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[n_series] tau;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   array[n, n_series] int ypred;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   rho = log(lambda);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   for (s in 1 : n_series) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     tau[s] = pow(sigma[s], -2.0);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // posterior predictions</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   eta = X * b;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   for (s in 1 : n_series) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     mus[1 : n, s] = eta[ytimes[1 : n, s]] + trend[1 : n, s];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     ypred[1 : n, s] = poisson_log_rng(mus[1 : n, s]);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># Likewise using brms utilities (note that you can use</span></span></span>
<span class="r-in"><span><span class="co"># Intercept rather than `(Intercept)`) to change priors on the intercept</span></span></span>
<span class="r-in"><span><span class="va">brmsprior</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fu">prior</span><span class="op">(</span><span class="fu">normal</span><span class="op">(</span><span class="fl">0.2</span>, <span class="fl">0.5</span><span class="op">)</span>, class <span class="op">=</span> <span class="va">cov</span><span class="op">)</span>,</span></span>
<span class="r-in"><span>              <span class="fu">prior</span><span class="op">(</span><span class="fu">normal</span><span class="op">(</span><span class="fl">0</span>, <span class="fl">0.25</span><span class="op">)</span>, class <span class="op">=</span> <span class="va">Intercept</span><span class="op">)</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="va">brmsprior</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             prior     class coef group resp dpar nlpar   lb   ub source</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  normal(0.2, 0.5)       cov                            &lt;NA&gt; &lt;NA&gt;   user</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   normal(0, 0.25) Intercept                            &lt;NA&gt; &lt;NA&gt;   user</span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="va">mod2</span> <span class="op">&lt;-</span> <span class="fu"><a href="mvgam.html">mvgam</a></span><span class="op">(</span><span class="va">y</span> <span class="op">~</span> <span class="va">cov</span> <span class="op">+</span> <span class="fu">s</span><span class="op">(</span><span class="va">season</span><span class="op">)</span>,</span></span>
<span class="r-in"><span>             data <span class="op">=</span> <span class="va">simdat</span><span class="op">$</span><span class="va">data_train</span>,</span></span>
<span class="r-in"><span>             trend_model <span class="op">=</span> <span class="st">'AR1'</span>,</span></span>
<span class="r-in"><span>             family <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/family.html" class="external-link">poisson</a></span><span class="op">(</span><span class="op">)</span>,</span></span>
<span class="r-in"><span>             priors <span class="op">=</span> <span class="va">brmsprior</span>,</span></span>
<span class="r-in"><span>             run_model <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="fu"><a href="code.html">code</a></span><span class="op">(</span><span class="va">mod2</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // Stan model code generated by package mvgam</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> data {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=0&gt; total_obs; // total number of observations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=0&gt; n; // number of timepoints per series</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=0&gt; n_sp; // number of smoothing parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=0&gt; n_series; // number of series</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=0&gt; num_basis; // total number of basis coefficients</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[num_basis] zero; // prior locations for basis coefficients</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[total_obs, num_basis] X; // mgcv GAM design matrix</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   array[n, n_series] int&lt;lower=0&gt; ytimes; // time-ordered matrix (which col in X belongs to each [time, series] observation?)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[9, 18] S1; // mgcv smooth penalty matrix S1</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=0&gt; n_nonmissing; // number of nonmissing observations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   array[n_nonmissing] int&lt;lower=0&gt; flat_ys; // flattened nonmissing observations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[n_nonmissing, num_basis] flat_xs; // X values for nonmissing observations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   array[n_nonmissing] int&lt;lower=0&gt; obs_ind; // indices of nonmissing observations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> parameters {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // raw basis coefficients</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[num_basis] b_raw;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // latent trend AR1 terms</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector&lt;lower=-1.5, upper=1.5&gt;[n_series] ar1;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // latent trend variance parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector&lt;lower=0&gt;[n_series] sigma;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // latent trends</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[n, n_series] trend;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // smoothing parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector&lt;lower=0&gt;[n_sp] lambda;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> transformed parameters {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // basis coefficients</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[num_basis] b;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   b[1 : num_basis] = b_raw[1 : num_basis];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> model {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // prior for (Intercept)...</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   b_raw[1] ~ normal(0, 0.25);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // prior for cov...</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   b_raw[2] ~ normal(0.2, 0.5);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // prior for s(season)...</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   b_raw[3 : 11] ~ multi_normal_prec(zero[3 : 11],</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                                     S1[1 : 9, 1 : 9] * lambda[1]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                                     + S1[1 : 9, 10 : 18] * lambda[2]);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // priors for AR parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   ar1 ~ std_normal();</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // priors for smoothing parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   lambda ~ normal(5, 30);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // priors for latent trend variance parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   sigma ~ student_t(3, 0, 2.5);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // trend estimates</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   trend[1, 1 : n_series] ~ normal(0, sigma);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   for (s in 1 : n_series) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     trend[2 : n, s] ~ normal(ar1[s] * trend[1 : (n - 1), s], sigma[s]);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     // likelihood functions</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     vector[n_nonmissing] flat_trends;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     flat_trends = to_vector(trend)[obs_ind];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     flat_ys ~ poisson_log_glm(append_col(flat_xs, flat_trends), 0.0,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                               append_row(b, 1.0));</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> generated quantities {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[total_obs] eta;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[n, n_series] mus;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[n_sp] rho;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[n_series] tau;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   array[n, n_series] int ypred;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   rho = log(lambda);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   for (s in 1 : n_series) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     tau[s] = pow(sigma[s], -2.0);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // posterior predictions</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   eta = X * b;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   for (s in 1 : n_series) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     mus[1 : n, s] = eta[ytimes[1 : n, s]] + trend[1 : n, s];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     ypred[1 : n, s] = poisson_log_rng(mus[1 : n, s]);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># The "class = 'b'" shortcut can be used to put the same prior on all</span></span></span>
<span class="r-in"><span><span class="co"># 'fixed' effect coefficients (apart from any intercepts)</span></span></span>
<span class="r-in"><span><span class="fu"><a href="https://rdrr.io/r/base/Random.html" class="external-link">set.seed</a></span><span class="op">(</span><span class="fl">0</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="va">dat</span> <span class="op">&lt;-</span> <span class="fu">mgcv</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/pkg/mgcv/man/gamSim.html" class="external-link">gamSim</a></span><span class="op">(</span><span class="fl">1</span>, n <span class="op">=</span> <span class="fl">200</span>, scale <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Gu &amp; Wahba 4 term additive model</span>
<span class="r-in"><span><span class="va">dat</span><span class="op">$</span><span class="va">time</span> <span class="op">&lt;-</span> <span class="fl">1</span><span class="op">:</span><span class="fu"><a href="https://rdrr.io/r/base/nrow.html" class="external-link">NROW</a></span><span class="op">(</span><span class="va">dat</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="va">mod</span> <span class="op">&lt;-</span> <span class="fu"><a href="mvgam.html">mvgam</a></span><span class="op">(</span><span class="va">y</span> <span class="op">~</span> <span class="va">x0</span> <span class="op">+</span> <span class="va">x1</span> <span class="op">+</span> <span class="fu">s</span><span class="op">(</span><span class="va">x2</span><span class="op">)</span> <span class="op">+</span> <span class="fu">s</span><span class="op">(</span><span class="va">x3</span><span class="op">)</span>,</span></span>
<span class="r-in"><span>            priors <span class="op">=</span> <span class="fu">prior</span><span class="op">(</span><span class="fu">normal</span><span class="op">(</span><span class="fl">0</span>, <span class="fl">0.75</span><span class="op">)</span>, class <span class="op">=</span> <span class="st">'b'</span><span class="op">)</span>,</span></span>
<span class="r-in"><span>            data <span class="op">=</span> <span class="va">dat</span>,</span></span>
<span class="r-in"><span>            family <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/family.html" class="external-link">gaussian</a></span><span class="op">(</span><span class="op">)</span>,</span></span>
<span class="r-in"><span>            run_model <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="fu"><a href="code.html">code</a></span><span class="op">(</span><span class="va">mod</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // Stan model code generated by package mvgam</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> functions {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector rep_each(vector x, int K) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     int N = rows(x);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     vector[N * K] y;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     int pos = 1;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     for (n in 1 : N) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       for (k in 1 : K) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         y[pos] = x[n];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         pos += 1;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     return y;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> data {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=0&gt; total_obs; // total number of observations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=0&gt; n; // number of timepoints per series</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=0&gt; n_sp; // number of smoothing parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=0&gt; n_series; // number of series</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=0&gt; num_basis; // total number of basis coefficients</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[num_basis] zero; // prior locations for basis coefficients</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[total_obs, num_basis] X; // mgcv GAM design matrix</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   array[n, n_series] int&lt;lower=0&gt; ytimes; // time-ordered matrix (which col in X belongs to each [time, series] observation?)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[9, 18] S1; // mgcv smooth penalty matrix S1</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[9, 18] S2; // mgcv smooth penalty matrix S2</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=0&gt; n_nonmissing; // number of nonmissing observations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[n_nonmissing] flat_ys; // flattened nonmissing observations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[n_nonmissing, num_basis] flat_xs; // X values for nonmissing observations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   array[n_nonmissing] int&lt;lower=0&gt; obs_ind; // indices of nonmissing observations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> parameters {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // raw basis coefficients</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[num_basis] b_raw;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // gaussian observation error</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector&lt;lower=0&gt;[n_series] sigma_obs;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // smoothing parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector&lt;lower=0&gt;[n_sp] lambda;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> transformed parameters {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // basis coefficients</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[num_basis] b;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   b[1 : num_basis] = b_raw[1 : num_basis];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> model {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // prior for (Intercept)...</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   b_raw[1] ~ student_t(3, 7.4, 3.7);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // prior for x0...</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   b_raw[2] ~ normal(0, 0.75);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // prior for x1...</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   b_raw[3] ~ normal(0, 0.75);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // prior for s(x2)...</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   b_raw[4 : 12] ~ multi_normal_prec(zero[4 : 12],</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                                     S1[1 : 9, 1 : 9] * lambda[1]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                                     + S1[1 : 9, 10 : 18] * lambda[2]);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // prior for s(x3)...</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   b_raw[13 : 21] ~ multi_normal_prec(zero[13 : 21],</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                                      S2[1 : 9, 1 : 9] * lambda[3]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                                      + S2[1 : 9, 10 : 18] * lambda[4]);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // priors for smoothing parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   lambda ~ normal(5, 30);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // priors for observation error parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   sigma_obs ~ student_t(3, 0, 3.7);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     // likelihood functions</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     vector[n_nonmissing] flat_sigma_obs;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     flat_sigma_obs = rep_each(sigma_obs, n)[obs_ind];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     flat_ys ~ normal_id_glm(flat_xs, 0.0, b, flat_sigma_obs);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> generated quantities {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[total_obs] eta;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[n, n_series] sigma_obs_vec;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[n, n_series] mus;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[n_sp] rho;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   array[n, n_series] real ypred;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   rho = log(lambda);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // posterior predictions</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   eta = X * b;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   for (s in 1 : n_series) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     sigma_obs_vec[1 : n, s] = rep_vector(sigma_obs[s], n);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   for (s in 1 : n_series) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     mus[1 : n, s] = eta[ytimes[1 : n, s]];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     ypred[1 : n, s] = normal_rng(mus[1 : n, s], sigma_obs_vec[1 : n, s]);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-in"><span></span></span>
</code></pre></div>
    </div>
  </main><aside class="col-md-3"><nav id="toc"><h2>On this page</h2>
    </nav></aside></div>


    <footer><div class="pkgdown-footer-left">
  <p></p><p>Developed by <a href="https://researchers.uq.edu.au/researcher/15140" class="external-link">Nicholas J Clark</a>.</p>
</div>

<div class="pkgdown-footer-right">
  <p></p><p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.0.7.</p>
</div>

    </footer></div>

  

  

  </body></html>

