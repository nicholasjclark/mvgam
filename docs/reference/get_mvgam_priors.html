<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="description" content="This function lists the parameters that can have their prior distributions
changed for a given mvgam model, as well listing their default distributions"><title>Extract information on default prior distributions for an mvgam model — get_mvgam_priors • mvgam</title><script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet"><script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous"><!-- bootstrap-toc --><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@v1.0.1/dist/bootstrap-toc.min.js" integrity="sha256-4veVQbu7//Lk5TSmc7YV48MxtMy98e26cf5MrgZYnwo=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- search --><script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/6.4.6/fuse.js" integrity="sha512-zv6Ywkjyktsohkbp9bb45V6tEMoWhzFzXis+LrMehmJZZSys19Yxf1dopHx7WzIKxr5tK2dVcYmaCk2uqdjF4A==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/autocomplete.js/0.38.0/autocomplete.jquery.min.js" integrity="sha512-GU9ayf+66Xx2TmpxqJpliWbT5PiGYxpaG8rfnBEk1LL8l1KGkRShhngwdXK1UgqhAzWpZHSiYPc09/NwDQIGyg==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/mark.min.js" integrity="sha512-5CYOlHXGh6QpOFA/TeTylKLWfB3ftPsde7AnmhuitiTX4K5SqCLBeKro6sPS8ilsz1Q4NRx3v8Ko2IBiszzdww==" crossorigin="anonymous"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="Extract information on default prior distributions for an mvgam model — get_mvgam_priors"><meta property="og:description" content="This function lists the parameters that can have their prior distributions
changed for a given mvgam model, as well listing their default distributions"><meta property="og:image" content="https://nicholasjclark.github.io/mvgam/logo.png"><!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]--></head><body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>
    

    <nav class="navbar fixed-top navbar-dark navbar-expand-lg bg-primary"><div class="container">
    
    <a class="navbar-brand me-2" href="../index.html">mvgam</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">1.1.4</small>

    
    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto"><li class="active nav-item">
  <a class="nav-link" href="../reference/index.html">Reference</a>
</li>
<li class="nav-item dropdown">
  <a href="#" class="nav-link dropdown-toggle" data-bs-toggle="dropdown" role="button" aria-expanded="false" aria-haspopup="true" id="dropdown-articles">Articles</a>
  <div class="dropdown-menu" aria-labelledby="dropdown-articles">
    <a class="dropdown-item" href="../articles/data_in_mvgam.html">Formatting data for use in mvgam</a>
    <a class="dropdown-item" href="../articles/forecast_evaluation.html">Forecasting and forecast evaluation in mvgam</a>
    <a class="dropdown-item" href="../articles/mvgam_overview.html">Overview of the mvgam package</a>
    <a class="dropdown-item" href="../articles/nmixtures.html">N-mixtures in mvgam</a>
    <a class="dropdown-item" href="../articles/shared_states.html">Shared latent states in mvgam</a>
    <a class="dropdown-item" href="../articles/time_varying_effects.html">Time-varying effects in mvgam</a>
    <a class="dropdown-item" href="../articles/trend_formulas.html">State-Space models in mvgam</a>
  </div>
</li>
<li class="nav-item">
  <a class="nav-link" href="../news/index.html">Changelog</a>
</li>
      </ul><form class="form-inline my-2 my-lg-0" role="search">
        <input type="search" class="form-control me-sm-2" aria-label="Toggle navigation" name="search-input" data-search-index="../search.json" id="search-input" placeholder="Search for" autocomplete="off"></form>

      <ul class="navbar-nav"><li class="nav-item">
  <a class="external-link nav-link" href="https://github.com/nicholasjclark/mvgam/" aria-label="github">
    <span class="fab fa fab fa-github fa-lg"></span>
     
  </a>
</li>
      </ul></div>

    
  </div>
</nav><div class="container template-reference-topic">
<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">
      <img src="../logo.png" class="logo" alt=""><h1>Extract information on default prior distributions for an mvgam model</h1>
      <small class="dont-index">Source: <a href="https://github.com/nicholasjclark/mvgam/blob/HEAD/R/get_mvgam_priors.R" class="external-link"><code>R/get_mvgam_priors.R</code></a></small>
      <div class="d-none name"><code>get_mvgam_priors.Rd</code></div>
    </div>

    <div class="ref-description section level2">
    <p>This function lists the parameters that can have their prior distributions
changed for a given <code>mvgam</code> model, as well listing their default distributions</p>
    </div>

    <div class="section level2">
    <h2 id="ref-usage">Usage<a class="anchor" aria-label="anchor" href="#ref-usage"></a></h2>
    <div class="sourceCode"><pre class="sourceCode r"><code><span><span class="fu">get_mvgam_priors</span><span class="op">(</span></span>
<span>  <span class="va">formula</span>,</span>
<span>  <span class="va">trend_formula</span>,</span>
<span>  <span class="va">factor_formula</span>,</span>
<span>  <span class="va">data</span>,</span>
<span>  <span class="va">data_train</span>,</span>
<span>  family <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/family.html" class="external-link">poisson</a></span><span class="op">(</span><span class="op">)</span>,</span>
<span>  unit <span class="op">=</span> <span class="va">time</span>,</span>
<span>  species <span class="op">=</span> <span class="va">series</span>,</span>
<span>  <span class="va">knots</span>,</span>
<span>  <span class="va">trend_knots</span>,</span>
<span>  use_lv <span class="op">=</span> <span class="cn">FALSE</span>,</span>
<span>  <span class="va">n_lv</span>,</span>
<span>  use_stan <span class="op">=</span> <span class="cn">TRUE</span>,</span>
<span>  trend_model <span class="op">=</span> <span class="st">"None"</span>,</span>
<span>  <span class="va">trend_map</span>,</span>
<span>  drift <span class="op">=</span> <span class="cn">FALSE</span></span>
<span><span class="op">)</span></span></code></pre></div>
    </div>

    <div class="section level2">
    <h2 id="arguments">Arguments<a class="anchor" aria-label="anchor" href="#arguments"></a></h2>
    <dl><dt>formula</dt>
<dd><p>A <code>character</code> string specifying the GAM observation model formula. These are exactly like the formula
for a GLM except that smooth terms, <code><a href="https://rdrr.io/pkg/mgcv/man/s.html" class="external-link">s()</a></code>, <code><a href="https://rdrr.io/pkg/mgcv/man/te.html" class="external-link">te()</a></code>, <code><a href="https://rdrr.io/pkg/mgcv/man/te.html" class="external-link">ti()</a></code>, <code><a href="https://rdrr.io/pkg/mgcv/man/t2.html" class="external-link">t2()</a></code>, as well as time-varying
<code><a href="dynamic.html">dynamic()</a></code> terms and nonparametric <code><a href="https://paulbuerkner.com/brms/reference/gp.html" class="external-link">gp()</a></code> terms, can be added to the right hand side
to specify that the linear predictor depends on smooth functions of predictors
(or linear functionals of these). In <code><a href="mvgam_families.html">nmix()</a></code> family models, the <code>formula</code> is used to
set up a linear predictor for the detection probability. Details of the formula syntax used by <span class="pkg">mvgam</span>
can be found in <code><a href="mvgam_formulae.html">mvgam_formulae</a></code></p></dd>


<dt>trend_formula</dt>
<dd><p>An optional <code>character</code> string specifying the GAM process model formula. If
supplied, a linear predictor will be modelled for the latent trends to capture process model evolution
separately from the observation model. Should not have a response variable specified on the left-hand side
of the formula (i.e. a valid option would be <code>~ season + s(year)</code>). Also note that you should not use
the identifier <code>series</code> in this formula to specify effects that vary across time series. Instead you should use
<code>trend</code>. This will ensure that models in which a <code>trend_map</code> is supplied will still work consistently
(i.e. by allowing effects to vary across process models, even when some time series share the same underlying
process model). This feature is only currently available for <code><a href="RW.html">RW()</a></code>, <code><a href="RW.html">AR()</a></code> and <code><a href="RW.html">VAR()</a></code> trend models.
In <code><a href="mvgam_families.html">nmix()</a></code> family models, the <code>trend_formula</code> is used to set up a linear predictor for the underlying
latent abundance. Be aware that it can be very challenging to simultaneously estimate intercept parameters
for both the observation mode (captured by <code>formula</code>) and the process model (captured by <code>trend_formula</code>).
Users are recommended to drop one of these using the <code>- 1</code> convention in the formula right hand side.</p></dd>


<dt>factor_formula</dt>
<dd><p>Can be supplied instead <code>trend_formula</code> to match syntax from
<a href="jsdgam.html">jsdgam</a></p></dd>


<dt>data</dt>
<dd><p>A <code>dataframe</code> or <code>list</code> containing the model response variable and covariates
required by the GAM <code>formula</code> and optional <code>trend_formula</code>. Most models should include columns:</p><ul><li><p><code>series</code> (a <code>factor</code> index of the series IDs; the number of levels should be identical
to the number of unique series labels (i.e. <code>n_series = length(levels(data$series))</code>))</p></li>
<li><p><code>time</code> (<code>numeric</code> or <code>integer</code> index of the time point for each observation).
For most dynamic trend types available in <code>mvgam</code> (see argument <code>trend_model</code>), time should be
measured in discrete, regularly spaced intervals (i.e. <code>c(1, 2, 3, ...)</code>). However you can
use irregularly spaced intervals if using <code>trend_model = CAR(1)</code>, though note that any
temporal intervals that are exactly <code>0</code> will be adjusted to a very small number
(<code>1e-12</code>) to prevent sampling errors. See an example of <code><a href="RW.html">CAR()</a></code> trends in <code><a href="RW.html">CAR</a></code></p></li>
</ul><p>Note however that there are special cases where these identifiers are not needed. For
example, models with hierarchical temporal correlation processes (e.g. <code>AR(gr = region, subgr = species)</code>)
should NOT include a <code>series</code> identifier, as this will be constructed internally (see
<code><a href="mvgam_trends.html">mvgam_trends</a></code> and <code><a href="RW.html">AR</a></code> for details). <code>mvgam</code> can also fit models that do not
include a <code>time</code> variable if there are no temporal dynamic structures included (i.e. <code>trend_model = 'None'</code> or
<code>trend_model = ZMVN()</code>). <code>data</code> should also include any other variables to be included in
the linear predictor of <code>formula</code></p></dd>


<dt>data_train</dt>
<dd><p>Deprecated. Still works in place of <code>data</code> but users are recommended to use
<code>data</code> instead for more seamless integration into <code>R</code> workflows</p></dd>


<dt>family</dt>
<dd><p><code>family</code> specifying the exponential observation family for the series. Currently supported
families are:</p><ul><li><p><code><a href="https://rdrr.io/r/stats/family.html" class="external-link">gaussian()</a></code> for real-valued data</p></li>
<li><p><code><a href="mvgam_families.html">betar()</a></code> for proportional data on <code>(0,1)</code></p></li>
<li><p><code><a href="mvgam_families.html">lognormal()</a></code> for non-negative real-valued data</p></li>
<li><p><code><a href="mvgam_families.html">student_t()</a></code> for real-valued data</p></li>
<li><p><code><a href="https://rdrr.io/r/stats/family.html" class="external-link">Gamma()</a></code> for non-negative real-valued data</p></li>
<li><p><code><a href="mvgam_families.html">bernoulli()</a></code> for binary data</p></li>
<li><p><code><a href="https://rdrr.io/r/stats/family.html" class="external-link">poisson()</a></code> for count data</p></li>
<li><p><code><a href="mvgam_families.html">nb()</a></code> for overdispersed count data</p></li>
<li><p><code><a href="https://rdrr.io/r/stats/family.html" class="external-link">binomial()</a></code> for count data with imperfect detection when the number of trials is known;
note that the <code><a href="https://rdrr.io/r/base/cbind.html" class="external-link">cbind()</a></code> function must be used to bind the discrete observations and the discrete number
of trials</p></li>
<li><p><code><a href="mvgam_families.html">beta_binomial()</a></code> as for <code><a href="https://rdrr.io/r/stats/family.html" class="external-link">binomial()</a></code> but allows for overdispersion</p></li>
<li><p><code><a href="mvgam_families.html">nmix()</a></code> for count data with imperfect detection when the number of trials
is unknown and should be modeled via a State-Space N-Mixture model.
The latent states are Poisson, capturing the 'true' latent
abundance, while the observation process is Binomial to account for
imperfect detection.
See <code><a href="mvgam_families.html">mvgam_families</a></code> for an example of how to use this family</p></li>
</ul><p>Note that only <code><a href="mvgam_families.html">nb()</a></code> and <code><a href="https://rdrr.io/r/stats/family.html" class="external-link">poisson()</a></code> are available if using <code>JAGS</code> as the backend.
Default is <code><a href="https://rdrr.io/r/stats/family.html" class="external-link">poisson()</a></code>.
See <code><a href="mvgam_families.html">mvgam_families</a></code> for more details</p></dd>


<dt>unit</dt>
<dd><p>The unquoted name of the variable that represents the unit of analysis in <code>data</code> over
which latent residuals should be correlated. This variable should be either a
<code>numeric</code> or <code>integer</code> variable in the supplied <code>data</code>.
Defaults to <code>time</code> to be consistent with other functionalities
in <span class="pkg">mvgam</span>, though note that the data need not be time series in this case. See examples below
for further details and explanations</p></dd>


<dt>species</dt>
<dd><p>The unquoted name of the <code>factor</code> variable that indexes
the different response units in <code>data</code> (usually <code>'species'</code> in a JSDM).
Defaults to <code>series</code> to be consistent with other <code>mvgam</code> models</p></dd>


<dt>knots</dt>
<dd><p>An optional <code>list</code> containing user specified knot values to be used for basis construction.
For most bases the user simply supplies the knots to be used, which must match up with the <code>k</code> value supplied
(note that the number of knots is not always just <code>k</code>). Different terms can use different numbers of knots,
unless they share a covariate</p></dd>


<dt>trend_knots</dt>
<dd><p>As for <code>knots</code> above, this is an optional <code>list</code> of knot values for smooth
functions within the <code>trend_formula</code></p></dd>


<dt>use_lv</dt>
<dd><p><code>logical</code>. If <code>TRUE</code>, use dynamic factors to estimate series'
latent trends in a reduced dimension format. Only available for
<code><a href="RW.html">RW()</a></code>, <code><a href="RW.html">AR()</a></code> and <code><a href="GP.html">GP()</a></code> trend models. Defaults to <code>FALSE</code></p></dd>


<dt>n_lv</dt>
<dd><p><code>integer</code> the number of latent dynamic factors to use if <code>use_lv == TRUE</code>.
Cannot be <code>&gt; n_series</code>. Defaults arbitrarily to <code>min(2, floor(n_series / 2))</code></p></dd>


<dt>use_stan</dt>
<dd><p>Logical. If <code>TRUE</code>, the model will be compiled and sampled using
Hamiltonian Monte Carlo with a call to <code><a href="https://mc-stan.org/cmdstanr/reference/cmdstan_model.html" class="external-link">cmdstan_model</a></code> or
a call to <code><a href="https://mc-stan.org/rstan/reference/stan.html" class="external-link">stan</a></code>. Note that
there are many more options when using <code>Stan</code> vs <code>JAGS</code></p></dd>


<dt>trend_model</dt>
<dd><p><code>character</code> or  <code>function</code> specifying the time series dynamics for the latent trend. Options are:</p><ul><li><p><code>None</code> (no latent trend component; i.e. the GAM component is all that contributes to the linear predictor,
and the observation process is the only source of error; similarly to what is estimated by <code><a href="https://rdrr.io/pkg/mgcv/man/gam.html" class="external-link">gam</a></code>)</p></li>
<li><p><code>ZMVN</code> or <code><a href="ZMVN.html">ZMVN()</a></code> (Zero-Mean Multivariate Normal; only available in <code>Stan</code>)</p></li>
<li><p><code>'RW'</code> or <code><a href="RW.html">RW()</a></code></p></li>
<li><p><code>'AR1'</code> or <code>AR(p = 1)</code></p></li>
<li><p><code>'AR2'</code> or <code>AR(p = 2)</code></p></li>
<li><p><code>'AR3'</code> or <code>AR(p = 3)</code></p></li>
<li><p><code>'CAR1'</code> or <code>CAR(p = 1)</code></p></li>
<li><p><code>'VAR1'</code>  or <code><a href="RW.html">VAR()</a></code>(only available in <code>Stan</code>)</p></li>
<li><p><code>'PWlogistic</code>, <code>'PWlinear'</code> or <code><a href="piecewise_trends.html">PW()</a></code> (only available in <code>Stan</code>)</p></li>
<li><p><code>'GP'</code> or <code><a href="GP.html">GP()</a></code> (Gaussian Process with squared exponential kernel;
only available in <code>Stan</code>)</p></li>
</ul><p>For all trend types apart from <code><a href="ZMVN.html">ZMVN()</a></code>, <code><a href="GP.html">GP()</a></code>, <code><a href="RW.html">CAR()</a></code> and <code><a href="piecewise_trends.html">PW()</a></code>, moving average and/or correlated
process error terms can also be estimated (for example, <code>RW(cor = TRUE)</code> will set up a
multivariate Random Walk if <code>n_series &gt; 1</code>). It is also possible for many multivariate trends
to estimate hierarchical correlations if the data are structured among levels of
a relevant grouping factor. See <a href="mvgam_trends.html">mvgam_trends</a> for more details and see <a href="ZMVN.html">ZMVN</a> for an example.</p></dd>


<dt>trend_map</dt>
<dd><p>Optional <code>data.frame</code> specifying which series should depend on which latent
trends. Useful for allowing multiple series to depend on the same latent trend process, but with
different observation processes. If supplied, a latent factor model is set up by setting
<code>use_lv = TRUE</code> and using the mapping to set up the shared trends. Needs to have column names
<code>series</code> and <code>trend</code>, with integer values in the <code>trend</code> column to state which trend each series
should depend on. The <code>series</code> column should have a single unique entry for each series in the
data (names should perfectly match factor levels of the <code>series</code> variable in <code>data</code>). Note that
if this is supplied, the intercept parameter in the process model will NOT be automatically suppressed.
See examples for details</p></dd>


<dt>drift</dt>
<dd><p>Deprecated. If you wish to estimate drift parameters, include parametric fixed effects
of 'time' in your formulae instead.</p></dd>

</dl></div>
    <div class="section level2">
    <h2 id="value">Value<a class="anchor" aria-label="anchor" href="#value"></a></h2>
    

<p>either a <code>data.frame</code> containing the prior definitions (if any suitable
priors can be altered by the user) or <code>NULL</code>, indicating that no priors in the model
can be modified through the <code>mvgam</code> interface</p>
    </div>
    <div class="section level2">
    <h2 id="details">Details<a class="anchor" aria-label="anchor" href="#details"></a></h2>
    <p>Users can supply a model formula, prior to fitting the model, so that default priors can be inspected and
altered. To make alterations, change the contents of the <code>prior</code> column and supplying this
<code>data.frame</code> to the <code>mvgam</code> function using the argument <code>priors</code>. If using <code>Stan</code> as the backend,
users can also modify the parameter bounds by modifying the <code>new_lowerbound</code> and/or <code>new_upperbound</code> columns.
This will be necessary if using restrictive distributions on some parameters, such as a Beta distribution
for the trend sd parameters for example (Beta only has support on  <code>(0,1)</code>), so the upperbound cannot
be above <code>1</code>. Another option is to make use of the prior modification functions in <code>brms</code>
(i.e. <code><a href="https://paulbuerkner.com/brms/reference/set_prior.html" class="external-link">prior</a></code>) to change prior distributions and bounds (just use the name of the parameter that
you'd like to change as the <code>class</code> argument; see examples below)</p>
    </div>
    <div class="section level2">
    <h2 id="note">Note<a class="anchor" aria-label="anchor" href="#note"></a></h2>
    <p>Only the <code>prior</code>, <code>new_lowerbound</code> and/or <code>new_upperbound</code> columns of the output
should be altered when defining the user-defined priors for the <code>mvgam</code> model. Use only if you are
familiar with the underlying probabilistic programming language. There are no sanity checks done to
ensure that the code is legal (i.e. to check that lower bounds are smaller than upper bounds, for
example)</p>
    </div>
    <div class="section level2">
    <h2 id="see-also">See also<a class="anchor" aria-label="anchor" href="#see-also"></a></h2>
    <div class="dont-index"><p><code><a href="mvgam.html">mvgam</a></code>, <code><a href="mvgam_formulae.html">mvgam_formulae</a></code>, <code><a href="https://paulbuerkner.com/brms/reference/set_prior.html" class="external-link">prior</a></code></p></div>
    </div>
    <div class="section level2">
    <h2 id="author">Author<a class="anchor" aria-label="anchor" href="#author"></a></h2>
    <p>Nicholas J Clark</p>
    </div>

    <div class="section level2">
    <h2 id="ref-examples">Examples<a class="anchor" aria-label="anchor" href="#ref-examples"></a></h2>
    <div class="sourceCode"><pre class="sourceCode r"><code><span class="r-in"><span><span class="co"># \donttest{</span></span></span>
<span class="r-in"><span><span class="co"># Simulate three integer-valued time series</span></span></span>
<span class="r-in"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://github.com/nicholasjclark/mvgam" class="external-link">mvgam</a></span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="va">dat</span> <span class="op">&lt;-</span> <span class="fu"><a href="sim_mvgam.html">sim_mvgam</a></span><span class="op">(</span>trend_rel <span class="op">=</span> <span class="fl">0.5</span><span class="op">)</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># Get a model file that uses default mvgam priors for inspection (not always necessary,</span></span></span>
<span class="r-in"><span><span class="co"># but this can be useful for testing whether your updated priors are written correctly)</span></span></span>
<span class="r-in"><span><span class="va">mod_default</span> <span class="op">&lt;-</span> <span class="fu"><a href="mvgam.html">mvgam</a></span><span class="op">(</span><span class="va">y</span> <span class="op">~</span> <span class="fu"><a href="https://rdrr.io/pkg/mgcv/man/s.html" class="external-link">s</a></span><span class="op">(</span><span class="va">series</span>, bs <span class="op">=</span> <span class="st">'re'</span><span class="op">)</span> <span class="op">+</span></span></span>
<span class="r-in"><span>              <span class="fu"><a href="https://rdrr.io/pkg/mgcv/man/s.html" class="external-link">s</a></span><span class="op">(</span><span class="va">season</span>, bs <span class="op">=</span> <span class="st">'cc'</span><span class="op">)</span> <span class="op">-</span> <span class="fl">1</span>,</span></span>
<span class="r-in"><span>              family <span class="op">=</span> <span class="fu"><a href="mvgam_families.html">nb</a></span><span class="op">(</span><span class="op">)</span>,</span></span>
<span class="r-in"><span>              data <span class="op">=</span> <span class="va">dat</span><span class="op">$</span><span class="va">data_train</span>,</span></span>
<span class="r-in"><span>              trend_model <span class="op">=</span> <span class="fu"><a href="RW.html">AR</a></span><span class="op">(</span>p <span class="op">=</span> <span class="fl">2</span><span class="op">)</span>,</span></span>
<span class="r-in"><span>              run_model <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span></span></span>
<span class="r-msg co"><span class="r-pr">#&gt;</span> Your model may benefit from using "noncentred = TRUE"</span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># Inspect the model file with default mvgam priors</span></span></span>
<span class="r-in"><span><span class="fu"><a href="code.html">code</a></span><span class="op">(</span><span class="va">mod_default</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // Stan model code generated by package mvgam</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> functions {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector rep_each(vector x, int K) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     int N = rows(x);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     vector[N * K] y;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     int pos = 1;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     for (n in 1 : N) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       for (k in 1 : K) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         y[pos] = x[n];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         pos += 1;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     return y;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> data {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=0&gt; total_obs; // total number of observations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=0&gt; n; // number of timepoints per series</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=0&gt; n_sp; // number of smoothing parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=0&gt; n_series; // number of series</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=0&gt; num_basis; // total number of basis coefficients</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[num_basis] zero; // prior locations for basis coefficients</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[total_obs, num_basis] X; // mgcv GAM design matrix</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   array[n, n_series] int&lt;lower=0&gt; ytimes; // time-ordered matrix (which col in X belongs to each [time, series] observation?)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[8, 8] S1; // mgcv smooth penalty matrix S1</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=0&gt; n_nonmissing; // number of nonmissing observations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   array[n_nonmissing] int&lt;lower=0&gt; flat_ys; // flattened nonmissing observations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[n_nonmissing, num_basis] flat_xs; // X values for nonmissing observations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   array[n_nonmissing] int&lt;lower=0&gt; obs_ind; // indices of nonmissing observations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> parameters {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // raw basis coefficients</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[num_basis] b_raw;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // random effect variances</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector&lt;lower=0&gt;[1] sigma_raw;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // random effect means</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[1] mu_raw;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // negative binomial overdispersion</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector&lt;lower=0&gt;[n_series] phi_inv;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // latent trend AR1 terms</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector&lt;lower=-1, upper=1&gt;[n_series] ar1;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // latent trend AR2 terms</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector&lt;lower=-1, upper=1&gt;[n_series] ar2;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // latent trend variance parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector&lt;lower=0&gt;[n_series] sigma;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // latent trends</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[n, n_series] trend;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // smoothing parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector&lt;lower=0&gt;[n_sp] lambda;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> transformed parameters {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // basis coefficients</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[num_basis] b;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   b[1 : 8] = b_raw[1 : 8];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   b[9 : 11] = mu_raw[1] + b_raw[9 : 11] * sigma_raw[1];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> model {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // prior for random effect population variances</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   sigma_raw ~ student_t(3, 0, 2.5);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // prior for random effect population means</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   mu_raw ~ std_normal();</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // prior for s(season)...</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   b_raw[1 : 8] ~ multi_normal_prec(zero[1 : 8], S1[1 : 8, 1 : 8] * lambda[1]);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // prior (non-centred) for s(series)...</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   b_raw[9 : 11] ~ std_normal();</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // priors for AR parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   ar1 ~ std_normal();</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   ar2 ~ std_normal();</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // priors for smoothing parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   lambda ~ normal(5, 30);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // priors for overdispersion parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   phi_inv ~ student_t(3, 0, 0.1);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // priors for latent trend variance parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   sigma ~ student_t(3, 0, 2.5);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // trend estimates</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   trend[1, 1 : n_series] ~ normal(0, sigma);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   trend[2, 1 : n_series] ~ normal(trend[1, 1 : n_series] * ar1, sigma);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   for (s in 1 : n_series) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     trend[3 : n, s] ~ normal(ar1[s] * trend[2 : (n - 1), s]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                              + ar2[s] * trend[1 : (n - 2), s], sigma[s]);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     // likelihood functions</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     vector[n_nonmissing] flat_trends;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     array[n_nonmissing] real flat_phis;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     flat_trends = to_vector(trend)[obs_ind];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     flat_phis = to_array_1d(rep_each(phi_inv, n)[obs_ind]);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     flat_ys ~ neg_binomial_2(exp(append_col(flat_xs, flat_trends)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                                  * append_row(b, 1.0)),</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                              inv(flat_phis));</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> generated quantities {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[total_obs] eta;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[n, n_series] mus;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[n_sp] rho;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[n_series] tau;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   array[n, n_series] int ypred;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[n, n_series] phi_vec;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[n_series] phi;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   phi = inv(phi_inv);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   for (s in 1 : n_series) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     phi_vec[1 : n, s] = rep_vector(phi[s], n);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   rho = log(lambda);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   for (s in 1 : n_series) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     tau[s] = pow(sigma[s], -2.0);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // posterior predictions</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   eta = X * b;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   for (s in 1 : n_series) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     mus[1 : n, s] = eta[ytimes[1 : n, s]] + trend[1 : n, s];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     ypred[1 : n, s] = neg_binomial_2_rng(exp(mus[1 : n, s]), phi_vec[1 : n, s]);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># Look at which priors can be updated in mvgam</span></span></span>
<span class="r-in"><span><span class="va">test_priors</span> <span class="op">&lt;-</span> <span class="fu">get_mvgam_priors</span><span class="op">(</span><span class="va">y</span> <span class="op">~</span> <span class="fu"><a href="https://rdrr.io/pkg/mgcv/man/s.html" class="external-link">s</a></span><span class="op">(</span><span class="va">series</span>, bs <span class="op">=</span> <span class="st">'re'</span><span class="op">)</span> <span class="op">+</span></span></span>
<span class="r-in"><span>                              <span class="fu"><a href="https://rdrr.io/pkg/mgcv/man/s.html" class="external-link">s</a></span><span class="op">(</span><span class="va">season</span>, bs <span class="op">=</span> <span class="st">'cc'</span><span class="op">)</span> <span class="op">-</span> <span class="fl">1</span>,</span></span>
<span class="r-in"><span>                              family <span class="op">=</span> <span class="fu"><a href="mvgam_families.html">nb</a></span><span class="op">(</span><span class="op">)</span>,</span></span>
<span class="r-in"><span>                              data <span class="op">=</span> <span class="va">dat</span><span class="op">$</span><span class="va">data_train</span>,</span></span>
<span class="r-in"><span>                              trend_model <span class="op">=</span> <span class="fu"><a href="RW.html">AR</a></span><span class="op">(</span>p <span class="op">=</span> <span class="fl">2</span><span class="op">)</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="va">test_priors</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                                param_name param_length</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 1           vector&lt;lower=0&gt;[n_sp] lambda;            2</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 2                       vector[1] mu_raw;            1</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 3           vector&lt;lower=0&gt;[1] sigma_raw;            1</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 4 vector&lt;lower=-1,upper=1&gt;[n_series] ar1;            3</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 5 vector&lt;lower=-1,upper=1&gt;[n_series] ar2;            3</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 6        vector&lt;lower=0&gt;[n_series] sigma;            3</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 7      vector&lt;lower=0&gt;[n_series] phi_inv;            3</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                    param_info                             prior</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 1 s(season) smooth parameters           lambda ~ normal(5, 30);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 2          s(series) pop mean            mu_raw ~ std_normal();</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 3            s(series) pop sd sigma_raw ~ student_t(3, 0, 2.5);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 4       trend AR1 coefficient               ar1 ~ std_normal();</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 5       trend AR2 coefficient               ar2 ~ std_normal();</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 6                    trend sd     sigma ~ student_t(3, 0, 2.5);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 7   inverse of NB dispsersion   phi_inv ~ student_t(3, 0, 0.1);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                   example_change new_lowerbound new_upperbound</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 1    lambda ~ exponential(0.55);             NA             NA</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 2  mu_raw ~ normal(-0.64, 0.64);             NA             NA</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 3 sigma_raw ~ exponential(0.45);             NA             NA</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 4     ar1 ~ normal(-0.76, 0.29);             NA             NA</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 5      ar2 ~ normal(-0.19, 0.8);             NA             NA</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 6     sigma ~ exponential(0.93);             NA             NA</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 7  phi_inv ~ normal(0.89, 0.89);             NA             NA</span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># Make a few changes; first, change the population mean for the series-level</span></span></span>
<span class="r-in"><span><span class="co"># random intercepts</span></span></span>
<span class="r-in"><span><span class="va">test_priors</span><span class="op">$</span><span class="va">prior</span><span class="op">[</span><span class="fl">2</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="st">'mu_raw ~ normal(0.2, 0.5);'</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># Now use stronger regularisation for the series-level AR2 coefficients</span></span></span>
<span class="r-in"><span><span class="va">test_priors</span><span class="op">$</span><span class="va">prior</span><span class="op">[</span><span class="fl">5</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="st">'ar2 ~ normal(0, 0.25);'</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># Check that the changes are made to the model file without any warnings by</span></span></span>
<span class="r-in"><span><span class="co"># setting 'run_model = FALSE'</span></span></span>
<span class="r-in"><span><span class="va">mod</span> <span class="op">&lt;-</span> <span class="fu"><a href="mvgam.html">mvgam</a></span><span class="op">(</span><span class="va">y</span> <span class="op">~</span> <span class="fu"><a href="https://rdrr.io/pkg/mgcv/man/s.html" class="external-link">s</a></span><span class="op">(</span><span class="va">series</span>, bs <span class="op">=</span> <span class="st">'re'</span><span class="op">)</span> <span class="op">+</span></span></span>
<span class="r-in"><span>            <span class="fu"><a href="https://rdrr.io/pkg/mgcv/man/s.html" class="external-link">s</a></span><span class="op">(</span><span class="va">season</span>, bs <span class="op">=</span> <span class="st">'cc'</span><span class="op">)</span> <span class="op">-</span> <span class="fl">1</span>,</span></span>
<span class="r-in"><span>            family <span class="op">=</span> <span class="fu"><a href="mvgam_families.html">nb</a></span><span class="op">(</span><span class="op">)</span>,</span></span>
<span class="r-in"><span>            data <span class="op">=</span> <span class="va">dat</span><span class="op">$</span><span class="va">data_train</span>,</span></span>
<span class="r-in"><span>            trend_model <span class="op">=</span> <span class="fu"><a href="RW.html">AR</a></span><span class="op">(</span>p <span class="op">=</span> <span class="fl">2</span><span class="op">)</span>,</span></span>
<span class="r-in"><span>            priors <span class="op">=</span> <span class="va">test_priors</span>,</span></span>
<span class="r-in"><span>            run_model <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span></span></span>
<span class="r-msg co"><span class="r-pr">#&gt;</span> Your model may benefit from using "noncentred = TRUE"</span>
<span class="r-in"><span><span class="fu"><a href="code.html">code</a></span><span class="op">(</span><span class="va">mod</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // Stan model code generated by package mvgam</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> functions {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector rep_each(vector x, int K) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     int N = rows(x);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     vector[N * K] y;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     int pos = 1;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     for (n in 1 : N) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       for (k in 1 : K) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         y[pos] = x[n];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         pos += 1;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     return y;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> data {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=0&gt; total_obs; // total number of observations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=0&gt; n; // number of timepoints per series</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=0&gt; n_sp; // number of smoothing parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=0&gt; n_series; // number of series</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=0&gt; num_basis; // total number of basis coefficients</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[num_basis] zero; // prior locations for basis coefficients</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[total_obs, num_basis] X; // mgcv GAM design matrix</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   array[n, n_series] int&lt;lower=0&gt; ytimes; // time-ordered matrix (which col in X belongs to each [time, series] observation?)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[8, 8] S1; // mgcv smooth penalty matrix S1</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=0&gt; n_nonmissing; // number of nonmissing observations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   array[n_nonmissing] int&lt;lower=0&gt; flat_ys; // flattened nonmissing observations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[n_nonmissing, num_basis] flat_xs; // X values for nonmissing observations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   array[n_nonmissing] int&lt;lower=0&gt; obs_ind; // indices of nonmissing observations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> parameters {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // raw basis coefficients</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[num_basis] b_raw;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // random effect variances</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector&lt;lower=0&gt;[1] sigma_raw;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // random effect means</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[1] mu_raw;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // negative binomial overdispersion</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector&lt;lower=0&gt;[n_series] phi_inv;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // latent trend AR1 terms</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector&lt;lower=-1, upper=1&gt;[n_series] ar1;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // latent trend AR2 terms</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector&lt;lower=-1, upper=1&gt;[n_series] ar2;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // latent trend variance parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector&lt;lower=0&gt;[n_series] sigma;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // latent trends</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[n, n_series] trend;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // smoothing parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector&lt;lower=0&gt;[n_sp] lambda;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> transformed parameters {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // basis coefficients</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[num_basis] b;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   b[1 : 8] = b_raw[1 : 8];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   b[9 : 11] = mu_raw[1] + b_raw[9 : 11] * sigma_raw[1];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> model {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // prior for random effect population variances</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   sigma_raw ~ student_t(3, 0, 2.5);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // prior for random effect population means</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   mu_raw ~ normal(0.2, 0.5);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // prior for s(season)...</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   b_raw[1 : 8] ~ multi_normal_prec(zero[1 : 8], S1[1 : 8, 1 : 8] * lambda[1]);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // prior (non-centred) for s(series)...</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   b_raw[9 : 11] ~ std_normal();</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // priors for AR parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   ar1 ~ std_normal();</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   ar2 ~ normal(0, 0.25);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // priors for smoothing parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   lambda ~ normal(5, 30);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // priors for overdispersion parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   phi_inv ~ student_t(3, 0, 0.1);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // priors for latent trend variance parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   sigma ~ student_t(3, 0, 2.5);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // trend estimates</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   trend[1, 1 : n_series] ~ normal(0, sigma);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   trend[2, 1 : n_series] ~ normal(trend[1, 1 : n_series] * ar1, sigma);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   for (s in 1 : n_series) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     trend[3 : n, s] ~ normal(ar1[s] * trend[2 : (n - 1), s]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                              + ar2[s] * trend[1 : (n - 2), s], sigma[s]);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     // likelihood functions</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     vector[n_nonmissing] flat_trends;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     array[n_nonmissing] real flat_phis;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     flat_trends = to_vector(trend)[obs_ind];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     flat_phis = to_array_1d(rep_each(phi_inv, n)[obs_ind]);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     flat_ys ~ neg_binomial_2(exp(append_col(flat_xs, flat_trends)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                                  * append_row(b, 1.0)),</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                              inv(flat_phis));</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> generated quantities {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[total_obs] eta;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[n, n_series] mus;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[n_sp] rho;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[n_series] tau;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   array[n, n_series] int ypred;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[n, n_series] phi_vec;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[n_series] phi;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   phi = inv(phi_inv);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   for (s in 1 : n_series) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     phi_vec[1 : n, s] = rep_vector(phi[s], n);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   rho = log(lambda);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   for (s in 1 : n_series) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     tau[s] = pow(sigma[s], -2.0);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // posterior predictions</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   eta = X * b;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   for (s in 1 : n_series) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     mus[1 : n, s] = eta[ytimes[1 : n, s]] + trend[1 : n, s];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     ypred[1 : n, s] = neg_binomial_2_rng(exp(mus[1 : n, s]), phi_vec[1 : n, s]);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># No warnings, the model is ready for fitting now in the usual way with the addition</span></span></span>
<span class="r-in"><span><span class="co"># of the 'priors' argument</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># The same can be done using 'brms' functions; here we will also change the ar1 prior</span></span></span>
<span class="r-in"><span><span class="co"># and put some bounds on the ar coefficients to enforce stationarity; we set the</span></span></span>
<span class="r-in"><span><span class="co"># prior using the 'class' argument in all brms prior functions</span></span></span>
<span class="r-in"><span><span class="va">brmsprior</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fu"><a href="https://paulbuerkner.com/brms/reference/set_prior.html" class="external-link">prior</a></span><span class="op">(</span><span class="fu">normal</span><span class="op">(</span><span class="fl">0.2</span>, <span class="fl">0.5</span><span class="op">)</span>, class <span class="op">=</span> <span class="va">mu_raw</span><span class="op">)</span>,</span></span>
<span class="r-in"><span>              <span class="fu"><a href="https://paulbuerkner.com/brms/reference/set_prior.html" class="external-link">prior</a></span><span class="op">(</span><span class="fu">normal</span><span class="op">(</span><span class="fl">0</span>, <span class="fl">0.25</span><span class="op">)</span>, class <span class="op">=</span> <span class="va">ar1</span>, lb <span class="op">=</span> <span class="op">-</span><span class="fl">1</span>, ub <span class="op">=</span> <span class="fl">1</span><span class="op">)</span>,</span></span>
<span class="r-in"><span>              <span class="fu"><a href="https://paulbuerkner.com/brms/reference/set_prior.html" class="external-link">prior</a></span><span class="op">(</span><span class="fu">normal</span><span class="op">(</span><span class="fl">0</span>, <span class="fl">0.25</span><span class="op">)</span>, class <span class="op">=</span> <span class="va">ar2</span>, lb <span class="op">=</span> <span class="op">-</span><span class="fl">1</span>, ub <span class="op">=</span> <span class="fl">1</span><span class="op">)</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="va">brmsprior</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             prior  class coef group resp dpar nlpar   lb   ub source</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  normal(0.2, 0.5) mu_raw                            &lt;NA&gt; &lt;NA&gt;   user</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   normal(0, 0.25)    ar1                              -1    1   user</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   normal(0, 0.25)    ar2                              -1    1   user</span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="va">mod</span> <span class="op">&lt;-</span> <span class="fu"><a href="mvgam.html">mvgam</a></span><span class="op">(</span><span class="va">y</span> <span class="op">~</span> <span class="fu"><a href="https://rdrr.io/pkg/mgcv/man/s.html" class="external-link">s</a></span><span class="op">(</span><span class="va">series</span>, bs <span class="op">=</span> <span class="st">'re'</span><span class="op">)</span> <span class="op">+</span></span></span>
<span class="r-in"><span>            <span class="fu"><a href="https://rdrr.io/pkg/mgcv/man/s.html" class="external-link">s</a></span><span class="op">(</span><span class="va">season</span>, bs <span class="op">=</span> <span class="st">'cc'</span><span class="op">)</span> <span class="op">-</span> <span class="fl">1</span>,</span></span>
<span class="r-in"><span>          family <span class="op">=</span> <span class="fu"><a href="mvgam_families.html">nb</a></span><span class="op">(</span><span class="op">)</span>,</span></span>
<span class="r-in"><span>          data <span class="op">=</span> <span class="va">dat</span><span class="op">$</span><span class="va">data_train</span>,</span></span>
<span class="r-in"><span>          trend_model <span class="op">=</span> <span class="fu"><a href="RW.html">AR</a></span><span class="op">(</span>p <span class="op">=</span> <span class="fl">2</span><span class="op">)</span>,</span></span>
<span class="r-in"><span>          priors <span class="op">=</span> <span class="va">brmsprior</span>,</span></span>
<span class="r-in"><span>          run_model <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span></span></span>
<span class="r-msg co"><span class="r-pr">#&gt;</span> Your model may benefit from using "noncentred = TRUE"</span>
<span class="r-in"><span><span class="fu"><a href="code.html">code</a></span><span class="op">(</span><span class="va">mod</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // Stan model code generated by package mvgam</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> functions {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector rep_each(vector x, int K) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     int N = rows(x);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     vector[N * K] y;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     int pos = 1;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     for (n in 1 : N) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       for (k in 1 : K) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         y[pos] = x[n];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         pos += 1;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     return y;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> data {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=0&gt; total_obs; // total number of observations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=0&gt; n; // number of timepoints per series</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=0&gt; n_sp; // number of smoothing parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=0&gt; n_series; // number of series</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=0&gt; num_basis; // total number of basis coefficients</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[num_basis] zero; // prior locations for basis coefficients</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[total_obs, num_basis] X; // mgcv GAM design matrix</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   array[n, n_series] int&lt;lower=0&gt; ytimes; // time-ordered matrix (which col in X belongs to each [time, series] observation?)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[8, 8] S1; // mgcv smooth penalty matrix S1</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=0&gt; n_nonmissing; // number of nonmissing observations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   array[n_nonmissing] int&lt;lower=0&gt; flat_ys; // flattened nonmissing observations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[n_nonmissing, num_basis] flat_xs; // X values for nonmissing observations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   array[n_nonmissing] int&lt;lower=0&gt; obs_ind; // indices of nonmissing observations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> parameters {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // raw basis coefficients</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[num_basis] b_raw;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // random effect variances</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector&lt;lower=0&gt;[1] sigma_raw;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // random effect means</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[1] mu_raw;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // negative binomial overdispersion</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector&lt;lower=0&gt;[n_series] phi_inv;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // latent trend AR1 terms</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector&lt;lower=-1, upper=1&gt;[n_series] ar1;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // latent trend AR2 terms</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector&lt;lower=-1, upper=1&gt;[n_series] ar2;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // latent trend variance parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector&lt;lower=0&gt;[n_series] sigma;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // latent trends</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[n, n_series] trend;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // smoothing parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector&lt;lower=0&gt;[n_sp] lambda;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> transformed parameters {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // basis coefficients</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[num_basis] b;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   b[1 : 8] = b_raw[1 : 8];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   b[9 : 11] = mu_raw[1] + b_raw[9 : 11] * sigma_raw[1];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> model {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // prior for random effect population variances</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   sigma_raw ~ student_t(3, 0, 2.5);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // prior for random effect population means</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   mu_raw ~ normal(0.2, 0.5);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // prior for s(season)...</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   b_raw[1 : 8] ~ multi_normal_prec(zero[1 : 8], S1[1 : 8, 1 : 8] * lambda[1]);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // prior (non-centred) for s(series)...</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   b_raw[9 : 11] ~ std_normal();</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // priors for AR parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   ar1 ~ normal(0, 0.25);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   ar2 ~ normal(0, 0.25);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // priors for smoothing parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   lambda ~ normal(5, 30);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // priors for overdispersion parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   phi_inv ~ student_t(3, 0, 0.1);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // priors for latent trend variance parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   sigma ~ student_t(3, 0, 2.5);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // trend estimates</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   trend[1, 1 : n_series] ~ normal(0, sigma);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   trend[2, 1 : n_series] ~ normal(trend[1, 1 : n_series] * ar1, sigma);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   for (s in 1 : n_series) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     trend[3 : n, s] ~ normal(ar1[s] * trend[2 : (n - 1), s]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                              + ar2[s] * trend[1 : (n - 2), s], sigma[s]);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     // likelihood functions</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     vector[n_nonmissing] flat_trends;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     array[n_nonmissing] real flat_phis;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     flat_trends = to_vector(trend)[obs_ind];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     flat_phis = to_array_1d(rep_each(phi_inv, n)[obs_ind]);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     flat_ys ~ neg_binomial_2(exp(append_col(flat_xs, flat_trends)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                                  * append_row(b, 1.0)),</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                              inv(flat_phis));</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> generated quantities {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[total_obs] eta;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[n, n_series] mus;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[n_sp] rho;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[n_series] tau;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   array[n, n_series] int ypred;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[n, n_series] phi_vec;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[n_series] phi;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   phi = inv(phi_inv);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   for (s in 1 : n_series) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     phi_vec[1 : n, s] = rep_vector(phi[s], n);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   rho = log(lambda);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   for (s in 1 : n_series) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     tau[s] = pow(sigma[s], -2.0);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // posterior predictions</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   eta = X * b;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   for (s in 1 : n_series) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     mus[1 : n, s] = eta[ytimes[1 : n, s]] + trend[1 : n, s];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     ypred[1 : n, s] = neg_binomial_2_rng(exp(mus[1 : n, s]), phi_vec[1 : n, s]);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># Look at what is returned when an incorrect spelling is used</span></span></span>
<span class="r-in"><span><span class="va">test_priors</span><span class="op">$</span><span class="va">prior</span><span class="op">[</span><span class="fl">5</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="st">'ar2_bananas ~ normal(0, 0.25);'</span></span></span>
<span class="r-in"><span><span class="va">mod</span> <span class="op">&lt;-</span> <span class="fu"><a href="mvgam.html">mvgam</a></span><span class="op">(</span><span class="va">y</span> <span class="op">~</span> <span class="fu"><a href="https://rdrr.io/pkg/mgcv/man/s.html" class="external-link">s</a></span><span class="op">(</span><span class="va">series</span>, bs <span class="op">=</span> <span class="st">'re'</span><span class="op">)</span> <span class="op">+</span></span></span>
<span class="r-in"><span>            <span class="fu"><a href="https://rdrr.io/pkg/mgcv/man/s.html" class="external-link">s</a></span><span class="op">(</span><span class="va">season</span>, bs <span class="op">=</span> <span class="st">'cc'</span><span class="op">)</span> <span class="op">-</span> <span class="fl">1</span>,</span></span>
<span class="r-in"><span>            family <span class="op">=</span> <span class="fu"><a href="mvgam_families.html">nb</a></span><span class="op">(</span><span class="op">)</span>,</span></span>
<span class="r-in"><span>            data <span class="op">=</span> <span class="va">dat</span><span class="op">$</span><span class="va">data_train</span>,</span></span>
<span class="r-in"><span>            trend_model <span class="op">=</span> <span class="fu"><a href="RW.html">AR</a></span><span class="op">(</span>p <span class="op">=</span> <span class="fl">2</span><span class="op">)</span>,</span></span>
<span class="r-in"><span>            priors <span class="op">=</span> <span class="va">test_priors</span>,</span></span>
<span class="r-in"><span>            run_model <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span></span></span>
<span class="r-wrn co"><span class="r-pr">#&gt;</span> <span class="warning">Warning: </span>no match found in model_file for parameter: ar2_bananas</span>
<span class="r-msg co"><span class="r-pr">#&gt;</span> Your model may benefit from using "noncentred = TRUE"</span>
<span class="r-in"><span><span class="fu"><a href="code.html">code</a></span><span class="op">(</span><span class="va">mod</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // Stan model code generated by package mvgam</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> functions {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector rep_each(vector x, int K) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     int N = rows(x);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     vector[N * K] y;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     int pos = 1;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     for (n in 1 : N) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       for (k in 1 : K) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         y[pos] = x[n];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         pos += 1;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     return y;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> data {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=0&gt; total_obs; // total number of observations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=0&gt; n; // number of timepoints per series</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=0&gt; n_sp; // number of smoothing parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=0&gt; n_series; // number of series</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=0&gt; num_basis; // total number of basis coefficients</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[num_basis] zero; // prior locations for basis coefficients</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[total_obs, num_basis] X; // mgcv GAM design matrix</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   array[n, n_series] int&lt;lower=0&gt; ytimes; // time-ordered matrix (which col in X belongs to each [time, series] observation?)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[8, 8] S1; // mgcv smooth penalty matrix S1</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=0&gt; n_nonmissing; // number of nonmissing observations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   array[n_nonmissing] int&lt;lower=0&gt; flat_ys; // flattened nonmissing observations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[n_nonmissing, num_basis] flat_xs; // X values for nonmissing observations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   array[n_nonmissing] int&lt;lower=0&gt; obs_ind; // indices of nonmissing observations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> parameters {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // raw basis coefficients</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[num_basis] b_raw;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // random effect variances</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector&lt;lower=0&gt;[1] sigma_raw;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // random effect means</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[1] mu_raw;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // negative binomial overdispersion</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector&lt;lower=0&gt;[n_series] phi_inv;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // latent trend AR1 terms</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector&lt;lower=-1, upper=1&gt;[n_series] ar1;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // latent trend AR2 terms</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector&lt;lower=-1, upper=1&gt;[n_series] ar2;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // latent trend variance parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector&lt;lower=0&gt;[n_series] sigma;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // latent trends</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[n, n_series] trend;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // smoothing parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector&lt;lower=0&gt;[n_sp] lambda;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> transformed parameters {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // basis coefficients</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[num_basis] b;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   b[1 : 8] = b_raw[1 : 8];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   b[9 : 11] = mu_raw[1] + b_raw[9 : 11] * sigma_raw[1];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> model {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // prior for random effect population variances</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   sigma_raw ~ student_t(3, 0, 2.5);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // prior for random effect population means</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   mu_raw ~ normal(0.2, 0.5);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // prior for s(season)...</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   b_raw[1 : 8] ~ multi_normal_prec(zero[1 : 8], S1[1 : 8, 1 : 8] * lambda[1]);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // prior (non-centred) for s(series)...</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   b_raw[9 : 11] ~ std_normal();</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // priors for AR parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   ar1 ~ std_normal();</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   ar2 ~ std_normal();</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // priors for smoothing parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   lambda ~ normal(5, 30);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // priors for overdispersion parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   phi_inv ~ student_t(3, 0, 0.1);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // priors for latent trend variance parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   sigma ~ student_t(3, 0, 2.5);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // trend estimates</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   trend[1, 1 : n_series] ~ normal(0, sigma);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   trend[2, 1 : n_series] ~ normal(trend[1, 1 : n_series] * ar1, sigma);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   for (s in 1 : n_series) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     trend[3 : n, s] ~ normal(ar1[s] * trend[2 : (n - 1), s]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                              + ar2[s] * trend[1 : (n - 2), s], sigma[s]);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     // likelihood functions</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     vector[n_nonmissing] flat_trends;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     array[n_nonmissing] real flat_phis;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     flat_trends = to_vector(trend)[obs_ind];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     flat_phis = to_array_1d(rep_each(phi_inv, n)[obs_ind]);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     flat_ys ~ neg_binomial_2(exp(append_col(flat_xs, flat_trends)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                                  * append_row(b, 1.0)),</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                              inv(flat_phis));</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> generated quantities {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[total_obs] eta;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[n, n_series] mus;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[n_sp] rho;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[n_series] tau;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   array[n, n_series] int ypred;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[n, n_series] phi_vec;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[n_series] phi;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   phi = inv(phi_inv);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   for (s in 1 : n_series) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     phi_vec[1 : n, s] = rep_vector(phi[s], n);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   rho = log(lambda);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   for (s in 1 : n_series) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     tau[s] = pow(sigma[s], -2.0);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // posterior predictions</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   eta = X * b;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   for (s in 1 : n_series) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     mus[1 : n, s] = eta[ytimes[1 : n, s]] + trend[1 : n, s];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     ypred[1 : n, s] = neg_binomial_2_rng(exp(mus[1 : n, s]), phi_vec[1 : n, s]);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># Example of changing parametric (fixed effect) priors</span></span></span>
<span class="r-in"><span><span class="va">simdat</span> <span class="op">&lt;-</span> <span class="fu"><a href="sim_mvgam.html">sim_mvgam</a></span><span class="op">(</span><span class="op">)</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># Add a fake covariate</span></span></span>
<span class="r-in"><span><span class="va">simdat</span><span class="op">$</span><span class="va">data_train</span><span class="op">$</span><span class="va">cov</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/Normal.html" class="external-link">rnorm</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/nrow.html" class="external-link">NROW</a></span><span class="op">(</span><span class="va">simdat</span><span class="op">$</span><span class="va">data_train</span><span class="op">)</span><span class="op">)</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="va">priors</span> <span class="op">&lt;-</span> <span class="fu">get_mvgam_priors</span><span class="op">(</span><span class="va">y</span> <span class="op">~</span> <span class="va">cov</span> <span class="op">+</span> <span class="fu"><a href="https://rdrr.io/pkg/mgcv/man/s.html" class="external-link">s</a></span><span class="op">(</span><span class="va">season</span><span class="op">)</span>,</span></span>
<span class="r-in"><span>                          data <span class="op">=</span> <span class="va">simdat</span><span class="op">$</span><span class="va">data_train</span>,</span></span>
<span class="r-in"><span>                          family <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/family.html" class="external-link">poisson</a></span><span class="op">(</span><span class="op">)</span>,</span></span>
<span class="r-in"><span>                          trend_model <span class="op">=</span> <span class="fu"><a href="RW.html">AR</a></span><span class="op">(</span><span class="op">)</span><span class="op">)</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># Change priors for the intercept and fake covariate effects</span></span></span>
<span class="r-in"><span><span class="va">priors</span><span class="op">$</span><span class="va">prior</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="st">'(Intercept) ~ normal(0, 1);'</span></span></span>
<span class="r-in"><span><span class="va">priors</span><span class="op">$</span><span class="va">prior</span><span class="op">[</span><span class="fl">2</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="st">'cov ~ normal(0, 0.1);'</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="va">mod2</span> <span class="op">&lt;-</span> <span class="fu"><a href="mvgam.html">mvgam</a></span><span class="op">(</span><span class="va">y</span> <span class="op">~</span> <span class="va">cov</span> <span class="op">+</span> <span class="fu"><a href="https://rdrr.io/pkg/mgcv/man/s.html" class="external-link">s</a></span><span class="op">(</span><span class="va">season</span><span class="op">)</span>,</span></span>
<span class="r-in"><span>             data <span class="op">=</span> <span class="va">simdat</span><span class="op">$</span><span class="va">data_train</span>,</span></span>
<span class="r-in"><span>             trend_model <span class="op">=</span> <span class="fu"><a href="RW.html">AR</a></span><span class="op">(</span><span class="op">)</span>,</span></span>
<span class="r-in"><span>             family <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/family.html" class="external-link">poisson</a></span><span class="op">(</span><span class="op">)</span>,</span></span>
<span class="r-in"><span>             priors <span class="op">=</span> <span class="va">priors</span>,</span></span>
<span class="r-in"><span>             run_model <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span></span></span>
<span class="r-msg co"><span class="r-pr">#&gt;</span> Your model may benefit from using "noncentred = TRUE"</span>
<span class="r-in"><span><span class="fu"><a href="code.html">code</a></span><span class="op">(</span><span class="va">mod2</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // Stan model code generated by package mvgam</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> data {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=0&gt; total_obs; // total number of observations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=0&gt; n; // number of timepoints per series</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=0&gt; n_sp; // number of smoothing parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=0&gt; n_series; // number of series</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=0&gt; num_basis; // total number of basis coefficients</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[num_basis] zero; // prior locations for basis coefficients</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[total_obs, num_basis] X; // mgcv GAM design matrix</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   array[n, n_series] int&lt;lower=0&gt; ytimes; // time-ordered matrix (which col in X belongs to each [time, series] observation?)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[9, 18] S1; // mgcv smooth penalty matrix S1</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=0&gt; n_nonmissing; // number of nonmissing observations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   array[n_nonmissing] int&lt;lower=0&gt; flat_ys; // flattened nonmissing observations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[n_nonmissing, num_basis] flat_xs; // X values for nonmissing observations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   array[n_nonmissing] int&lt;lower=0&gt; obs_ind; // indices of nonmissing observations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> parameters {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // raw basis coefficients</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[num_basis] b_raw;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // latent trend AR1 terms</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector&lt;lower=-1, upper=1&gt;[n_series] ar1;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // latent trend variance parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector&lt;lower=0&gt;[n_series] sigma;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // latent trends</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[n, n_series] trend;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // smoothing parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector&lt;lower=0&gt;[n_sp] lambda;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> transformed parameters {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // basis coefficients</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[num_basis] b;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   b[1 : num_basis] = b_raw[1 : num_basis];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> model {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // prior for (Intercept)...</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   b_raw[1] ~ normal(0, 1);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // prior for cov...</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   b_raw[2] ~ normal(0, 0.1);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // prior for s(season)...</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   b_raw[3 : 11] ~ multi_normal_prec(zero[3 : 11],</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                                     S1[1 : 9, 1 : 9] * lambda[1]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                                     + S1[1 : 9, 10 : 18] * lambda[2]);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // priors for AR parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   ar1 ~ std_normal();</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // priors for smoothing parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   lambda ~ normal(5, 30);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // priors for latent trend variance parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   sigma ~ student_t(3, 0, 2.5);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // trend estimates</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   trend[1, 1 : n_series] ~ normal(0, sigma);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   for (s in 1 : n_series) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     trend[2 : n, s] ~ normal(ar1[s] * trend[1 : (n - 1), s], sigma[s]);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     // likelihood functions</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     vector[n_nonmissing] flat_trends;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     flat_trends = to_vector(trend)[obs_ind];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     flat_ys ~ poisson_log_glm(append_col(flat_xs, flat_trends), 0.0,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                               append_row(b, 1.0));</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> generated quantities {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[total_obs] eta;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[n, n_series] mus;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[n_sp] rho;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[n_series] tau;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   array[n, n_series] int ypred;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   rho = log(lambda);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   for (s in 1 : n_series) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     tau[s] = pow(sigma[s], -2.0);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // posterior predictions</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   eta = X * b;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   for (s in 1 : n_series) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     mus[1 : n, s] = eta[ytimes[1 : n, s]] + trend[1 : n, s];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     ypred[1 : n, s] = poisson_log_rng(mus[1 : n, s]);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># Likewise using 'brms' utilities (note that you can use</span></span></span>
<span class="r-in"><span><span class="co"># Intercept rather than `(Intercept)`) to change priors on the intercept</span></span></span>
<span class="r-in"><span><span class="va">brmsprior</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fu"><a href="https://paulbuerkner.com/brms/reference/set_prior.html" class="external-link">prior</a></span><span class="op">(</span><span class="fu">normal</span><span class="op">(</span><span class="fl">0.2</span>, <span class="fl">0.5</span><span class="op">)</span>, class <span class="op">=</span> <span class="va">cov</span><span class="op">)</span>,</span></span>
<span class="r-in"><span>              <span class="fu"><a href="https://paulbuerkner.com/brms/reference/set_prior.html" class="external-link">prior</a></span><span class="op">(</span><span class="fu">normal</span><span class="op">(</span><span class="fl">0</span>, <span class="fl">0.25</span><span class="op">)</span>, class <span class="op">=</span> <span class="va">Intercept</span><span class="op">)</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="va">brmsprior</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             prior     class coef group resp dpar nlpar   lb   ub source</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  normal(0.2, 0.5)       cov                            &lt;NA&gt; &lt;NA&gt;   user</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   normal(0, 0.25) Intercept                            &lt;NA&gt; &lt;NA&gt;   user</span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="va">mod2</span> <span class="op">&lt;-</span> <span class="fu"><a href="mvgam.html">mvgam</a></span><span class="op">(</span><span class="va">y</span> <span class="op">~</span> <span class="va">cov</span> <span class="op">+</span> <span class="fu"><a href="https://rdrr.io/pkg/mgcv/man/s.html" class="external-link">s</a></span><span class="op">(</span><span class="va">season</span><span class="op">)</span>,</span></span>
<span class="r-in"><span>             data <span class="op">=</span> <span class="va">simdat</span><span class="op">$</span><span class="va">data_train</span>,</span></span>
<span class="r-in"><span>             trend_model <span class="op">=</span> <span class="fu"><a href="RW.html">AR</a></span><span class="op">(</span><span class="op">)</span>,</span></span>
<span class="r-in"><span>             family <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/family.html" class="external-link">poisson</a></span><span class="op">(</span><span class="op">)</span>,</span></span>
<span class="r-in"><span>             priors <span class="op">=</span> <span class="va">brmsprior</span>,</span></span>
<span class="r-in"><span>             run_model <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span></span></span>
<span class="r-msg co"><span class="r-pr">#&gt;</span> Your model may benefit from using "noncentred = TRUE"</span>
<span class="r-in"><span><span class="fu"><a href="code.html">code</a></span><span class="op">(</span><span class="va">mod2</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // Stan model code generated by package mvgam</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> data {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=0&gt; total_obs; // total number of observations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=0&gt; n; // number of timepoints per series</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=0&gt; n_sp; // number of smoothing parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=0&gt; n_series; // number of series</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=0&gt; num_basis; // total number of basis coefficients</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[num_basis] zero; // prior locations for basis coefficients</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[total_obs, num_basis] X; // mgcv GAM design matrix</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   array[n, n_series] int&lt;lower=0&gt; ytimes; // time-ordered matrix (which col in X belongs to each [time, series] observation?)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[9, 18] S1; // mgcv smooth penalty matrix S1</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=0&gt; n_nonmissing; // number of nonmissing observations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   array[n_nonmissing] int&lt;lower=0&gt; flat_ys; // flattened nonmissing observations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[n_nonmissing, num_basis] flat_xs; // X values for nonmissing observations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   array[n_nonmissing] int&lt;lower=0&gt; obs_ind; // indices of nonmissing observations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> parameters {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // raw basis coefficients</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[num_basis] b_raw;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // latent trend AR1 terms</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector&lt;lower=-1, upper=1&gt;[n_series] ar1;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // latent trend variance parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector&lt;lower=0&gt;[n_series] sigma;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // latent trends</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[n, n_series] trend;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // smoothing parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector&lt;lower=0&gt;[n_sp] lambda;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> transformed parameters {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // basis coefficients</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[num_basis] b;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   b[1 : num_basis] = b_raw[1 : num_basis];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> model {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // prior for (Intercept)...</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   b_raw[1] ~ normal(0, 0.25);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // prior for cov...</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   b_raw[2] ~ normal(0.2, 0.5);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // prior for s(season)...</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   b_raw[3 : 11] ~ multi_normal_prec(zero[3 : 11],</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                                     S1[1 : 9, 1 : 9] * lambda[1]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                                     + S1[1 : 9, 10 : 18] * lambda[2]);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // priors for AR parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   ar1 ~ std_normal();</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // priors for smoothing parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   lambda ~ normal(5, 30);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // priors for latent trend variance parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   sigma ~ student_t(3, 0, 2.5);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // trend estimates</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   trend[1, 1 : n_series] ~ normal(0, sigma);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   for (s in 1 : n_series) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     trend[2 : n, s] ~ normal(ar1[s] * trend[1 : (n - 1), s], sigma[s]);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     // likelihood functions</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     vector[n_nonmissing] flat_trends;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     flat_trends = to_vector(trend)[obs_ind];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     flat_ys ~ poisson_log_glm(append_col(flat_xs, flat_trends), 0.0,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                               append_row(b, 1.0));</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> generated quantities {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[total_obs] eta;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[n, n_series] mus;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[n_sp] rho;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[n_series] tau;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   array[n, n_series] int ypred;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   rho = log(lambda);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   for (s in 1 : n_series) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     tau[s] = pow(sigma[s], -2.0);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // posterior predictions</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   eta = X * b;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   for (s in 1 : n_series) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     mus[1 : n, s] = eta[ytimes[1 : n, s]] + trend[1 : n, s];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     ypred[1 : n, s] = poisson_log_rng(mus[1 : n, s]);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># The "class = 'b'" shortcut can be used to put the same prior on all</span></span></span>
<span class="r-in"><span><span class="co"># 'fixed' effect coefficients (apart from any intercepts)</span></span></span>
<span class="r-in"><span><span class="fu"><a href="https://rdrr.io/r/base/Random.html" class="external-link">set.seed</a></span><span class="op">(</span><span class="fl">0</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="va">dat</span> <span class="op">&lt;-</span> <span class="fu">mgcv</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/pkg/mgcv/man/gamSim.html" class="external-link">gamSim</a></span><span class="op">(</span><span class="fl">1</span>, n <span class="op">=</span> <span class="fl">200</span>, scale <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Gu &amp; Wahba 4 term additive model</span>
<span class="r-in"><span><span class="va">dat</span><span class="op">$</span><span class="va">time</span> <span class="op">&lt;-</span> <span class="fl">1</span><span class="op">:</span><span class="fu"><a href="https://rdrr.io/r/base/nrow.html" class="external-link">NROW</a></span><span class="op">(</span><span class="va">dat</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="va">mod</span> <span class="op">&lt;-</span> <span class="fu"><a href="mvgam.html">mvgam</a></span><span class="op">(</span><span class="va">y</span> <span class="op">~</span> <span class="va">x0</span> <span class="op">+</span> <span class="va">x1</span> <span class="op">+</span> <span class="fu"><a href="https://rdrr.io/pkg/mgcv/man/s.html" class="external-link">s</a></span><span class="op">(</span><span class="va">x2</span><span class="op">)</span> <span class="op">+</span> <span class="fu"><a href="https://rdrr.io/pkg/mgcv/man/s.html" class="external-link">s</a></span><span class="op">(</span><span class="va">x3</span><span class="op">)</span>,</span></span>
<span class="r-in"><span>            priors <span class="op">=</span> <span class="fu"><a href="https://paulbuerkner.com/brms/reference/set_prior.html" class="external-link">prior</a></span><span class="op">(</span><span class="fu">normal</span><span class="op">(</span><span class="fl">0</span>, <span class="fl">0.75</span><span class="op">)</span>, class <span class="op">=</span> <span class="st">'b'</span><span class="op">)</span>,</span></span>
<span class="r-in"><span>            data <span class="op">=</span> <span class="va">dat</span>,</span></span>
<span class="r-in"><span>            family <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/family.html" class="external-link">gaussian</a></span><span class="op">(</span><span class="op">)</span>,</span></span>
<span class="r-in"><span>            run_model <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="fu"><a href="code.html">code</a></span><span class="op">(</span><span class="va">mod</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // Stan model code generated by package mvgam</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> functions {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector rep_each(vector x, int K) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     int N = rows(x);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     vector[N * K] y;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     int pos = 1;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     for (n in 1 : N) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       for (k in 1 : K) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         y[pos] = x[n];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         pos += 1;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     return y;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> data {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=0&gt; total_obs; // total number of observations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=0&gt; n; // number of timepoints per series</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=0&gt; n_sp; // number of smoothing parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=0&gt; n_series; // number of series</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=0&gt; num_basis; // total number of basis coefficients</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[num_basis] zero; // prior locations for basis coefficients</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[total_obs, num_basis] X; // mgcv GAM design matrix</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   array[n, n_series] int&lt;lower=0&gt; ytimes; // time-ordered matrix (which col in X belongs to each [time, series] observation?)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[9, 18] S1; // mgcv smooth penalty matrix S1</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[9, 18] S2; // mgcv smooth penalty matrix S2</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=0&gt; n_nonmissing; // number of nonmissing observations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[n_nonmissing] flat_ys; // flattened nonmissing observations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[n_nonmissing, num_basis] flat_xs; // X values for nonmissing observations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   array[n_nonmissing] int&lt;lower=0&gt; obs_ind; // indices of nonmissing observations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> parameters {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // raw basis coefficients</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[num_basis] b_raw;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // gaussian observation error</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector&lt;lower=0&gt;[n_series] sigma_obs;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // smoothing parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector&lt;lower=0&gt;[n_sp] lambda;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> transformed parameters {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // basis coefficients</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[num_basis] b;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   b[1 : num_basis] = b_raw[1 : num_basis];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> model {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // prior for (Intercept)...</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   b_raw[1] ~ student_t(3, 7.4, 3.7);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // prior for x0...</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   b_raw[2] ~ normal(0, 0.75);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // prior for x1...</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   b_raw[3] ~ normal(0, 0.75);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // prior for s(x2)...</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   b_raw[4 : 12] ~ multi_normal_prec(zero[4 : 12],</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                                     S1[1 : 9, 1 : 9] * lambda[1]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                                     + S1[1 : 9, 10 : 18] * lambda[2]);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // prior for s(x3)...</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   b_raw[13 : 21] ~ multi_normal_prec(zero[13 : 21],</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                                      S2[1 : 9, 1 : 9] * lambda[3]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                                      + S2[1 : 9, 10 : 18] * lambda[4]);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // priors for smoothing parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   lambda ~ normal(5, 30);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // priors for observation error parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   sigma_obs ~ student_t(3, 0, 3.7);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     // likelihood functions</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     vector[n_nonmissing] flat_sigma_obs;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     flat_sigma_obs = rep_each(sigma_obs, n)[obs_ind];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     flat_ys ~ normal_id_glm(flat_xs, 0.0, b, flat_sigma_obs);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> generated quantities {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[total_obs] eta;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[n, n_series] sigma_obs_vec;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[n, n_series] mus;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[n_sp] rho;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   array[n, n_series] real ypred;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   rho = log(lambda);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // posterior predictions</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   eta = X * b;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   for (s in 1 : n_series) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     sigma_obs_vec[1 : n, s] = rep_vector(sigma_obs[s], n);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   for (s in 1 : n_series) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     mus[1 : n, s] = eta[ytimes[1 : n, s]];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     ypred[1 : n, s] = normal_rng(mus[1 : n, s], sigma_obs_vec[1 : n, s]);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-in"><span><span class="co"># }</span></span></span>
</code></pre></div>
    </div>
  </main><aside class="col-md-3"><nav id="toc"><h2>On this page</h2>
    </nav></aside></div>


    <footer><div class="pkgdown-footer-left">
  <p></p><p>Developed by <a href="https://researchers.uq.edu.au/researcher/15140" class="external-link">Nicholas J Clark</a>.</p>
</div>

<div class="pkgdown-footer-right">
  <p></p><p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.0.7.</p>
</div>

    </footer></div>

  

  

  </body></html>

