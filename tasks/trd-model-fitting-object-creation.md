# Task Requirements Document: Model Fitting and mvgam Object Creation

## 1. Task Overview

### Purpose
Implement Stan model fitting and mvgam object creation that completes the modeling workflow after stancode/standata generation. This system must integrate seamlessly with existing `generate_combined_stancode()`, `combine_stan_data()`, `mvgam_formula`, and prior specification infrastructure while supporting multiple backends and enabling reuse for future `jsdgam()` function.

### Scope
- **Model Fitting**: Stan compilation and MCMC sampling using brms-style backend abstraction
- **Object Creation**: Structured mvgam objects with composition-based architecture 
- **Integration**: Direct integration with existing formula processing, validation, and code generation
- **Extensibility**: Reusable fitting infrastructure for future model types

### User Type
R package developers and users familiar with brms workflow expecting similar interface and functionality.

## 2. User Journey

### Primary Workflow (Building on Existing Infrastructure)
1. **Model Specification**: User calls `mvgam(formula, trend_formula, data, family, ...)`
2. **Formula Processing**: Function uses existing `mvgam_formula()` constructor and validation
3. **Code Generation**: Function calls existing `generate_combined_stancode()` and `combine_stan_data()`
4. **Model Fitting**: New `fit_mvgam()` compiles and fits the combined Stan model
5. **Object Creation**: New `create_mvgam_object()` assembles mvgam object with metadata
6. **Analysis Ready**: User can call existing and new methods on returned object

### Separate Fitting Workflow  
1. **Manual Control**: User calls `fit_mvgam(stancode, standata, ...)` with pre-generated code/data
2. **Direct Fitting**: Function handles compilation and sampling using existing validation
3. **Object Assembly**: User calls `create_mvgam_object()` with setup metadata from existing workflow
4. **Analysis Ready**: Same downstream functionality as primary workflow

## 3. Function Specifications

### 3.1 Primary Function: `mvgam()` (Modified to integrate existing workflow)
**Purpose**: Main user interface that coordinates existing infrastructure with new fitting functionality

**Parameters**:
- `formula`: formula or brmsformula object for observation model
- `trend_formula`: formula object for trend specification (optional, defaults to NULL)
- `data`: data.frame containing observations and covariates
- `family`: brms family object (defaults to `gaussian()`)
- `prior`: brmsprior object created via existing prior infrastructure (optional)
- `backend`: character string ("cmdstanr", "rstan", "mock") or auto-detect
- `iter`: integer, MCMC iterations per chain (default 2000)
- `chains`: integer, number of MCMC chains (default 4)
- `cores`: integer, number of cores for parallel sampling (default 1)
- `control`: list of Stan control parameters (optional)
- `stanvars`: additional stanvars for user extensions (optional)
- `...`: additional arguments passed to existing setup functions and fitting backend

**Return Value**: mvgam object with class `c("mvgam")`

**Integration Points**:
- Uses existing `mvgam_formula()` constructor for formula processing
- Calls existing `validate_time_series_for_trends()` for data validation
- Uses existing `generate_combined_stancode()` for code generation
- Uses existing `combine_stan_data()` for data preparation
- Integrates with existing prior resolution system

### 3.2 Fitting Function: `fit_mvgam()` (New, backend abstraction)
**Purpose**: Compile and fit Stan code generated by existing infrastructure

**Parameters**:
- `stancode`: character string from `generate_combined_stancode()`
- `standata`: named list from `combine_stan_data()`
- `backend`: character string ("cmdstanr", "rstan") or auto-detect
- `iter`: integer, MCMC iterations per chain (default 2000)
- `chains`: integer, number of MCMC chains (default 4)
- `cores`: integer, number of cores for parallel sampling (default 1)
- `control`: list of Stan control parameters (optional)
- `model_name`: character string for Stan model naming (optional)
- `...`: additional backend-specific arguments

**Return Value**: Backend-specific fit object (CmdStanMCMC or stanfit)

**Integration Points**:
- Accepts output directly from existing `generate_combined_stancode()`
- Uses standata from existing `combine_stan_data()`
- Integrates with existing validation via `validate_stan_code()`

### 3.3 Object Creation: `create_mvgam_object()` (New, builds on existing metadata)
**Purpose**: Assemble mvgam object using metadata from existing setup infrastructure

**Parameters**:
- `fit`: fitted Stan object from `fit_mvgam()`
- `mvgam_formula_obj`: mvgam_formula object from existing formula processing
- `setup_data`: list containing validated data and metadata from existing validation functions
- `prior_obj`: brmsprior object from existing prior infrastructure  
- `backend`: character string indicating which backend was used
- `algorithm`: list containing MCMC algorithm details
- `stancode`: original stancode for reproducibility
- `standata`: original standata for reproducibility

**Return Value**: mvgam object with complete structure for downstream analysis

**Integration Points**:
- Uses `mvgam_formula_obj` from existing formula processing
- Incorporates metadata from existing `extract_time_series_dimensions()`
- Uses validated data structure from existing validation pipeline
- Preserves prior specifications from existing prior system

### 3.4 Backend Interface: `get_backend_interface()` (New, copies brms pattern)
**Purpose**: Unified backend abstraction copying brms pattern for Stan interface

**Parameters**:
- `backend`: character string or NULL for auto-detection

**Return Value**: List containing backend-specific functions and metadata

**Integration Points**:
- Works with stancode from existing `generate_combined_stancode()`
- Compatible with standata from existing `combine_stan_data()`
- Uses existing `validate_stan_code()` for pre-compilation validation

## 4. Functional Requirements

### 4.1 Integration with Existing Formula Processing
1. The system must use existing `mvgam_formula()` constructor without modification
2. The system must integrate with existing formula validation and parsing logic
3. The system must support existing trend constructor system (AR, RW, VAR, etc.)
4. The system must work with existing multivariate trend detection logic
5. The system must preserve existing formula-based prior specification workflow

### 4.2 Integration with Existing Code Generation
1. The system must use output from existing `generate_combined_stancode()` without modification
2. The system must accept standata from existing `combine_stan_data()` directly
3. The system must integrate with existing stanvar injection system
4. The system must work with existing two-stage assembly architecture
5. The system must support existing validation via `validate_stan_code()`

### 4.3 Integration with Existing Data Processing
1. The system must use data validated by existing `validate_time_series_for_trends()`
2. The system must work with existing attribute-based variable system
3. The system must integrate with existing `extract_time_series_dimensions()` output
4. The system must preserve existing data ordering and preparation logic
5. The system must support existing multivariate data handling

### 4.4 Integration with Existing Prior System
1. The system must work with existing `get_trend_parameter_prior()` function
2. The system must support existing brmsprior objects without modification
3. The system must integrate with existing prior inspection via `get_prior.mvgam_formula()`
4. The system must preserve existing trend prior resolution system
5. The system must enable prior extraction from fitted mvgam objects

### 4.5 mvgam Object Structure (Building on existing metadata)
1. The system must create mvgam objects using composition with separate obs/trend brmsfit-like objects
2. The system must store trend metadata as attributes using existing metadata from setup
3. The system must preserve original user data without contamination from trend processing
4. The system must store forecast dispatch metadata from existing trend system
5. The system must maintain compatibility with existing S3 method patterns

## 5. Data Flow & Dependencies

### Integration with Existing Workflow
```
mvgam() 
→ mvgam_formula() [EXISTING]
→ validate_time_series_for_trends() [EXISTING] 
→ extract_time_series_dimensions() [EXISTING]
→ generate_combined_stancode() [EXISTING]
→ combine_stan_data() [EXISTING]
→ fit_mvgam() [NEW]
→ create_mvgam_object() [NEW]
```

### Required Existing Functions
- **Formula Processing**: `mvgam_formula()`, formula validation, trend constructor system
- **Data Validation**: `validate_time_series_for_trends()`, `ensure_mvgam_variables()`
- **Code Generation**: `generate_combined_stancode()`, `generate_trend_injection_stanvars()`
- **Data Preparation**: `combine_stan_data()`, `extract_time_series_dimensions()`
- **Prior System**: `get_prior.mvgam_formula()`, `get_trend_parameter_prior()`
- **Validation**: `validate_stan_code()`, existing validation infrastructure

### New Function Integration Points
```r
# fit_mvgam() integration
stancode <- generate_combined_stancode(formula_obj, data, ...) # EXISTING
standata <- combine_stan_data(obs_data, trend_data, ...)       # EXISTING
fit <- fit_mvgam(stancode, standata, backend = "cmdstanr")     # NEW

# create_mvgam_object() integration  
mvgam_obj <- create_mvgam_object(
  fit = fit,
  mvgam_formula_obj = formula_obj,        # From EXISTING processing
  setup_data = validated_data,            # From EXISTING validation
  prior_obj = prior_object,               # From EXISTING prior system
  backend = "cmdstanr"
)
```

## 6. User Interface Requirements

### 6.1 Seamless Integration with Existing Interface
```r
# Primary interface (builds on existing mvgam_formula)
mvgam(formula, trend_formula = ~ RW(), data, family = poisson(), 
      prior = prior_obj, backend = "cmdstanr", ...)

# Uses existing formula processing internally:
# mvgam_formula_obj <- mvgam_formula(formula, trend_formula)
# prior_obj <- get_prior(mvgam_formula_obj, data, family)
```

### 6.2 Compatibility with Existing Prior Workflow
```r
# Existing prior inspection (must continue to work)
mf <- mvgam_formula(y ~ x, trend_formula = ~ AR(p = 1))
priors <- get_prior(mf, data = data, family = poisson())

# Modified priors passed to mvgam()
custom_priors <- priors
custom_priors[custom_priors$class == "ar1_trend", "prior"] <- "normal(0, 0.5)"
fit <- mvgam(mf, data = data, family = poisson(), prior = custom_priors)

# Prior extraction from fitted object (new requirement)
fitted_priors <- get_prior(fit)  # Should work like brmsfit objects
```

### 6.3 Backend Integration
```r
# Backend selection (new functionality)
fit1 <- mvgam(..., backend = "cmdstanr")  # Explicit selection
fit2 <- mvgam(..., backend = "rstan")     # Fallback option
fit3 <- mvgam(...)                        # Auto-detection
```

## 7. Error Handling & Validation

### 7.1 Integration with Existing Validation
1. **Pre-fitting Validation**: Use existing validation functions to catch errors before Stan compilation
2. **Formula Validation**: Leverage existing trend compatibility and formula conflict detection
3. **Data Validation**: Use existing time series structure validation and data preparation
4. **Stan Code Validation**: Use existing `validate_stan_code()` before compilation attempts
5. **Prior Validation**: Use existing prior resolution and conflict detection

### 7.2 New Validation Requirements
1. **Backend Validation**: Check backend availability and version compatibility
2. **Compilation Validation**: Handle Stan compilation errors with informative messages
3. **Sampling Validation**: Detect and handle MCMC convergence issues
4. **Object Validation**: Ensure mvgam object structure supports required methods

### 7.3 Error Message Integration
```r
# Leverage existing error formatting
if (compilation_failed) {
  insight::format_error(
    "Stan model compilation failed. This may be due to:",
    "* Invalid Stan code generated from trend specification",
    "* Missing Stan installation or incompatible version", 
    "* Memory limitations for large models",
    "Run validate_stan_code(stancode) for detailed diagnostics."
  )
}
```

## 8. Examples & Usage Patterns

### 8.1 Basic Usage (Building on Existing Workflow)
```r
# Simple model using existing infrastructure
mf <- mvgam_formula(count ~ temperature, trend_formula = ~ RW())
priors <- get_prior(mf, data = portal_data, family = poisson())
fit1 <- mvgam(mf, data = portal_data, family = poisson(), prior = priors)

# Or simplified (internal formula processing)
fit1 <- mvgam(count ~ temperature, trend_formula = ~ RW(), 
              data = portal_data, family = poisson())
```

### 8.2 Manual Workflow Integration
```r
# Using existing code generation manually
mf <- mvgam_formula(count ~ temp, trend_formula = ~ AR(p = 1))
validated_data <- validate_time_series_for_trends(portal_data, mf)
stancode <- generate_combined_stancode(mf, validated_data)
standata <- combine_stan_data(validated_data, mf)

# New fitting functions
fit <- fit_mvgam(stancode, standata, backend = "cmdstanr")
mvgam_obj <- create_mvgam_object(fit, mf, validated_data, backend = "cmdstanr")
```

### 8.3 Prior Integration Example
```r
# Existing prior workflow continues to work
mf <- mvgam_formula(mvbind(count, biomass) ~ treatment, 
                    trend_formula = ~ AR(p = 1, cor = TRUE))
priors <- get_prior(mf, data = data, family = c(poisson(), gaussian()))

# Modify trend priors using existing system
priors[priors$class == "ar1_trend", "prior"] <- "normal(0.5, 0.2)"
priors[priors$class == "sigma_trend", "prior"] <- "student_t(3, 0, 1)"

# Fit with custom priors
fit <- mvgam(mf, data = data, family = c(poisson(), gaussian()), prior = priors)

# Extract priors from fitted object (new functionality)
fitted_priors <- get_prior(fit)
```

## 9. Testing Requirements

### 9.1 Integration Tests with Existing Infrastructure
- `test_mvgam_formula_integration()`: mvgam() works with existing mvgam_formula objects
- `test_existing_stancode_generation()`: fit_mvgam() works with existing generate_combined_stancode() output
- `test_existing_data_validation()`: Integration with validate_time_series_for_trends() and related functions
- `test_existing_prior_system()`: Compatible with get_prior.mvgam_formula() and prior resolution
- `test_trend_constructor_compatibility()`: Works with existing AR(), RW(), VAR() constructors

### 9.2 Backend and Fitting Tests
- `test_backend_detection()`: Auto-detection works with existing validation
- `test_stan_compilation()`: Compilation works with existing stancode generation
- `test_object_structure()`: mvgam objects support existing and new method requirements
- `test_metadata_preservation()`: Existing metadata from setup preserved in fitted objects

### 9.3 Backward Compatibility Tests
- `test_formula_interface_unchanged()`: Existing formula processing behavior preserved
- `test_prior_interface_unchanged()`: Existing prior specification workflow unchanged
- `test_validation_interface_unchanged()`: Existing validation functions work as before
- `test_stancode_output_unchanged()`: Generated stancode structure remains compatible

## 10. Documentation Requirements

### 10.1 Integration Documentation
```r
#' Fit Bayesian Multivariate State-Space Models
#'
#' @description
#' Fits multivariate time series models by integrating with existing mvgam 
#' formula processing, validation, and Stan code generation infrastructure.
#' Supports multiple Stan backends for MCMC sampling.
#'
#' @param formula Formula or mvgam_formula object (see \code{\link{mvgam_formula}})
#' @param trend_formula Trend specification (see existing trend constructors)
#' @param data Data frame (see existing validation requirements)
#' @param family Response family (see \code{\link{brms::brmsfamily}})
#' @param prior Prior object from \code{\link{get_prior.mvgam_formula}} (optional)
#' @param backend Stan backend ("cmdstanr", "rstan", or NULL for auto-detect)
#'
#' @details
#' This function coordinates the complete mvgam workflow:
#' \enumerate{
#'   \item Formula processing via existing \code{mvgam_formula()} infrastructure
#'   \item Data validation via existing \code{validate_time_series_for_trends()}
#'   \item Stan code generation via existing \code{generate_combined_stancode()}
#'   \item Data preparation via existing \code{combine_stan_data()}
#'   \item Model fitting via new \code{fit_mvgam()} backend abstraction
#'   \item Object creation via new \code{create_mvgam_object()}
#' }
#'
#' @seealso \code{\link{mvgam_formula}}, \code{\link{get_prior.mvgam_formula}}, 
#'          existing trend constructors, \code{\link{fit_mvgam}}
mvgam <- function(formula, trend_formula = NULL, data, ...)
```

### 10.2 Integration Examples
```r
#' @examples
#' \dontrun{
#' # Basic workflow using existing infrastructure
#' mf <- mvgam_formula(count ~ temperature, trend_formula = ~ RW())
#' priors <- get_prior(mf, data = portal_data, family = poisson())
#' fit <- mvgam(mf, data = portal_data, family = poisson(), prior = priors)
#' 
#' # Simplified interface (internal formula processing)
#' fit <- mvgam(count ~ temperature, trend_formula = ~ RW(), 
#'              data = portal_data, family = poisson())
#'              
#' # Manual workflow with existing functions
#' stancode <- generate_combined_stancode(mf, validated_data)
#' standata <- combine_stan_data(validated_data, mf)
#' stan_fit <- fit_mvgam(stancode, standata)
#' mvgam_obj <- create_mvgam_object(stan_fit, mf, validated_data)
#' }
```

## 11. Implementation Notes for Developers

### 11.1 Integration Architecture
```r
# Primary function integration pattern
mvgam <- function(formula, trend_formula = NULL, data, family = gaussian(), 
                  prior = NULL, backend = NULL, ...) {
  
  # Use existing infrastructure (no modifications needed)
  mvgam_formula_obj <- mvgam_formula(formula, trend_formula)
  validated_data <- validate_time_series_for_trends(data, mvgam_formula_obj, ...)
  
  # Existing prior system integration
  if (is.null(prior)) {
    prior <- get_prior(mvgam_formula_obj, data, family)
  }
  
  # Existing code generation (no modifications needed)
  stancode <- generate_combined_stancode(mvgam_formula_obj, validated_data, prior, ...)
  standata <- combine_stan_data(validated_data, mvgam_formula_obj, ...)
  
  # New fitting infrastructure
  fit <- fit_mvgam(stancode, standata, backend = backend, ...)
  
  # New object creation using existing metadata
  create_mvgam_object(
    fit = fit,
    mvgam_formula_obj = mvgam_formula_obj,
    setup_data = validated_data,
    prior_obj = prior,
    backend = attr(fit, "backend"),
    stancode = stancode,
    standata = standata
  )
}
```

### 11.2 Object Structure with Existing Metadata
```r
# mvgam object structure using existing metadata sources
structure(
  list(
    # Core components
    fit = stan_fit_object,                    # Combined Stan fit
    obs_model = create_obs_brmsfit_like(),    # For S3 method dispatch  
    trend_model = create_trend_brmsfit_like(), # For trend-specific methods
    
    # Data (preserve existing pattern)
    formula = mvgam_formula_obj,              # From existing mvgam_formula()
    data = original_data,                     # Unmodified user data
    data2 = additional_data,                  # brms-style additional data if needed
    prior = prior_obj,                        # From existing prior system
    
    # Fitting metadata
    algorithm = mcmc_info,                    # MCMC algorithm details
    backend = backend_name,                   # "cmdstanr", "rstan", "mock"
    stancode = stancode,                      # For reproducibility
    standata = standata,                      # For reproducibility
    version = package_versions                # Package version info
  ),
  
  # Attributes from existing metadata (not new data structures)
  trend_metadata = attr(validated_data, "trend_metadata"),      # From existing validation
  series_structure = attr(validated_data, "series_structure"), # From existing processing  
  forecast_dispatch = attr(trend_spec, "forecast_dispatch"),   # From existing trend system
  backend_info = stan_version_info,                           # New backend info
  class = "mvgam"
)
```

### 11.3 Code Organization Strategy
```
R/
├── mvgam.R                  # Main function integration with existing infrastructure
├── fit_mvgam.R             # New backend abstraction (copies brms patterns)
├── mvgam_object.R          # New object creation using existing metadata
├── mvgam_backends.R        # New backend interface (adapted from brms)
└── mvgam_methods.R         # New S3 methods for mvgam objects

# Existing files (no modifications needed for core functionality)
├── mvgam_formula.R         # EXISTING - formula processing
├── validations.R           # EXISTING - data validation and preparation
├── stan_assembly.R         # EXISTING - stancode/standata generation
├── priors.R                # EXISTING - prior specification and resolution
└── trend_system.R          # EXISTING - trend constructors and registry
```

## 12. Non-Goals (Explicit Boundaries)

### 12.1 Existing Infrastructure Modifications
- **No Changes to Formula Processing**: Use existing `mvgam_formula()` and validation exactly as implemented
- **No Changes to Code Generation**: Use existing `generate_combined_stancode()` and `combine_stan_data()` without modification
- **No Changes to Prior System**: Use existing prior specification and resolution infrastructure
- **No Changes to Trend System**: Use existing trend constructors and registry system
- **No Changes to Validation**: Use existing validation pipeline without modification

### 12.2 New Feature Boundaries  
- **No Custom Stan Generation**: Only fitting and object creation, not new stancode/standata generation
- **No Formula Extensions**: No new formula syntax beyond existing mvgam_formula capabilities
- **No New Prior Types**: Use existing brmsprior infrastructure only
- **No New Trend Types**: Use existing trend constructor system only

### 12.3 Compatibility Preservation
- **Maintain All Existing APIs**: No breaking changes to existing function interfaces
- **Preserve Existing Behavior**: All existing functions must work exactly as before
- **No Regression in Performance**: New functionality must not slow down existing workflows
- **Maintain Test Coverage**: All existing tests must continue to pass

## 13. Success Criteria

### 13.1 Integration Success
1. **Seamless Workflow**: `mvgam()` successfully integrates all existing infrastructure without modification
2. **API Compatibility**: All existing functions (mvgam_formula, get_prior, validation, etc.) work unchanged
3. **Formula Compatibility**: All existing trend constructors and formula specifications work identically
4. **Prior Compatibility**: Existing prior specification and inspection workflow works unchanged
5. **Metadata Preservation**: All existing metadata from setup phase preserved in fitted objects

### 13.2 Fitting Success
1. **Backend Flexibility**: All supported backends work equivalently with existing stancode generation
2. **Performance Maintenance**: Fitting performance comparable to direct Stan usage
3. **Error Handling**: Stan compilation and sampling errors handled gracefully with actionable guidance
4. **Validation Integration**: All existing validation runs before fitting to prevent Stan errors

### 13.3 Object Structure Success
1. **Method Compatibility**: mvgam objects support required S3 methods for analysis
2. **Prior Extraction**: `get_prior()` works on fitted mvgam objects like brmsfit objects
3. **Metadata Access**: All trend metadata required for prediction/forecasting preserved and accessible
4. **Reproducibility**: Objects contain sufficient information to recreate fits

### 13.4 Developer Success  
1. **Code Reusability**: Fitting infrastructure can be reused for `jsdgam()` with minimal changes
2. **Maintainability**: New code isolated from existing infrastructure to prevent regression
3. **Extensibility**: New backends can be added without modifying existing infrastructure
4. **Test Integration**: New tests integrate with existing test suite without conflicts

## 14. Open Questions

### 14.1 Integration Details
1. **Metadata Extraction**: What specific metadata from existing validation should be stored as attributes?
2. **Error Propagation**: How should errors from existing validation functions be handled during fitting?
3. **Performance Impact**: Will additional metadata storage significantly impact object size?
4. **Backwards Compatibility**: Should old workflow patterns continue to work if users bypass mvgam()?

### 14.2 Object Design Questions
1. **brmsfit-like Object Creation**: How detailed should the internal obs_model and trend_model objects be?
2. **Attribute Organization**: Should trend metadata be nested or flat in object attributes?
3. **Memory Optimization**: Should large Stan objects be stored with lazy loading?
4. **Method Dispatch**: Which methods should delegate to internal objects vs. custom implementation?

### 14.3 Technical Implementation
1. **Backend Auto-detection**: Should auto-detection preference be stored in global options?
2. **Convergence Checking**: Should convergence diagnostics be automatically computed and stored?
3. **Parallel Configuration**: How should multi-core settings interact with existing Stan data preparation?
4. **Version Tracking**: What level of version information should be stored for reproducibility?

### 14.4 Future Compatibility
1. **jsdgam Integration**: What additional parameters will fit_mvgam() need for jsdgam() compatibility?
2. **Stan Interface Changes**: How should the backend abstraction handle future Stan API changes?
3. **Method Evolution**: How should new S3 methods be added without breaking existing functionality?
4. **Package Dependencies**: Should cmdstanr become a hard dependency or remain optional?