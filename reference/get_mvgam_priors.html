<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="description" content="This function lists the parameters that can have their prior distributions
changed for a given model, as well listing their default distributions"><title>Extract information on default prior distributions for an mvgam model — get_mvgam_priors • mvgam</title><!-- favicons --><link rel="icon" type="image/png" sizes="16x16" href="../favicon-16x16.png"><link rel="icon" type="image/png" sizes="32x32" href="../favicon-32x32.png"><link rel="apple-touch-icon" type="image/png" sizes="180x180" href="../apple-touch-icon.png"><link rel="apple-touch-icon" type="image/png" sizes="120x120" href="../apple-touch-icon-120x120.png"><link rel="apple-touch-icon" type="image/png" sizes="76x76" href="../apple-touch-icon-76x76.png"><link rel="apple-touch-icon" type="image/png" sizes="60x60" href="../apple-touch-icon-60x60.png"><script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet"><script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous"><!-- bootstrap-toc --><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@v1.0.1/dist/bootstrap-toc.min.js" integrity="sha256-4veVQbu7//Lk5TSmc7YV48MxtMy98e26cf5MrgZYnwo=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.11/clipboard.min.js" integrity="sha512-7O5pXpc0oCRrxk8RUfDYFgn0nO1t+jLuIOQdOMRp4APB7uZ4vSjspzp5y6YDtDs4VzUSTbWzBFZ/LKJhnyFOKw==" crossorigin="anonymous" referrerpolicy="no-referrer"></script><!-- search --><script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/6.4.6/fuse.js" integrity="sha512-zv6Ywkjyktsohkbp9bb45V6tEMoWhzFzXis+LrMehmJZZSys19Yxf1dopHx7WzIKxr5tK2dVcYmaCk2uqdjF4A==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/autocomplete.js/0.38.0/autocomplete.jquery.min.js" integrity="sha512-GU9ayf+66Xx2TmpxqJpliWbT5PiGYxpaG8rfnBEk1LL8l1KGkRShhngwdXK1UgqhAzWpZHSiYPc09/NwDQIGyg==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/mark.min.js" integrity="sha512-5CYOlHXGh6QpOFA/TeTylKLWfB3ftPsde7AnmhuitiTX4K5SqCLBeKro6sPS8ilsz1Q4NRx3v8Ko2IBiszzdww==" crossorigin="anonymous"></script><!-- pkgdown --><script src="../pkgdown.js"></script><link href="../extra.css" rel="stylesheet"><meta property="og:title" content="Extract information on default prior distributions for an mvgam model — get_mvgam_priors"><meta property="og:description" content="This function lists the parameters that can have their prior distributions
changed for a given model, as well listing their default distributions"><meta property="og:image" content="https://nicholasjclark.github.io/mvgam/logo.png"><!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]--></head><body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>
    

    <nav class="navbar fixed-top navbar-dark navbar-expand-lg bg-primary" data-bs-theme="dark"><div class="container">
    
    <a class="navbar-brand me-2" href="../index.html">mvgam</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">1.1.52</small>

    
    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto"><li class="nav-item dropdown">
  <a href="#" class="nav-link dropdown-toggle" data-bs-toggle="dropdown" role="button" aria-expanded="false" aria-haspopup="true" id="dropdown-articles">Articles</a>
  <div class="dropdown-menu" aria-labelledby="dropdown-articles">
    <a class="dropdown-item" href="../articles/data_in_mvgam.html">Formatting data for use in mvgam</a>
    <a class="dropdown-item" href="../articles/forecast_evaluation.html">Forecasting and forecast evaluation in mvgam</a>
    <a class="dropdown-item" href="../articles/mvgam_overview.html">Overview of the mvgam package</a>
    <a class="dropdown-item" href="../articles/nmixtures.html">N-mixtures in mvgam</a>
    <a class="dropdown-item" href="../articles/shared_states.html">Shared latent states in mvgam</a>
    <a class="dropdown-item" href="../articles/time_varying_effects.html">Time-varying effects in mvgam</a>
    <a class="dropdown-item" href="../articles/trend_formulas.html">State-Space models in mvgam</a>
  </div>
</li>
<li class="active nav-item">
  <a class="nav-link" href="../reference/index.html">Reference</a>
</li>
<li class="nav-item">
  <a class="nav-link" href="../news/index.html">Changelog</a>
</li>
      </ul><form class="form-inline my-2 my-lg-0" role="search">
        <input type="search" class="form-control me-sm-2" aria-label="Toggle navigation" name="search-input" data-search-index="../search.json" id="search-input" placeholder="Search for" autocomplete="off"></form>

      <ul class="navbar-nav"><li class="nav-item">
  <a class="external-link nav-link" href="https://github.com/nicholasjclark/mvgam/" aria-label="github">
    <span class="fab fa fab fa-github fa-lg"></span>
     
  </a>
</li>
      </ul></div>

    
  </div>
</nav><div class="container template-reference-topic">
<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">
      <img src="../logo.png" class="logo" alt=""><h1>Extract information on default prior distributions for an <span class="pkg">mvgam</span> model</h1>
      <small class="dont-index">Source: <a href="https://github.com/nicholasjclark/mvgam/blob/HEAD/R/get_mvgam_priors.R" class="external-link"><code>R/get_mvgam_priors.R</code></a></small>
      <div class="d-none name"><code>get_mvgam_priors.Rd</code></div>
    </div>

    <div class="ref-description section level2">
    <p>This function lists the parameters that can have their prior distributions
changed for a given model, as well listing their default distributions</p>
    </div>

    <div class="section level2">
    <h2 id="ref-usage">Usage<a class="anchor" aria-label="anchor" href="#ref-usage"></a></h2>
    <div class="sourceCode"><pre class="sourceCode r"><code><span><span class="fu">get_mvgam_priors</span><span class="op">(</span></span>
<span>  <span class="va">formula</span>,</span>
<span>  <span class="va">trend_formula</span>,</span>
<span>  <span class="va">factor_formula</span>,</span>
<span>  <span class="va">knots</span>,</span>
<span>  <span class="va">trend_knots</span>,</span>
<span>  trend_model <span class="op">=</span> <span class="st">"None"</span>,</span>
<span>  family <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/family.html" class="external-link">poisson</a></span><span class="op">(</span><span class="op">)</span>,</span>
<span>  <span class="va">data</span>,</span>
<span>  unit <span class="op">=</span> <span class="va">time</span>,</span>
<span>  species <span class="op">=</span> <span class="va">series</span>,</span>
<span>  use_lv <span class="op">=</span> <span class="cn">FALSE</span>,</span>
<span>  <span class="va">n_lv</span>,</span>
<span>  <span class="va">trend_map</span>,</span>
<span>  <span class="va">...</span></span>
<span><span class="op">)</span></span></code></pre></div>
    </div>

    <div class="section level2">
    <h2 id="arguments">Arguments<a class="anchor" aria-label="anchor" href="#arguments"></a></h2>
    <dl><dt>formula</dt>
<dd><p>A <code>formula</code> object specifying the GAM observation model formula.
These are exactly like the formula for a GLM except that smooth terms, <code><a href="https://rdrr.io/pkg/mgcv/man/s.html" class="external-link">s()</a></code>,
<code><a href="https://rdrr.io/pkg/mgcv/man/te.html" class="external-link">te()</a></code>, <code><a href="https://rdrr.io/pkg/mgcv/man/te.html" class="external-link">ti()</a></code>, <code><a href="https://rdrr.io/pkg/mgcv/man/t2.html" class="external-link">t2()</a></code>, as well as time-varying <code><a href="dynamic.html">dynamic()</a></code> terms,
nonparametric <code><a href="https://paulbuerkner.com/brms/reference/gp.html" class="external-link">gp()</a></code> terms and offsets using <code><a href="https://rdrr.io/r/stats/offset.html" class="external-link">offset()</a></code>, can be added to the
right hand side to specify that the linear predictor depends on smooth
functions of predictors (or linear functionals of these).</p>
<p>In <code><a href="mvgam_families.html">nmix()</a></code> family models, the <code>formula</code> is used to set up a linear predictor
for the detection probability. Details of the formula syntax used by
<span class="pkg">mvgam</span> can be found in <code><a href="mvgam_formulae.html">mvgam_formulae</a></code></p></dd>


<dt>trend_formula</dt>
<dd><p>An optional <code>formula</code> object specifying the GAM process
model formula. If supplied, a linear predictor will be modelled for the
latent trends to capture process model evolution separately from the
observation model.</p>
<p><strong>Important notes:</strong></p><ul><li><p>Should not have a response variable specified on the left-hand side
(e.g., <code>~ season + s(year)</code>)</p></li>
<li><p>Use <code>trend</code> instead of <code>series</code> for effects that vary across time series</p></li>
<li><p>Only available for <code><a href="RW.html">RW()</a></code>, <code><a href="RW.html">AR()</a></code> and <code><a href="RW.html">VAR()</a></code> trend models</p></li>
<li><p>In <code><a href="mvgam_families.html">nmix()</a></code> family models, sets up linear predictor for latent abundance</p></li>
<li><p>Consider dropping one intercept using <code>- 1</code> convention to avoid
estimation challenges</p></li>
</ul></dd>


<dt>factor_formula</dt>
<dd><p>Can be supplied instead <code>trend_formula</code> to match
syntax from <a href="jsdgam.html">jsdgam</a></p></dd>


<dt>knots</dt>
<dd><p>An optional <code>list</code> containing user specified knot values for
basis construction. For most bases the user simply supplies the knots to be
used, which must match up with the <code>k</code> value supplied. Different terms can
use different numbers of knots, unless they share a covariate.</p></dd>


<dt>trend_knots</dt>
<dd><p>As for <code>knots</code> above, this is an optional <code>list</code> of knot
values for smooth functions within the <code>trend_formula</code>.</p></dd>


<dt>trend_model</dt>
<dd><p><code>character</code> or <code>function</code> specifying the time series dynamics
for the latent trend.</p>
<p><strong>Available options:</strong></p><ul><li><p><code>None</code>: No latent trend component (GAM component only, like <code><a href="https://rdrr.io/pkg/mgcv/man/gam.html" class="external-link">gam</a></code>)</p></li>
<li><p><code>ZMVN</code> or <code><a href="ZMVN.html">ZMVN()</a></code>: Zero-Mean Multivariate Normal (Stan only)</p></li>
<li><p><code>'RW'</code> or <code><a href="RW.html">RW()</a></code>: Random Walk</p></li>
<li><p><code>'AR1'</code>, <code>'AR2'</code>, <code>'AR3'</code> or <code>AR(p = 1, 2, 3)</code>: Autoregressive models</p></li>
<li><p><code>'CAR1'</code> or <code>CAR(p = 1)</code>: Continuous-time AR (Ornstein–Uhlenbeck process)</p></li>
<li><p><code>'VAR1'</code> or <code><a href="RW.html">VAR()</a></code>: Vector Autoregressive (Stan only)</p></li>
<li><p><code>'PWlogistic'</code>, <code>'PWlinear'</code> or <code><a href="piecewise_trends.html">PW()</a></code>: Piecewise trends (Stan only)</p></li>
<li><p><code>'GP'</code> or <code><a href="GP.html">GP()</a></code>: Gaussian Process with squared exponential kernel (Stan only)</p></li>
</ul><p><strong>Additional features:</strong></p><ul><li><p>Moving average and/or correlated process error terms available for most types
(e.g., <code>RW(cor = TRUE)</code> for multivariate Random Walk)</p></li>
<li><p>Hierarchical correlations possible for structured data</p></li>
<li><p>See <a href="mvgam_trends.html">mvgam_trends</a> for details and <code><a href="ZMVN.html">ZMVN()</a></code> for examples</p></li>
</ul></dd>


<dt>family</dt>
<dd><p><code>family</code> specifying the exponential observation family for the series.</p>
<p><strong>Supported families:</strong></p><ul><li><p><code><a href="https://rdrr.io/r/stats/family.html" class="external-link">gaussian()</a></code>: Real-valued data</p></li>
<li><p><code><a href="mvgam_families.html">betar()</a></code>: Proportional data on <code>(0,1)</code></p></li>
<li><p><code><a href="mvgam_families.html">lognormal()</a></code>: Non-negative real-valued data</p></li>
<li><p><code><a href="mvgam_families.html">student_t()</a></code>: Real-valued data</p></li>
<li><p><code><a href="https://rdrr.io/r/stats/family.html" class="external-link">Gamma()</a></code>: Non-negative real-valued data</p></li>
<li><p><code><a href="mvgam_families.html">bernoulli()</a></code>: Binary data</p></li>
<li><p><code><a href="https://rdrr.io/r/stats/family.html" class="external-link">poisson()</a></code>: Count data (default)</p></li>
<li><p><code><a href="mvgam_families.html">nb()</a></code>: Overdispersed count data</p></li>
<li><p><code><a href="https://rdrr.io/r/stats/family.html" class="external-link">binomial()</a></code>: Count data with imperfect detection when number of trials is known
(use <code><a href="https://rdrr.io/r/base/cbind.html" class="external-link">cbind()</a></code> to bind observations and trials)</p></li>
<li><p><code><a href="mvgam_families.html">beta_binomial()</a></code>: As <code><a href="https://rdrr.io/r/stats/family.html" class="external-link">binomial()</a></code> but allows for overdispersion</p></li>
<li><p><code><a href="mvgam_families.html">nmix()</a></code>: Count data with imperfect detection when number of trials is unknown
(State-Space N-Mixture model with Poisson latent states and Binomial observations)</p></li>
</ul><p>See <code><a href="mvgam_families.html">mvgam_families</a></code> for more details.</p></dd>


<dt>data</dt>
<dd><p>A <code>dataframe</code> or <code>list</code> containing the model response variable
and covariates required by the GAM <code>formula</code> and optional <code>trend_formula</code>.</p>
<p><strong>Required columns for most models:</strong></p><ul><li><p><code>series</code>: A <code>factor</code> index of the series IDs (number of levels should equal
number of unique series labels)</p></li>
<li><p><code>time</code>: <code>numeric</code> or <code>integer</code> index of time points. For most dynamic trend
types, time should be measured in discrete, regularly spaced intervals
(i.e., <code>c(1, 2, 3, ...)</code>). Irregular spacing is allowed for <code>trend_model = CAR(1)</code>,
but zero intervals are adjusted to <code>1e-12</code> to prevent sampling errors.</p></li>
</ul><p><strong>Special cases:</strong></p><ul><li><p>Models with hierarchical temporal correlation (e.g., <code>AR(gr = region, subgr = species)</code>)
should NOT include a <code>series</code> identifier</p></li>
<li><p>Models without temporal dynamics (<code>trend_model = 'None'</code> or <code>trend_model = ZMVN()</code>)
don't require a <code>time</code> variable</p></li>
</ul></dd>


<dt>unit</dt>
<dd><p>The unquoted name of the variable that represents the unit of
analysis in <code>data</code> over which latent residuals should be correlated. This
variable should be either a <code>numeric</code> or <code>integer</code> variable in the
supplied <code>data</code>. Defaults to <code>time</code> to be consistent with other
functionalities in <span class="pkg">mvgam</span>, though note that the data need not be time
series in this case. See examples below for further details and
explanations</p></dd>


<dt>species</dt>
<dd><p>The unquoted name of the <code>factor</code> variable that indexes the
different response units in <code>data</code> (usually <code>'species'</code> in a JSDM).
Defaults to <code>series</code> to be consistent with other <code>mvgam</code> models</p></dd>


<dt>use_lv</dt>
<dd><p><code>logical</code>. If <code>TRUE</code>, use dynamic factors to estimate series'
latent trends in a reduced dimension format. Only available for <code><a href="RW.html">RW()</a></code>,
<code><a href="RW.html">AR()</a></code> and <code><a href="GP.html">GP()</a></code> trend models. Default is <code>FALSE</code>.
See <code><a href="lv_correlations.html">lv_correlations</a></code> for examples.</p></dd>


<dt>n_lv</dt>
<dd><p><code>integer</code> specifying the number of latent dynamic factors to use
if <code>use_lv == TRUE</code>. Cannot exceed <code>n_series</code>. Default is
<code>min(2, floor(n_series / 2))</code>.</p></dd>


<dt>trend_map</dt>
<dd><p>Optional <code>data.frame</code> specifying which series should depend on
which latent trends. Enables multiple series to depend on the same latent
trend process with different observation processes.</p>
<p><strong>Required structure:</strong></p><ul><li><p>Column <code>series</code>: Single unique entry for each series (matching factor levels in data)</p></li>
<li><p>Column <code>trend</code>: Integer values indicating which trend each series depends on</p></li>
</ul><p><strong>Notes:</strong></p><ul><li><p>Sets up latent factor model by enabling <code>use_lv = TRUE</code></p></li>
<li><p>Process model intercept is NOT automatically suppressed</p></li>
<li><p>Not yet supported for continuous time models (<code><a href="RW.html">CAR()</a></code>)</p></li>
</ul></dd>


<dt>...</dt>
<dd><p>Not currently used</p></dd>

</dl></div>
    <div class="section level2">
    <h2 id="value">Value<a class="anchor" aria-label="anchor" href="#value"></a></h2>
    

<p>either a <code>data.frame</code> containing the prior definitions (if any
suitable priors can be altered by the user) or <code>NULL</code>, indicating
that no priors in the model can be modified</p>
    </div>
    <div class="section level2">
    <h2 id="details">Details<a class="anchor" aria-label="anchor" href="#details"></a></h2>
    <p>Users can supply a model formula, prior to fitting the model, so
that default priors can be inspected and altered. To make alterations,
change the contents of the <code>prior</code> column and supplying this
<code>data.frame</code> to the <code><a href="mvgam.html">mvgam</a></code> or <code><a href="jsdgam.html">jsdgam</a></code>
functions using the argument <code>priors</code>. If using <code>Stan</code> as the backend,
users can also modify the parameter bounds by modifying the
<code>new_lowerbound</code> and/or <code>new_upperbound</code> columns. This will be necessary
if using restrictive distributions on some parameters, such as a Beta
distribution for the trend sd parameters for example (Beta only has
support on <code>(0,1)</code>), so the upperbound cannot be above <code>1</code>. Another
option is to make use of the prior modification functions in <span class="pkg">brms</span>
(i.e. <code><a href="https://paulbuerkner.com/brms/reference/set_prior.html" class="external-link">prior</a></code>) to change prior distributions and bounds
(just use the name of the parameter that you'd like to change as the
<code>class</code> argument; see examples below)</p>
    </div>
    <div class="section level2">
    <h2 id="note">Note<a class="anchor" aria-label="anchor" href="#note"></a></h2>
    <p>Only the <code>prior</code>, <code>new_lowerbound</code> and/or <code>new_upperbound</code> columns of
the output should be altered when defining the user-defined priors for
the model. Use only if you are familiar with the underlying probabilistic
programming language. There are no sanity checks done to ensure that the
code is legal (i.e. to check that lower bounds are smaller than upper
bounds, for example)</p>
    </div>
    <div class="section level2">
    <h2 id="see-also">See also<a class="anchor" aria-label="anchor" href="#see-also"></a></h2>
    <div class="dont-index"><p><code><a href="mvgam.html">mvgam</a></code>, <code><a href="mvgam_formulae.html">mvgam_formulae</a></code>,
<code><a href="https://paulbuerkner.com/brms/reference/set_prior.html" class="external-link">prior</a></code></p></div>
    </div>
    <div class="section level2">
    <h2 id="author">Author<a class="anchor" aria-label="anchor" href="#author"></a></h2>
    <p>Nicholas J Clark</p>
    </div>

    <div class="section level2">
    <h2 id="ref-examples">Examples<a class="anchor" aria-label="anchor" href="#ref-examples"></a></h2>
    <div class="sourceCode"><pre class="sourceCode r"><code><span class="r-in"><span><span class="co"># \donttest{</span></span></span>
<span class="r-in"><span><span class="co"># ========================================================================</span></span></span>
<span class="r-in"><span><span class="co"># Example 1: Simulate data and inspect default priors</span></span></span>
<span class="r-in"><span><span class="co"># ========================================================================</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="va">dat</span> <span class="op">&lt;-</span> <span class="fu"><a href="sim_mvgam.html">sim_mvgam</a></span><span class="op">(</span>trend_rel <span class="op">=</span> <span class="fl">0.5</span><span class="op">)</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># Get a model file that uses default mvgam priors for inspection (not</span></span></span>
<span class="r-in"><span><span class="co"># always necessary, but this can be useful for testing whether your</span></span></span>
<span class="r-in"><span><span class="co"># updated priors are written correctly)</span></span></span>
<span class="r-in"><span><span class="va">mod_default</span> <span class="op">&lt;-</span> <span class="fu"><a href="mvgam.html">mvgam</a></span><span class="op">(</span></span></span>
<span class="r-in"><span>  <span class="va">y</span> <span class="op">~</span> <span class="fu"><a href="https://rdrr.io/pkg/mgcv/man/s.html" class="external-link">s</a></span><span class="op">(</span><span class="va">series</span>, bs <span class="op">=</span> <span class="st">"re"</span><span class="op">)</span> <span class="op">+</span> <span class="fu"><a href="https://rdrr.io/pkg/mgcv/man/s.html" class="external-link">s</a></span><span class="op">(</span><span class="va">season</span>, bs <span class="op">=</span> <span class="st">"cc"</span><span class="op">)</span> <span class="op">-</span> <span class="fl">1</span>,</span></span>
<span class="r-in"><span>  family <span class="op">=</span> <span class="fu"><a href="mvgam_families.html">nb</a></span><span class="op">(</span><span class="op">)</span>,</span></span>
<span class="r-in"><span>  data <span class="op">=</span> <span class="va">dat</span><span class="op">$</span><span class="va">data_train</span>,</span></span>
<span class="r-in"><span>  trend_model <span class="op">=</span> <span class="fu"><a href="RW.html">AR</a></span><span class="op">(</span>p <span class="op">=</span> <span class="fl">2</span><span class="op">)</span>,</span></span>
<span class="r-in"><span>  run_model <span class="op">=</span> <span class="cn">FALSE</span></span></span>
<span class="r-in"><span><span class="op">)</span></span></span>
<span class="r-msg co"><span class="r-pr">#&gt;</span> Your model may benefit from using "noncentred = TRUE"</span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># Inspect the model file with default mvgam priors</span></span></span>
<span class="r-in"><span><span class="fu"><a href="https://paulbuerkner.com/brms/reference/stancode.html" class="external-link">stancode</a></span><span class="op">(</span><span class="va">mod_default</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // Stan model code generated by package mvgam</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> functions {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector rep_each(vector x, int K) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     int N = rows(x);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     vector[N * K] y;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     int pos = 1;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     for (n in 1 : N) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       for (k in 1 : K) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         y[pos] = x[n];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         pos += 1;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     return y;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> data {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=0&gt; total_obs; // total number of observations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=0&gt; n; // number of timepoints per series</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=0&gt; n_sp; // number of smoothing parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=0&gt; n_series; // number of series</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=0&gt; num_basis; // total number of basis coefficients</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[num_basis] zero; // prior locations for basis coefficients</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[total_obs, num_basis] X; // mgcv GAM design matrix</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   array[n, n_series] int&lt;lower=0&gt; ytimes; // time-ordered matrix (which col in X belongs to each [time, series] observation?)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[8, 8] S1; // mgcv smooth penalty matrix S1</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=0&gt; n_nonmissing; // number of nonmissing observations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   array[n_nonmissing] int&lt;lower=0&gt; flat_ys; // flattened nonmissing observations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[n_nonmissing, num_basis] flat_xs; // X values for nonmissing observations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   array[n_nonmissing] int&lt;lower=0&gt; obs_ind; // indices of nonmissing observations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> parameters {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // raw basis coefficients</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[num_basis] b_raw;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // random effect variances</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector&lt;lower=0&gt;[1] sigma_raw;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // random effect means</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[1] mu_raw;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // negative binomial overdispersion</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector&lt;lower=0&gt;[n_series] phi_inv;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // latent trend AR1 terms</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector&lt;lower=-1, upper=1&gt;[n_series] ar1;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // latent trend AR2 terms</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector&lt;lower=-1, upper=1&gt;[n_series] ar2;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // latent trend variance parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector&lt;lower=0&gt;[n_series] sigma;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // latent trends</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[n, n_series] trend;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // smoothing parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector&lt;lower=0&gt;[n_sp] lambda;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> transformed parameters {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // basis coefficients</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[num_basis] b;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   b[1 : 8] = b_raw[1 : 8];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   b[9 : 11] = mu_raw[1] + b_raw[9 : 11] * sigma_raw[1];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> model {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // prior for random effect population variances</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   sigma_raw ~ inv_gamma(1.418, 0.452);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // prior for random effect population means</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   mu_raw ~ std_normal();</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // prior for s(season)...</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   b_raw[1 : 8] ~ multi_normal_prec(zero[1 : 8], S1[1 : 8, 1 : 8] * lambda[1]);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // prior (non-centred) for s(series)...</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   b_raw[9 : 11] ~ std_normal();</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // priors for AR parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   ar1 ~ std_normal();</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   ar2 ~ std_normal();</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // priors for smoothing parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   lambda ~ normal(5, 30);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // priors for overdispersion parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   phi_inv ~ student_t(3, 0, 0.1);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // priors for latent trend variance parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   sigma ~ inv_gamma(1.418, 0.452);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // trend estimates</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   trend[1, 1 : n_series] ~ normal(0, sigma);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   trend[2, 1 : n_series] ~ normal(trend[1, 1 : n_series] * ar1, sigma);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   for (s in 1 : n_series) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     trend[3 : n, s] ~ normal(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                              ar1[s] * trend[2 : (n - 1), s]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                              + ar2[s] * trend[1 : (n - 2), s], sigma[s]);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     // likelihood functions</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     vector[n_nonmissing] flat_trends;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     array[n_nonmissing] real flat_phis;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     flat_trends = to_vector(trend)[obs_ind];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     flat_phis = to_array_1d(rep_each(phi_inv, n)[obs_ind]);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     flat_ys ~ neg_binomial_2(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                              exp(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                                  append_col(flat_xs, flat_trends)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                                  * append_row(b, 1.0)),</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                              inv(flat_phis));</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> generated quantities {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[total_obs] eta;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[n, n_series] mus;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[n_sp] rho;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[n_series] tau;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   array[n, n_series] int ypred;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[n, n_series] phi_vec;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[n_series] phi;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   phi = inv(phi_inv);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   for (s in 1 : n_series) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     phi_vec[1 : n, s] = rep_vector(phi[s], n);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   rho = log(lambda);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   for (s in 1 : n_series) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     tau[s] = pow(sigma[s], -2.0);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // posterior predictions</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   eta = X * b;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   for (s in 1 : n_series) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     mus[1 : n, s] = eta[ytimes[1 : n, s]] + trend[1 : n, s];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     ypred[1 : n, s] = neg_binomial_2_rng(exp(mus[1 : n, s]), phi_vec[1 : n, s]);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># Look at which priors can be updated in mvgam</span></span></span>
<span class="r-in"><span><span class="va">test_priors</span> <span class="op">&lt;-</span> <span class="fu">get_mvgam_priors</span><span class="op">(</span></span></span>
<span class="r-in"><span>  <span class="va">y</span> <span class="op">~</span> <span class="fu"><a href="https://rdrr.io/pkg/mgcv/man/s.html" class="external-link">s</a></span><span class="op">(</span><span class="va">series</span>, bs <span class="op">=</span> <span class="st">"re"</span><span class="op">)</span> <span class="op">+</span> <span class="fu"><a href="https://rdrr.io/pkg/mgcv/man/s.html" class="external-link">s</a></span><span class="op">(</span><span class="va">season</span>, bs <span class="op">=</span> <span class="st">"cc"</span><span class="op">)</span> <span class="op">-</span> <span class="fl">1</span>,</span></span>
<span class="r-in"><span>  family <span class="op">=</span> <span class="fu"><a href="mvgam_families.html">nb</a></span><span class="op">(</span><span class="op">)</span>,</span></span>
<span class="r-in"><span>  data <span class="op">=</span> <span class="va">dat</span><span class="op">$</span><span class="va">data_train</span>,</span></span>
<span class="r-in"><span>  trend_model <span class="op">=</span> <span class="fu"><a href="RW.html">AR</a></span><span class="op">(</span>p <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="va">test_priors</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                                param_name param_length</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 1           vector&lt;lower=0&gt;[n_sp] lambda;            2</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 2                       vector[1] mu_raw;            1</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 3           vector&lt;lower=0&gt;[1] sigma_raw;            1</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 4 vector&lt;lower=-1,upper=1&gt;[n_series] ar1;            3</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 5 vector&lt;lower=-1,upper=1&gt;[n_series] ar2;            3</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 6        vector&lt;lower=0&gt;[n_series] sigma;            3</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 7      vector&lt;lower=0&gt;[n_series] phi_inv;            3</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                    param_info                                prior</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 1 s(season) smooth parameters              lambda ~ normal(5, 30);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 2          s(series) pop mean               mu_raw ~ std_normal();</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 3            s(series) pop sd sigma_raw ~ inv_gamma(1.418, 0.452);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 4       trend AR1 coefficient                  ar1 ~ std_normal();</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 5       trend AR2 coefficient                  ar2 ~ std_normal();</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 6                    trend sd     sigma ~ inv_gamma(1.418, 0.452);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 7   inverse of NB dispsersion      phi_inv ~ student_t(3, 0, 0.1);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                   example_change new_lowerbound new_upperbound</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 1    lambda ~ exponential(0.44);             NA             NA</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 2   mu_raw ~ normal(0.87, 0.28);             NA             NA</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 3 sigma_raw ~ exponential(0.58);             NA             NA</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 4      ar1 ~ normal(0.55, 0.21);             NA             NA</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 5     ar2 ~ normal(-0.67, 0.19);             NA             NA</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 6     sigma ~ exponential(0.02);             NA             NA</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 7  phi_inv ~ normal(0.82, 0.17);             NA             NA</span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># ========================================================================</span></span></span>
<span class="r-in"><span><span class="co"># Example 2: Modify priors manually</span></span></span>
<span class="r-in"><span><span class="co"># ========================================================================</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># Make a few changes; first, change the population mean for the</span></span></span>
<span class="r-in"><span><span class="co"># series-level random intercepts</span></span></span>
<span class="r-in"><span><span class="va">test_priors</span><span class="op">$</span><span class="va">prior</span><span class="op">[</span><span class="fl">2</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="st">"mu_raw ~ normal(0.2, 0.5);"</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># Now use stronger regularisation for the series-level AR2 coefficients</span></span></span>
<span class="r-in"><span><span class="va">test_priors</span><span class="op">$</span><span class="va">prior</span><span class="op">[</span><span class="fl">5</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="st">"ar2 ~ normal(0, 0.25);"</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># Check that the changes are made to the model file without any warnings</span></span></span>
<span class="r-in"><span><span class="co"># by setting 'run_model = FALSE'</span></span></span>
<span class="r-in"><span><span class="va">mod</span> <span class="op">&lt;-</span> <span class="fu"><a href="mvgam.html">mvgam</a></span><span class="op">(</span></span></span>
<span class="r-in"><span>  <span class="va">y</span> <span class="op">~</span> <span class="fu"><a href="https://rdrr.io/pkg/mgcv/man/s.html" class="external-link">s</a></span><span class="op">(</span><span class="va">series</span>, bs <span class="op">=</span> <span class="st">"re"</span><span class="op">)</span> <span class="op">+</span> <span class="fu"><a href="https://rdrr.io/pkg/mgcv/man/s.html" class="external-link">s</a></span><span class="op">(</span><span class="va">season</span>, bs <span class="op">=</span> <span class="st">"cc"</span><span class="op">)</span> <span class="op">-</span> <span class="fl">1</span>,</span></span>
<span class="r-in"><span>  family <span class="op">=</span> <span class="fu"><a href="mvgam_families.html">nb</a></span><span class="op">(</span><span class="op">)</span>,</span></span>
<span class="r-in"><span>  data <span class="op">=</span> <span class="va">dat</span><span class="op">$</span><span class="va">data_train</span>,</span></span>
<span class="r-in"><span>  trend_model <span class="op">=</span> <span class="fu"><a href="RW.html">AR</a></span><span class="op">(</span>p <span class="op">=</span> <span class="fl">2</span><span class="op">)</span>,</span></span>
<span class="r-in"><span>  priors <span class="op">=</span> <span class="va">test_priors</span>,</span></span>
<span class="r-in"><span>  run_model <span class="op">=</span> <span class="cn">FALSE</span></span></span>
<span class="r-in"><span><span class="op">)</span></span></span>
<span class="r-msg co"><span class="r-pr">#&gt;</span> Your model may benefit from using "noncentred = TRUE"</span>
<span class="r-in"><span><span class="fu"><a href="https://paulbuerkner.com/brms/reference/stancode.html" class="external-link">stancode</a></span><span class="op">(</span><span class="va">mod</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // Stan model code generated by package mvgam</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> functions {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector rep_each(vector x, int K) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     int N = rows(x);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     vector[N * K] y;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     int pos = 1;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     for (n in 1 : N) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       for (k in 1 : K) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         y[pos] = x[n];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         pos += 1;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     return y;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> data {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=0&gt; total_obs; // total number of observations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=0&gt; n; // number of timepoints per series</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=0&gt; n_sp; // number of smoothing parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=0&gt; n_series; // number of series</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=0&gt; num_basis; // total number of basis coefficients</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[num_basis] zero; // prior locations for basis coefficients</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[total_obs, num_basis] X; // mgcv GAM design matrix</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   array[n, n_series] int&lt;lower=0&gt; ytimes; // time-ordered matrix (which col in X belongs to each [time, series] observation?)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[8, 8] S1; // mgcv smooth penalty matrix S1</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=0&gt; n_nonmissing; // number of nonmissing observations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   array[n_nonmissing] int&lt;lower=0&gt; flat_ys; // flattened nonmissing observations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[n_nonmissing, num_basis] flat_xs; // X values for nonmissing observations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   array[n_nonmissing] int&lt;lower=0&gt; obs_ind; // indices of nonmissing observations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> parameters {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // raw basis coefficients</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[num_basis] b_raw;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // random effect variances</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector&lt;lower=0&gt;[1] sigma_raw;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // random effect means</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[1] mu_raw;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // negative binomial overdispersion</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector&lt;lower=0&gt;[n_series] phi_inv;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // latent trend AR1 terms</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector&lt;lower=-1, upper=1&gt;[n_series] ar1;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // latent trend AR2 terms</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector&lt;lower=-1, upper=1&gt;[n_series] ar2;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // latent trend variance parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector&lt;lower=0&gt;[n_series] sigma;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // latent trends</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[n, n_series] trend;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // smoothing parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector&lt;lower=0&gt;[n_sp] lambda;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> transformed parameters {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // basis coefficients</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[num_basis] b;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   b[1 : 8] = b_raw[1 : 8];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   b[9 : 11] = mu_raw[1] + b_raw[9 : 11] * sigma_raw[1];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> model {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // prior for random effect population variances</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   sigma_raw ~ inv_gamma(1.418, 0.452);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // prior for random effect population means</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   mu_raw ~ normal(0.2, 0.5);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // prior for s(season)...</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   b_raw[1 : 8] ~ multi_normal_prec(zero[1 : 8], S1[1 : 8, 1 : 8] * lambda[1]);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // prior (non-centred) for s(series)...</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   b_raw[9 : 11] ~ std_normal();</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // priors for AR parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   ar1 ~ std_normal();</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   ar2 ~ normal(0, 0.25);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // priors for smoothing parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   lambda ~ normal(5, 30);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // priors for overdispersion parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   phi_inv ~ student_t(3, 0, 0.1);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // priors for latent trend variance parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   sigma ~ inv_gamma(1.418, 0.452);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // trend estimates</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   trend[1, 1 : n_series] ~ normal(0, sigma);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   trend[2, 1 : n_series] ~ normal(trend[1, 1 : n_series] * ar1, sigma);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   for (s in 1 : n_series) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     trend[3 : n, s] ~ normal(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                              ar1[s] * trend[2 : (n - 1), s]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                              + ar2[s] * trend[1 : (n - 2), s], sigma[s]);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     // likelihood functions</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     vector[n_nonmissing] flat_trends;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     array[n_nonmissing] real flat_phis;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     flat_trends = to_vector(trend)[obs_ind];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     flat_phis = to_array_1d(rep_each(phi_inv, n)[obs_ind]);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     flat_ys ~ neg_binomial_2(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                              exp(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                                  append_col(flat_xs, flat_trends)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                                  * append_row(b, 1.0)),</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                              inv(flat_phis));</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> generated quantities {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[total_obs] eta;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[n, n_series] mus;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[n_sp] rho;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[n_series] tau;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   array[n, n_series] int ypred;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[n, n_series] phi_vec;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[n_series] phi;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   phi = inv(phi_inv);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   for (s in 1 : n_series) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     phi_vec[1 : n, s] = rep_vector(phi[s], n);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   rho = log(lambda);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   for (s in 1 : n_series) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     tau[s] = pow(sigma[s], -2.0);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // posterior predictions</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   eta = X * b;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   for (s in 1 : n_series) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     mus[1 : n, s] = eta[ytimes[1 : n, s]] + trend[1 : n, s];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     ypred[1 : n, s] = neg_binomial_2_rng(exp(mus[1 : n, s]), phi_vec[1 : n, s]);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># No warnings, the model is ready for fitting now in the usual way with</span></span></span>
<span class="r-in"><span><span class="co"># the addition of the 'priors' argument</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># ========================================================================</span></span></span>
<span class="r-in"><span><span class="co"># Example 3: Use brms syntax for prior modification</span></span></span>
<span class="r-in"><span><span class="co"># ========================================================================</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># The same can be done using 'brms' functions; here we will also change</span></span></span>
<span class="r-in"><span><span class="co"># the ar1 prior and put some bounds on the ar coefficients to enforce</span></span></span>
<span class="r-in"><span><span class="co"># stationarity; we set the prior using the 'class' argument in all brms</span></span></span>
<span class="r-in"><span><span class="co"># prior functions</span></span></span>
<span class="r-in"><span><span class="va">brmsprior</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span></span></span>
<span class="r-in"><span>  <span class="fu"><a href="https://paulbuerkner.com/brms/reference/set_prior.html" class="external-link">prior</a></span><span class="op">(</span><span class="fu">normal</span><span class="op">(</span><span class="fl">0.2</span>, <span class="fl">0.5</span><span class="op">)</span>, class <span class="op">=</span> <span class="va">mu_raw</span><span class="op">)</span>,</span></span>
<span class="r-in"><span>  <span class="fu"><a href="https://paulbuerkner.com/brms/reference/set_prior.html" class="external-link">prior</a></span><span class="op">(</span><span class="fu">normal</span><span class="op">(</span><span class="fl">0</span>, <span class="fl">0.25</span><span class="op">)</span>, class <span class="op">=</span> <span class="va">ar1</span>, lb <span class="op">=</span> <span class="op">-</span><span class="fl">1</span>, ub <span class="op">=</span> <span class="fl">1</span><span class="op">)</span>,</span></span>
<span class="r-in"><span>  <span class="fu"><a href="https://paulbuerkner.com/brms/reference/set_prior.html" class="external-link">prior</a></span><span class="op">(</span><span class="fu">normal</span><span class="op">(</span><span class="fl">0</span>, <span class="fl">0.25</span><span class="op">)</span>, class <span class="op">=</span> <span class="va">ar2</span>, lb <span class="op">=</span> <span class="op">-</span><span class="fl">1</span>, ub <span class="op">=</span> <span class="fl">1</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="va">brmsprior</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             prior  class coef group resp dpar nlpar   lb   ub tag source</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  normal(0.2, 0.5) mu_raw                            &lt;NA&gt; &lt;NA&gt;       user</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   normal(0, 0.25)    ar1                              -1    1       user</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   normal(0, 0.25)    ar2                              -1    1       user</span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="va">mod</span> <span class="op">&lt;-</span> <span class="fu"><a href="mvgam.html">mvgam</a></span><span class="op">(</span></span></span>
<span class="r-in"><span>  <span class="va">y</span> <span class="op">~</span> <span class="fu"><a href="https://rdrr.io/pkg/mgcv/man/s.html" class="external-link">s</a></span><span class="op">(</span><span class="va">series</span>, bs <span class="op">=</span> <span class="st">"re"</span><span class="op">)</span> <span class="op">+</span> <span class="fu"><a href="https://rdrr.io/pkg/mgcv/man/s.html" class="external-link">s</a></span><span class="op">(</span><span class="va">season</span>, bs <span class="op">=</span> <span class="st">"cc"</span><span class="op">)</span> <span class="op">-</span> <span class="fl">1</span>,</span></span>
<span class="r-in"><span>  family <span class="op">=</span> <span class="fu"><a href="mvgam_families.html">nb</a></span><span class="op">(</span><span class="op">)</span>,</span></span>
<span class="r-in"><span>  data <span class="op">=</span> <span class="va">dat</span><span class="op">$</span><span class="va">data_train</span>,</span></span>
<span class="r-in"><span>  trend_model <span class="op">=</span> <span class="fu"><a href="RW.html">AR</a></span><span class="op">(</span>p <span class="op">=</span> <span class="fl">2</span><span class="op">)</span>,</span></span>
<span class="r-in"><span>  priors <span class="op">=</span> <span class="va">brmsprior</span>,</span></span>
<span class="r-in"><span>  run_model <span class="op">=</span> <span class="cn">FALSE</span></span></span>
<span class="r-in"><span><span class="op">)</span></span></span>
<span class="r-msg co"><span class="r-pr">#&gt;</span> Your model may benefit from using "noncentred = TRUE"</span>
<span class="r-in"><span><span class="fu"><a href="https://paulbuerkner.com/brms/reference/stancode.html" class="external-link">stancode</a></span><span class="op">(</span><span class="va">mod</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // Stan model code generated by package mvgam</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> functions {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector rep_each(vector x, int K) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     int N = rows(x);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     vector[N * K] y;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     int pos = 1;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     for (n in 1 : N) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       for (k in 1 : K) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         y[pos] = x[n];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         pos += 1;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     return y;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> data {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=0&gt; total_obs; // total number of observations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=0&gt; n; // number of timepoints per series</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=0&gt; n_sp; // number of smoothing parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=0&gt; n_series; // number of series</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=0&gt; num_basis; // total number of basis coefficients</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[num_basis] zero; // prior locations for basis coefficients</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[total_obs, num_basis] X; // mgcv GAM design matrix</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   array[n, n_series] int&lt;lower=0&gt; ytimes; // time-ordered matrix (which col in X belongs to each [time, series] observation?)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[8, 8] S1; // mgcv smooth penalty matrix S1</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=0&gt; n_nonmissing; // number of nonmissing observations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   array[n_nonmissing] int&lt;lower=0&gt; flat_ys; // flattened nonmissing observations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[n_nonmissing, num_basis] flat_xs; // X values for nonmissing observations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   array[n_nonmissing] int&lt;lower=0&gt; obs_ind; // indices of nonmissing observations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> parameters {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // raw basis coefficients</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[num_basis] b_raw;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // random effect variances</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector&lt;lower=0&gt;[1] sigma_raw;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // random effect means</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[1] mu_raw;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // negative binomial overdispersion</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector&lt;lower=0&gt;[n_series] phi_inv;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // latent trend AR1 terms</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector&lt;lower=-1, upper=1&gt;[n_series] ar1;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // latent trend AR2 terms</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector&lt;lower=-1, upper=1&gt;[n_series] ar2;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // latent trend variance parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector&lt;lower=0&gt;[n_series] sigma;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // latent trends</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[n, n_series] trend;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // smoothing parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector&lt;lower=0&gt;[n_sp] lambda;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> transformed parameters {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // basis coefficients</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[num_basis] b;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   b[1 : 8] = b_raw[1 : 8];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   b[9 : 11] = mu_raw[1] + b_raw[9 : 11] * sigma_raw[1];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> model {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // prior for random effect population variances</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   sigma_raw ~ inv_gamma(1.418, 0.452);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // prior for random effect population means</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   mu_raw ~ normal(0.2, 0.5);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // prior for s(season)...</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   b_raw[1 : 8] ~ multi_normal_prec(zero[1 : 8], S1[1 : 8, 1 : 8] * lambda[1]);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // prior (non-centred) for s(series)...</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   b_raw[9 : 11] ~ std_normal();</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // priors for AR parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   ar1 ~ normal(0, 0.25);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   ar2 ~ normal(0, 0.25);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // priors for smoothing parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   lambda ~ normal(5, 30);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // priors for overdispersion parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   phi_inv ~ student_t(3, 0, 0.1);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // priors for latent trend variance parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   sigma ~ inv_gamma(1.418, 0.452);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // trend estimates</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   trend[1, 1 : n_series] ~ normal(0, sigma);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   trend[2, 1 : n_series] ~ normal(trend[1, 1 : n_series] * ar1, sigma);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   for (s in 1 : n_series) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     trend[3 : n, s] ~ normal(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                              ar1[s] * trend[2 : (n - 1), s]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                              + ar2[s] * trend[1 : (n - 2), s], sigma[s]);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     // likelihood functions</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     vector[n_nonmissing] flat_trends;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     array[n_nonmissing] real flat_phis;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     flat_trends = to_vector(trend)[obs_ind];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     flat_phis = to_array_1d(rep_each(phi_inv, n)[obs_ind]);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     flat_ys ~ neg_binomial_2(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                              exp(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                                  append_col(flat_xs, flat_trends)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                                  * append_row(b, 1.0)),</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                              inv(flat_phis));</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> generated quantities {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[total_obs] eta;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[n, n_series] mus;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[n_sp] rho;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[n_series] tau;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   array[n, n_series] int ypred;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[n, n_series] phi_vec;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[n_series] phi;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   phi = inv(phi_inv);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   for (s in 1 : n_series) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     phi_vec[1 : n, s] = rep_vector(phi[s], n);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   rho = log(lambda);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   for (s in 1 : n_series) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     tau[s] = pow(sigma[s], -2.0);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // posterior predictions</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   eta = X * b;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   for (s in 1 : n_series) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     mus[1 : n, s] = eta[ytimes[1 : n, s]] + trend[1 : n, s];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     ypred[1 : n, s] = neg_binomial_2_rng(exp(mus[1 : n, s]), phi_vec[1 : n, s]);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># ========================================================================</span></span></span>
<span class="r-in"><span><span class="co"># Example 4: Error handling example</span></span></span>
<span class="r-in"><span><span class="co"># ========================================================================</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># Look at what is returned when an incorrect spelling is used</span></span></span>
<span class="r-in"><span><span class="va">test_priors</span><span class="op">$</span><span class="va">prior</span><span class="op">[</span><span class="fl">5</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="st">"ar2_bananas ~ normal(0, 0.25);"</span></span></span>
<span class="r-in"><span><span class="va">mod</span> <span class="op">&lt;-</span> <span class="fu"><a href="mvgam.html">mvgam</a></span><span class="op">(</span></span></span>
<span class="r-in"><span>  <span class="va">y</span> <span class="op">~</span> <span class="fu"><a href="https://rdrr.io/pkg/mgcv/man/s.html" class="external-link">s</a></span><span class="op">(</span><span class="va">series</span>, bs <span class="op">=</span> <span class="st">"re"</span><span class="op">)</span> <span class="op">+</span> <span class="fu"><a href="https://rdrr.io/pkg/mgcv/man/s.html" class="external-link">s</a></span><span class="op">(</span><span class="va">season</span>, bs <span class="op">=</span> <span class="st">"cc"</span><span class="op">)</span> <span class="op">-</span> <span class="fl">1</span>,</span></span>
<span class="r-in"><span>  family <span class="op">=</span> <span class="fu"><a href="mvgam_families.html">nb</a></span><span class="op">(</span><span class="op">)</span>,</span></span>
<span class="r-in"><span>  data <span class="op">=</span> <span class="va">dat</span><span class="op">$</span><span class="va">data_train</span>,</span></span>
<span class="r-in"><span>  trend_model <span class="op">=</span> <span class="fu"><a href="RW.html">AR</a></span><span class="op">(</span>p <span class="op">=</span> <span class="fl">2</span><span class="op">)</span>,</span></span>
<span class="r-in"><span>  priors <span class="op">=</span> <span class="va">test_priors</span>,</span></span>
<span class="r-in"><span>  run_model <span class="op">=</span> <span class="cn">FALSE</span></span></span>
<span class="r-in"><span><span class="op">)</span></span></span>
<span class="r-wrn co"><span class="r-pr">#&gt;</span> <span class="warning">Warning: </span>no match found in model_file for parameter: ar2_bananas</span>
<span class="r-msg co"><span class="r-pr">#&gt;</span> Your model may benefit from using "noncentred = TRUE"</span>
<span class="r-in"><span><span class="fu"><a href="https://paulbuerkner.com/brms/reference/stancode.html" class="external-link">stancode</a></span><span class="op">(</span><span class="va">mod</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // Stan model code generated by package mvgam</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> functions {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector rep_each(vector x, int K) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     int N = rows(x);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     vector[N * K] y;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     int pos = 1;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     for (n in 1 : N) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       for (k in 1 : K) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         y[pos] = x[n];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         pos += 1;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     return y;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> data {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=0&gt; total_obs; // total number of observations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=0&gt; n; // number of timepoints per series</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=0&gt; n_sp; // number of smoothing parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=0&gt; n_series; // number of series</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=0&gt; num_basis; // total number of basis coefficients</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[num_basis] zero; // prior locations for basis coefficients</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[total_obs, num_basis] X; // mgcv GAM design matrix</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   array[n, n_series] int&lt;lower=0&gt; ytimes; // time-ordered matrix (which col in X belongs to each [time, series] observation?)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[8, 8] S1; // mgcv smooth penalty matrix S1</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=0&gt; n_nonmissing; // number of nonmissing observations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   array[n_nonmissing] int&lt;lower=0&gt; flat_ys; // flattened nonmissing observations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[n_nonmissing, num_basis] flat_xs; // X values for nonmissing observations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   array[n_nonmissing] int&lt;lower=0&gt; obs_ind; // indices of nonmissing observations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> parameters {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // raw basis coefficients</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[num_basis] b_raw;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // random effect variances</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector&lt;lower=0&gt;[1] sigma_raw;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // random effect means</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[1] mu_raw;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // negative binomial overdispersion</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector&lt;lower=0&gt;[n_series] phi_inv;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // latent trend AR1 terms</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector&lt;lower=-1, upper=1&gt;[n_series] ar1;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // latent trend AR2 terms</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector&lt;lower=-1, upper=1&gt;[n_series] ar2;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // latent trend variance parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector&lt;lower=0&gt;[n_series] sigma;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // latent trends</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[n, n_series] trend;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // smoothing parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector&lt;lower=0&gt;[n_sp] lambda;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> transformed parameters {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // basis coefficients</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[num_basis] b;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   b[1 : 8] = b_raw[1 : 8];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   b[9 : 11] = mu_raw[1] + b_raw[9 : 11] * sigma_raw[1];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> model {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // prior for random effect population variances</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   sigma_raw ~ inv_gamma(1.418, 0.452);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // prior for random effect population means</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   mu_raw ~ normal(0.2, 0.5);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // prior for s(season)...</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   b_raw[1 : 8] ~ multi_normal_prec(zero[1 : 8], S1[1 : 8, 1 : 8] * lambda[1]);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // prior (non-centred) for s(series)...</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   b_raw[9 : 11] ~ std_normal();</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // priors for AR parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   ar1 ~ std_normal();</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   ar2 ~ std_normal();</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // priors for smoothing parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   lambda ~ normal(5, 30);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // priors for overdispersion parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   phi_inv ~ student_t(3, 0, 0.1);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // priors for latent trend variance parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   sigma ~ inv_gamma(1.418, 0.452);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // trend estimates</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   trend[1, 1 : n_series] ~ normal(0, sigma);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   trend[2, 1 : n_series] ~ normal(trend[1, 1 : n_series] * ar1, sigma);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   for (s in 1 : n_series) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     trend[3 : n, s] ~ normal(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                              ar1[s] * trend[2 : (n - 1), s]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                              + ar2[s] * trend[1 : (n - 2), s], sigma[s]);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     // likelihood functions</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     vector[n_nonmissing] flat_trends;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     array[n_nonmissing] real flat_phis;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     flat_trends = to_vector(trend)[obs_ind];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     flat_phis = to_array_1d(rep_each(phi_inv, n)[obs_ind]);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     flat_ys ~ neg_binomial_2(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                              exp(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                                  append_col(flat_xs, flat_trends)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                                  * append_row(b, 1.0)),</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                              inv(flat_phis));</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> generated quantities {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[total_obs] eta;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[n, n_series] mus;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[n_sp] rho;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[n_series] tau;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   array[n, n_series] int ypred;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[n, n_series] phi_vec;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[n_series] phi;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   phi = inv(phi_inv);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   for (s in 1 : n_series) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     phi_vec[1 : n, s] = rep_vector(phi[s], n);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   rho = log(lambda);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   for (s in 1 : n_series) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     tau[s] = pow(sigma[s], -2.0);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // posterior predictions</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   eta = X * b;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   for (s in 1 : n_series) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     mus[1 : n, s] = eta[ytimes[1 : n, s]] + trend[1 : n, s];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     ypred[1 : n, s] = neg_binomial_2_rng(exp(mus[1 : n, s]), phi_vec[1 : n, s]);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># ========================================================================</span></span></span>
<span class="r-in"><span><span class="co"># Example 5: Parametric (fixed effect) priors</span></span></span>
<span class="r-in"><span><span class="co"># ========================================================================</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="va">simdat</span> <span class="op">&lt;-</span> <span class="fu"><a href="sim_mvgam.html">sim_mvgam</a></span><span class="op">(</span><span class="op">)</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># Add a fake covariate</span></span></span>
<span class="r-in"><span><span class="va">simdat</span><span class="op">$</span><span class="va">data_train</span><span class="op">$</span><span class="va">cov</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/Normal.html" class="external-link">rnorm</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/nrow.html" class="external-link">NROW</a></span><span class="op">(</span><span class="va">simdat</span><span class="op">$</span><span class="va">data_train</span><span class="op">)</span><span class="op">)</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="va">priors</span> <span class="op">&lt;-</span> <span class="fu">get_mvgam_priors</span><span class="op">(</span></span></span>
<span class="r-in"><span>  <span class="va">y</span> <span class="op">~</span> <span class="va">cov</span> <span class="op">+</span> <span class="fu"><a href="https://rdrr.io/pkg/mgcv/man/s.html" class="external-link">s</a></span><span class="op">(</span><span class="va">season</span><span class="op">)</span>,</span></span>
<span class="r-in"><span>  data <span class="op">=</span> <span class="va">simdat</span><span class="op">$</span><span class="va">data_train</span>,</span></span>
<span class="r-in"><span>  family <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/family.html" class="external-link">poisson</a></span><span class="op">(</span><span class="op">)</span>,</span></span>
<span class="r-in"><span>  trend_model <span class="op">=</span> <span class="fu"><a href="RW.html">AR</a></span><span class="op">(</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="op">)</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># Change priors for the intercept and fake covariate effects</span></span></span>
<span class="r-in"><span><span class="va">priors</span><span class="op">$</span><span class="va">prior</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="st">"(Intercept) ~ normal(0, 1);"</span></span></span>
<span class="r-in"><span><span class="va">priors</span><span class="op">$</span><span class="va">prior</span><span class="op">[</span><span class="fl">2</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="st">"cov ~ normal(0, 0.1);"</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="va">mod2</span> <span class="op">&lt;-</span> <span class="fu"><a href="mvgam.html">mvgam</a></span><span class="op">(</span></span></span>
<span class="r-in"><span>  <span class="va">y</span> <span class="op">~</span> <span class="va">cov</span> <span class="op">+</span> <span class="fu"><a href="https://rdrr.io/pkg/mgcv/man/s.html" class="external-link">s</a></span><span class="op">(</span><span class="va">season</span><span class="op">)</span>,</span></span>
<span class="r-in"><span>  data <span class="op">=</span> <span class="va">simdat</span><span class="op">$</span><span class="va">data_train</span>,</span></span>
<span class="r-in"><span>  trend_model <span class="op">=</span> <span class="fu"><a href="RW.html">AR</a></span><span class="op">(</span><span class="op">)</span>,</span></span>
<span class="r-in"><span>  family <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/family.html" class="external-link">poisson</a></span><span class="op">(</span><span class="op">)</span>,</span></span>
<span class="r-in"><span>  priors <span class="op">=</span> <span class="va">priors</span>,</span></span>
<span class="r-in"><span>  run_model <span class="op">=</span> <span class="cn">FALSE</span></span></span>
<span class="r-in"><span><span class="op">)</span></span></span>
<span class="r-msg co"><span class="r-pr">#&gt;</span> Your model may benefit from using "noncentred = TRUE"</span>
<span class="r-in"><span><span class="fu"><a href="https://paulbuerkner.com/brms/reference/stancode.html" class="external-link">stancode</a></span><span class="op">(</span><span class="va">mod2</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // Stan model code generated by package mvgam</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> data {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=0&gt; total_obs; // total number of observations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=0&gt; n; // number of timepoints per series</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=0&gt; n_sp; // number of smoothing parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=0&gt; n_series; // number of series</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=0&gt; num_basis; // total number of basis coefficients</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[num_basis] zero; // prior locations for basis coefficients</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[total_obs, num_basis] X; // mgcv GAM design matrix</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   array[n, n_series] int&lt;lower=0&gt; ytimes; // time-ordered matrix (which col in X belongs to each [time, series] observation?)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[9, 18] S1; // mgcv smooth penalty matrix S1</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=0&gt; n_nonmissing; // number of nonmissing observations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   array[n_nonmissing] int&lt;lower=0&gt; flat_ys; // flattened nonmissing observations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[n_nonmissing, num_basis] flat_xs; // X values for nonmissing observations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   array[n_nonmissing] int&lt;lower=0&gt; obs_ind; // indices of nonmissing observations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> parameters {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // raw basis coefficients</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[num_basis] b_raw;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // latent trend AR1 terms</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector&lt;lower=-1, upper=1&gt;[n_series] ar1;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // latent trend variance parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector&lt;lower=0&gt;[n_series] sigma;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // latent trends</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[n, n_series] trend;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // smoothing parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector&lt;lower=0&gt;[n_sp] lambda;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> transformed parameters {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // basis coefficients</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[num_basis] b;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   b[1 : num_basis] = b_raw[1 : num_basis];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> model {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // prior for (Intercept)...</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   b_raw[1] ~ normal(0, 1);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // prior for cov...</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   b_raw[2] ~ normal(0, 0.1);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // prior for s(season)...</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   b_raw[3 : 11] ~ multi_normal_prec(zero[3 : 11],</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                     S1[1 : 9, 1 : 9] * lambda[1]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                     + S1[1 : 9, 10 : 18] * lambda[2]);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // priors for AR parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   ar1 ~ std_normal();</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // priors for smoothing parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   lambda ~ normal(5, 30);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // priors for latent trend variance parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   sigma ~ inv_gamma(1.418, 0.452);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // trend estimates</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   trend[1, 1 : n_series] ~ normal(0, sigma);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   for (s in 1 : n_series) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     trend[2 : n, s] ~ normal(ar1[s] * trend[1 : (n - 1), s], sigma[s]);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     // likelihood functions</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     vector[n_nonmissing] flat_trends;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     flat_trends = to_vector(trend)[obs_ind];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     flat_ys ~ poisson_log_glm(append_col(flat_xs, flat_trends), 0.0,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                               append_row(b, 1.0));</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> generated quantities {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[total_obs] eta;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[n, n_series] mus;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[n_sp] rho;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[n_series] tau;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   array[n, n_series] int ypred;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   rho = log(lambda);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   for (s in 1 : n_series) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     tau[s] = pow(sigma[s], -2.0);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // posterior predictions</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   eta = X * b;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   for (s in 1 : n_series) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     mus[1 : n, s] = eta[ytimes[1 : n, s]] + trend[1 : n, s];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     ypred[1 : n, s] = poisson_log_rng(mus[1 : n, s]);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># ========================================================================</span></span></span>
<span class="r-in"><span><span class="co"># Example 6: Alternative brms syntax for fixed effects</span></span></span>
<span class="r-in"><span><span class="co"># ========================================================================</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># Likewise using 'brms' utilities (note that you can use Intercept rather</span></span></span>
<span class="r-in"><span><span class="co"># than `(Intercept)`) to change priors on the intercept</span></span></span>
<span class="r-in"><span><span class="va">brmsprior</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span></span></span>
<span class="r-in"><span>  <span class="fu"><a href="https://paulbuerkner.com/brms/reference/set_prior.html" class="external-link">prior</a></span><span class="op">(</span><span class="fu">normal</span><span class="op">(</span><span class="fl">0.2</span>, <span class="fl">0.5</span><span class="op">)</span>, class <span class="op">=</span> <span class="va">cov</span><span class="op">)</span>,</span></span>
<span class="r-in"><span>  <span class="fu"><a href="https://paulbuerkner.com/brms/reference/set_prior.html" class="external-link">prior</a></span><span class="op">(</span><span class="fu">normal</span><span class="op">(</span><span class="fl">0</span>, <span class="fl">0.25</span><span class="op">)</span>, class <span class="op">=</span> <span class="va">Intercept</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="va">brmsprior</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             prior     class coef group resp dpar nlpar   lb   ub tag source</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  normal(0.2, 0.5)       cov                            &lt;NA&gt; &lt;NA&gt;       user</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   normal(0, 0.25) Intercept                            &lt;NA&gt; &lt;NA&gt;       user</span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="va">mod2</span> <span class="op">&lt;-</span> <span class="fu"><a href="mvgam.html">mvgam</a></span><span class="op">(</span></span></span>
<span class="r-in"><span>  <span class="va">y</span> <span class="op">~</span> <span class="va">cov</span> <span class="op">+</span> <span class="fu"><a href="https://rdrr.io/pkg/mgcv/man/s.html" class="external-link">s</a></span><span class="op">(</span><span class="va">season</span><span class="op">)</span>,</span></span>
<span class="r-in"><span>  data <span class="op">=</span> <span class="va">simdat</span><span class="op">$</span><span class="va">data_train</span>,</span></span>
<span class="r-in"><span>  trend_model <span class="op">=</span> <span class="fu"><a href="RW.html">AR</a></span><span class="op">(</span><span class="op">)</span>,</span></span>
<span class="r-in"><span>  family <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/family.html" class="external-link">poisson</a></span><span class="op">(</span><span class="op">)</span>,</span></span>
<span class="r-in"><span>  priors <span class="op">=</span> <span class="va">brmsprior</span>,</span></span>
<span class="r-in"><span>  run_model <span class="op">=</span> <span class="cn">FALSE</span></span></span>
<span class="r-in"><span><span class="op">)</span></span></span>
<span class="r-msg co"><span class="r-pr">#&gt;</span> Your model may benefit from using "noncentred = TRUE"</span>
<span class="r-in"><span><span class="fu"><a href="https://paulbuerkner.com/brms/reference/stancode.html" class="external-link">stancode</a></span><span class="op">(</span><span class="va">mod2</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // Stan model code generated by package mvgam</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> data {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=0&gt; total_obs; // total number of observations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=0&gt; n; // number of timepoints per series</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=0&gt; n_sp; // number of smoothing parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=0&gt; n_series; // number of series</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=0&gt; num_basis; // total number of basis coefficients</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[num_basis] zero; // prior locations for basis coefficients</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[total_obs, num_basis] X; // mgcv GAM design matrix</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   array[n, n_series] int&lt;lower=0&gt; ytimes; // time-ordered matrix (which col in X belongs to each [time, series] observation?)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[9, 18] S1; // mgcv smooth penalty matrix S1</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=0&gt; n_nonmissing; // number of nonmissing observations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   array[n_nonmissing] int&lt;lower=0&gt; flat_ys; // flattened nonmissing observations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[n_nonmissing, num_basis] flat_xs; // X values for nonmissing observations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   array[n_nonmissing] int&lt;lower=0&gt; obs_ind; // indices of nonmissing observations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> parameters {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // raw basis coefficients</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[num_basis] b_raw;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // latent trend AR1 terms</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector&lt;lower=-1, upper=1&gt;[n_series] ar1;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // latent trend variance parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector&lt;lower=0&gt;[n_series] sigma;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // latent trends</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[n, n_series] trend;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // smoothing parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector&lt;lower=0&gt;[n_sp] lambda;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> transformed parameters {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // basis coefficients</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[num_basis] b;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   b[1 : num_basis] = b_raw[1 : num_basis];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> model {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // prior for (Intercept)...</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   b_raw[1] ~ normal(0, 0.25);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // prior for cov...</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   b_raw[2] ~ normal(0.2, 0.5);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // prior for s(season)...</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   b_raw[3 : 11] ~ multi_normal_prec(zero[3 : 11],</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                     S1[1 : 9, 1 : 9] * lambda[1]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                     + S1[1 : 9, 10 : 18] * lambda[2]);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // priors for AR parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   ar1 ~ std_normal();</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // priors for smoothing parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   lambda ~ normal(5, 30);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // priors for latent trend variance parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   sigma ~ inv_gamma(1.418, 0.452);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // trend estimates</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   trend[1, 1 : n_series] ~ normal(0, sigma);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   for (s in 1 : n_series) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     trend[2 : n, s] ~ normal(ar1[s] * trend[1 : (n - 1), s], sigma[s]);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     // likelihood functions</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     vector[n_nonmissing] flat_trends;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     flat_trends = to_vector(trend)[obs_ind];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     flat_ys ~ poisson_log_glm(append_col(flat_xs, flat_trends), 0.0,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                               append_row(b, 1.0));</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> generated quantities {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[total_obs] eta;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[n, n_series] mus;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[n_sp] rho;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[n_series] tau;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   array[n, n_series] int ypred;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   rho = log(lambda);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   for (s in 1 : n_series) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     tau[s] = pow(sigma[s], -2.0);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // posterior predictions</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   eta = X * b;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   for (s in 1 : n_series) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     mus[1 : n, s] = eta[ytimes[1 : n, s]] + trend[1 : n, s];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     ypred[1 : n, s] = poisson_log_rng(mus[1 : n, s]);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># ========================================================================</span></span></span>
<span class="r-in"><span><span class="co"># Example 7: Bulk prior assignment</span></span></span>
<span class="r-in"><span><span class="co"># ========================================================================</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># The "class = 'b'" shortcut can be used to put the same prior on all</span></span></span>
<span class="r-in"><span><span class="co"># 'fixed' effect coefficients (apart from any intercepts)</span></span></span>
<span class="r-in"><span><span class="fu"><a href="https://rdrr.io/r/base/Random.html" class="external-link">set.seed</a></span><span class="op">(</span><span class="fl">0</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="va">dat</span> <span class="op">&lt;-</span> <span class="fu">mgcv</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/pkg/mgcv/man/gamSim.html" class="external-link">gamSim</a></span><span class="op">(</span><span class="fl">1</span>, n <span class="op">=</span> <span class="fl">200</span>, scale <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Gu &amp; Wahba 4 term additive model</span>
<span class="r-in"><span><span class="va">dat</span><span class="op">$</span><span class="va">time</span> <span class="op">&lt;-</span> <span class="fl">1</span><span class="op">:</span><span class="fu"><a href="https://rdrr.io/r/base/nrow.html" class="external-link">NROW</a></span><span class="op">(</span><span class="va">dat</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="va">mod</span> <span class="op">&lt;-</span> <span class="fu"><a href="mvgam.html">mvgam</a></span><span class="op">(</span></span></span>
<span class="r-in"><span>  <span class="va">y</span> <span class="op">~</span> <span class="va">x0</span> <span class="op">+</span> <span class="va">x1</span> <span class="op">+</span> <span class="fu"><a href="https://rdrr.io/pkg/mgcv/man/s.html" class="external-link">s</a></span><span class="op">(</span><span class="va">x2</span><span class="op">)</span> <span class="op">+</span> <span class="fu"><a href="https://rdrr.io/pkg/mgcv/man/s.html" class="external-link">s</a></span><span class="op">(</span><span class="va">x3</span><span class="op">)</span>,</span></span>
<span class="r-in"><span>  priors <span class="op">=</span> <span class="fu"><a href="https://paulbuerkner.com/brms/reference/set_prior.html" class="external-link">prior</a></span><span class="op">(</span><span class="fu">normal</span><span class="op">(</span><span class="fl">0</span>, <span class="fl">0.75</span><span class="op">)</span>, class <span class="op">=</span> <span class="st">"b"</span><span class="op">)</span>,</span></span>
<span class="r-in"><span>  data <span class="op">=</span> <span class="va">dat</span>,</span></span>
<span class="r-in"><span>  family <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/family.html" class="external-link">gaussian</a></span><span class="op">(</span><span class="op">)</span>,</span></span>
<span class="r-in"><span>  run_model <span class="op">=</span> <span class="cn">FALSE</span></span></span>
<span class="r-in"><span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="fu"><a href="https://paulbuerkner.com/brms/reference/stancode.html" class="external-link">stancode</a></span><span class="op">(</span><span class="va">mod</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // Stan model code generated by package mvgam</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> functions {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector rep_each(vector x, int K) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     int N = rows(x);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     vector[N * K] y;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     int pos = 1;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     for (n in 1 : N) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       for (k in 1 : K) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         y[pos] = x[n];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         pos += 1;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     return y;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> data {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=0&gt; total_obs; // total number of observations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=0&gt; n; // number of timepoints per series</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=0&gt; n_sp; // number of smoothing parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=0&gt; n_series; // number of series</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=0&gt; num_basis; // total number of basis coefficients</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[num_basis] zero; // prior locations for basis coefficients</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[total_obs, num_basis] X; // mgcv GAM design matrix</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   array[n, n_series] int&lt;lower=0&gt; ytimes; // time-ordered matrix (which col in X belongs to each [time, series] observation?)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[9, 18] S1; // mgcv smooth penalty matrix S1</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[9, 18] S2; // mgcv smooth penalty matrix S2</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=0&gt; n_nonmissing; // number of nonmissing observations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[n_nonmissing] flat_ys; // flattened nonmissing observations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[n_nonmissing, num_basis] flat_xs; // X values for nonmissing observations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   array[n_nonmissing] int&lt;lower=0&gt; obs_ind; // indices of nonmissing observations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> parameters {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // raw basis coefficients</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[num_basis] b_raw;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // gaussian observation error</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector&lt;lower=0&gt;[n_series] sigma_obs;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // smoothing parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector&lt;lower=0&gt;[n_sp] lambda;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> transformed parameters {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // basis coefficients</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[num_basis] b;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   b[1 : num_basis] = b_raw[1 : num_basis];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> model {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // prior for (Intercept)...</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   b_raw[1] ~ student_t(3, 7.4, 3.7);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // prior for x0...</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   b_raw[2] ~ normal(0, 0.75);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // prior for x1...</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   b_raw[3] ~ normal(0, 0.75);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // prior for s(x2)...</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   b_raw[4 : 12] ~ multi_normal_prec(zero[4 : 12],</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                     S1[1 : 9, 1 : 9] * lambda[1]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                     + S1[1 : 9, 10 : 18] * lambda[2]);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // prior for s(x3)...</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   b_raw[13 : 21] ~ multi_normal_prec(zero[13 : 21],</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                      S2[1 : 9, 1 : 9] * lambda[3]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                      + S2[1 : 9, 10 : 18] * lambda[4]);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // priors for smoothing parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   lambda ~ normal(5, 30);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // priors for observation error parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   sigma_obs ~ inv_gamma(1.418, 0.452);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     // likelihood functions</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     vector[n_nonmissing] flat_sigma_obs;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     flat_sigma_obs = rep_each(sigma_obs, n)[obs_ind];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     flat_ys ~ normal_id_glm(flat_xs, 0.0, b, flat_sigma_obs);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> generated quantities {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[total_obs] eta;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[n, n_series] sigma_obs_vec;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[n, n_series] mus;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[n_sp] rho;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   array[n, n_series] real ypred;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   rho = log(lambda);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // posterior predictions</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   eta = X * b;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   for (s in 1 : n_series) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     sigma_obs_vec[1 : n, s] = rep_vector(sigma_obs[s], n);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   for (s in 1 : n_series) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     mus[1 : n, s] = eta[ytimes[1 : n, s]];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     ypred[1 : n, s] = normal_rng(mus[1 : n, s], sigma_obs_vec[1 : n, s]);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-in"><span><span class="co"># }</span></span></span>
<span class="r-in"><span></span></span>
</code></pre></div>
    </div>
  </main><aside class="col-md-3"><nav id="toc"><h2>On this page</h2>
    </nav></aside></div>


    <footer><div class="pkgdown-footer-left">
  <p>Developed by <a href="https://researchers.uq.edu.au/researcher/15140" class="external-link">Nicholas J Clark</a>.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.0.9.</p>
</div>

    </footer></div>

  

  

  </body></html>

