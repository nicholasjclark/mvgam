% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/trend_system.R
\name{mvgam_trend_specification}
\alias{mvgam_trend_specification}
\title{Enhanced mvgam_trend Object Field Specification}
\description{
Comprehensive documentation of required and optional fields for the enhanced
mvgam_trend S3 class structure. This specification enables self-contained
trend objects that provide all necessary information for validation,
Stan code generation, and post-processing without external lookups.
}
\section{Core Required Fields}{

\describe{
\item{trend}{Character string. Normalized trend type name for stanvar
generation dispatch. Examples: "AR", "VAR", "RW", "CAR", "PW", "ZMVN".
Used in convention-based lookup: "AR" → generate_ar_trend_stanvars()}
\item{time}{Character string. Name of time variable in user's data.
Default "time" with warning when not explicitly specified.}
\item{series}{Character string. Name of series identifier variable in data.
Default "series" with warning when not explicitly specified.}
\item{class}{Must include "mvgam_trend" for method dispatch.}
}
}

\section{Self-Contained Validation Fields}{

\describe{
\item{validation_rules}{Character vector. Validation rules this trend requires.
Replaces hard-coded conditionals throughout validation functions.
Must use approved strings from validation_rule_vocabulary.
Examples: c("requires_regular_intervals", "supports_factors", "supports_hierarchical")}
}
}

\section{Self-Contained Parameter Monitoring Fields}{

\describe{
\item{monitor_params}{Character vector. Stan parameters to track post-fit.
Automatically includes response suffixes in multivariate contexts.
Examples: c("ar1_trend", "sigma_trend", "L_Omega_trend")}
\item{tpars}{Character vector. All trend-specific parameter names with
"_trend" suffix for Stan compatibility. Generated from param_info.}
\item{bounds}{Named list. Parameter bounds for prior specification.
Format: list(ar1_trend = c(-1, 1), sigma_trend = c(0, Inf))}
}
}

\section{Self-Contained Forecasting Metadata Fields}{

\describe{
\item{forecast_metadata}{List. Complete forecasting function information:
\itemize{
\item{function_name}{Character. Forecasting function name (e.g., "forecast_ar_rcpp")}
\item{required_args}{Character vector. Required arguments from fitted model}
\item{max_horizon}{Integer. Maximum forecasting steps supported}
\item{dependencies}{Character vector. Requirements like "needs_last_state"}
}}
}
}

\section{Configuration Parameters (Trend-Specific)}{

\describe{
\item{p}{Integer or vector. Order parameter for AR/VAR models.
Examples: 1 (AR1), c(1,12) (seasonal AR), 2 (VAR2)}
\item{ma}{Logical. Whether moving average terms are included.}
\item{cor}{Logical. Whether correlation structure is enabled.
VAR models always set this to TRUE for optimal performance.}
\item{gr}{Character string. Grouping variable name for hierarchical models.
"NA" indicates no grouping.}
\item{subgr}{Character string. Subgrouping variable name.
Default "series" but can be customized for hierarchical models.}
\item{n_lv}{Integer. Number of latent variables for factor models.
Only allowed when validation_rules includes "supports_factors".}
\item{cap}{Character string. Carrying capacity variable for logistic growth.
Required for PW models with growth = "logistic".}
\item{growth}{Character string. Growth type for piecewise models:
"linear" or "logistic".}
\item{n_changepoints}{Integer. Number of changepoints for piecewise models.}
\item{changepoint_range}{Numeric. Proportion of history for changepoints.}
\item{changepoint_scale}{Numeric. Scale parameter for changepoint priors.}
}
}

\section{Display and Documentation Fields}{

\describe{
\item{label}{Character string. Human-readable description for printing.
Auto-generated from trend type and parameters if not provided.}
\item{summary_labels}{List. Naming patterns for parameter summaries:
\itemize{
\item{parameter_labels}{List mapping parameter names to display labels}
\item{factor_labels}{List for factor loading label patterns}
\item{group_labels}{List for hierarchical parameter labels}
}}
}
}

\section{Internal Processing Fields}{

\describe{
\item{param_info}{List containing:
\itemize{
\item{parameters}{trend_param object with complete specifications}
\item{characteristics}{List of trend capabilities and settings}
}}
\item{shared_innovations}{Logical. Whether trend uses shared Gaussian
innovation system (TRUE) or handles own innovations (FALSE).
Most trends use shared system; exceptions: CAR, VAR, PW.}
\item{dimensions}{List. Pre-calculated time series dimensions (populated during validation):
\itemize{
\item{n_time}{Integer. Number of time points}
\item{n_series}{Integer. Number of series}
\item{n_obs}{Integer. Total observations}
\item{time_var}{Character. Time variable name}
\item{series_var}{Character. Series variable name}
\item{time_range}{Numeric vector. c(min_time, max_time)}
\item{unique_times}{Vector. All unique time values}
}}
\item{response_context}{Character string. Response name for multivariate models.
NULL for univariate models, populated during multivariate parsing.}
}
}

\section{Field Relationships and Validation Rules}{

The validation_rules field determines which other fields are valid:
\itemize{
\item{"supports_factors" + n_lv}: Factor models allowed
\item{"incompatible_with_factors" + n_lv}: Error thrown
\item{"supports_hierarchical" + gr/subgr}: Hierarchical models allowed
\item{"requires_regular_intervals"}: Regular time validation triggered
\item{"allows_irregular_intervals"}: CAR-style irregular time handling
}
}

\section{Convention-Based Function Dispatch}{

The trend field enables automatic function lookup:
\itemize{
\item{Stan generation}: "AR" → generate_ar_trend_stanvars()
\item{Forecasting}: forecast_metadata$function_name → that function
\item{No manual registry entries needed}
}
}

\section{Response Suffix Handling (Multivariate)}{

In multivariate contexts, certain fields are automatically modified:
\itemize{
\item{monitor_params}: "_count", "_biomass" suffixes added to parameter names
\item{summary_labels}: Response-specific labels generated automatically
\item{response_context}: Set to response name for tracking
}
}

\section{Backward Compatibility}{

During transition period, old fields may still be present:
\itemize{
\item{trend_model}: Legacy field, use trend instead
\item{trend_type}: Legacy field, use trend instead
\item{forecast_fun}: Legacy field, use forecast_metadata$function_name
\item{stancode_fun}: Legacy field, replaced by convention-based lookup
\item{standata_fun}: Legacy field, replaced by convention-based lookup
}
}

\section{Class Structure Requirements}{

Objects must:
\itemize{
\item{Have class c("mvgam_trend")}
\item{Pass validate_mvgam_trend() checks}
\item{Include all required core fields}
\item{Use approved validation_rules vocabulary}
\item{Have consistent field types and relationships}
}
}

\section{Example Complete Object}{

\preformatted{
ar_trend <- structure(list(
  # Core required fields
  trend = "AR",
  time = "time",
  series = "series",

  # Self-contained validation
  validation_rules = c(
    "requires_regular_intervals",
    "supports_factors",
    "supports_hierarchical"
  ),

  # Self-contained monitoring
  monitor_params = c("ar1_trend", "sigma_trend"),
  tpars = c("ar1_trend"),
  bounds = list(ar1_trend = c(-1, 1)),

  # Self-contained forecasting
  forecast_metadata = list(
    function_name = "forecast_ar_rcpp",
    required_args = c("ar_coefficients", "last_state"),
    max_horizon = Inf,
    dependencies = c("needs_ar_coeffs")
  ),

  # Configuration
  p = 1, ma = FALSE, cor = FALSE, n_lv = NULL,

  # Auto-generated during processing
  label = "AR1",
  shared_innovations = TRUE,
  param_info = list(...)
), class = "mvgam_trend")
}
}

\section{Design Principles}{

\itemize{
\item{Self-contained}: Each object contains all needed metadata}
\item{Convention-based}: Minimal configuration, maximum automation}
\item{Extensible}: New fields can be added without breaking existing trends}
\item{Validated}: Structure enforced through validate_mvgam_trend()}
\item{Consistent}: All trends follow identical patterns}
}
}

\author{
Nicholas J Clark
}
