% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/get_mvgam_priors.R
\name{get_mvgam_priors}
\alias{get_mvgam_priors}
\title{Extract information on default prior distributions for an mvgam model}
\usage{
get_mvgam_priors(
  formula,
  trend_formula,
  data,
  data_train,
  family = "poisson",
  use_lv = FALSE,
  n_lv,
  use_stan = TRUE,
  trend_model = "None",
  trend_map,
  drift = FALSE
)
}
\arguments{
\item{formula}{A \code{character} string specifying the GAM formula. These are exactly like the formula
for a GLM except that smooth terms, s, te, ti and t2, can be added to the right hand side
to specify that the linear predictor depends on smooth functions of predictors (or linear functionals of these)}

\item{trend_formula}{An optional \code{character} string specifying the GAM process model formula. If
supplied, a linear predictor will be modelled for the latent trends to capture process model evolution
separately from the observation model. Should not have a response variable specified on the left-hand side
of the formula (i.e. a valid option would be \code{~ season + s(year)}). This feature is experimental, and is only
currently available for Random Walk trend models.}

\item{data}{A \code{dataframe} or \code{list} containing the model response variable and covariates
required by the GAM \code{formula}. Should include columns:
\code{series} (character or factor index of the series IDs; if a factor, the number of levels should be identical
to the number of unique series labels)
\code{time} (numeric index of the time point for each observation).
Any other variables to be included in the linear predictor of \code{formula} must also be present}

\item{data_train}{Deprecated. Still works in place of \code{data} but users are recommended to use
\code{data} instead for more seamless integration into \code{R} workflows}

\item{family}{\code{family} specifying the exponential observation family for the series. Currently supported
families are:
\itemize{
\item\code{nb()} for count data
\item\code{poisson()} for count data
\item\code{tweedie()} for count data (power parameter \code{p} fixed at \code{1.5})
\item\code{gaussian()} for real-valued data
\item\code{betar()} for proportional data on \verb{(0,1)}
\item\code{lognormal()} for non-negative real-valued data
\item\code{student_t()} for real-valued data
\item\code{Gamma()} for non-negative real-valued data}
See \code{\link{mvgam_families}} for more details}

\item{use_lv}{\code{logical}. If \code{TRUE}, use dynamic factors to estimate series'
latent trends in a reduced dimension format. If \code{FALSE}, estimate independent latent trends for each series}

\item{n_lv}{\code{integer} the number of latent dynamic factors to use if \code{use_lv == TRUE}.
Cannot be \code{>n_series}. Defaults arbitrarily to \code{min(2, floor(n_series / 2))}}

\item{use_stan}{Logical. If \code{TRUE} and if \code{rstan} is installed, the model will be compiled and sampled using
the Hamiltonian Monte Carlo with a call to \code{\link[cmdstanr]{cmdstan_model}} or, if \code{cmdstanr} is not available,
a call to \code{\link[rstan]{stan}}. Note that this functionality is still in development and
not all options that are available in \code{JAGS} can be used, including: no option for a Tweedie family and no option for
dynamic factor trends. However, as \code{Stan} can estimate Hilbert base approximate Gaussian Processes, which
are much more computationally tractable than full GPs for time series with \verb{>100} observations, estimation
in \code{Stan} can support latent GP trends while estimation in \code{JAGS} cannot}

\item{trend_model}{\code{character} specifying the time series dynamics for the latent trend. Options are:
\itemize{
\item \code{None} (no latent trend component; i.e. the GAM component is all that contributes to the linear predictor,
and the observation process is the only source of error; similarly to what is estimated by \code{\link[mgcv]{gam}})
\item \code{RW} (random walk with possible drift)
\item \code{AR1} (with possible drift)
\item \code{AR2} (with possible drift)
\item \code{AR3} (with possible drift)
\item \code{VAR1} (contemporaneously uncorrelated VAR1; only available in \code{Stan})
\item \code{VAR1cor} (contemporaneously correlated VAR1; only available in \code{Stan})
\item \code{GP} (Gaussian Process with squared exponential kernel;
only available in \code{Stan})} See \link{mvgam_trends} for more details}

\item{trend_map}{Optional \code{data.frame} specifying which series should depend on which latent
trends. Useful for allowing multiple series to depend on the same latent trend process, but with
different observation processes. If supplied, a latent factor model is set up by setting
\code{use_lv = TRUE} and using the mapping to set up the shared trends. Needs to have column names
\code{series} and \code{trend}, with integer values in the \code{trend} column to state which trend each series
should depend on. The \code{series} column should have a single unique entry for each series in the
data (names should perfectly match factor levels of the \code{series} variable in \code{data}). See examples
in \code{\link{mvgam}} for details}

\item{drift}{\code{logical} estimate a drift parameter in the latent trend components. Useful if the latent
trend is expected to broadly follow a non-zero slope. Note that if the latent trend is more or less stationary,
the drift parameter can become unidentifiable, especially if an intercept term is included in the GAM linear
predictor (which it is by default when calling \code{\link[mgcv]{jagam}}). Therefore this defaults to \code{FALSE}}
}
\value{
either a \code{data.frame} containing the prior definitions (if any suitable
priors can be altered by the user) or \code{NULL}, indicating that no priors in the model
can be modified through the \code{mvgam} interface
}
\description{
This function lists the parameters that can have their prior distributions
changed for a given \code{mvgam} model, as well listing their default distributions
}
\details{
Users can supply a model formula, prior to fitting the model, so that default priors can be inspected and
altered. To make alterations, change the contents of the \code{prior} column and supplying this
\code{data.frame} to the \code{mvgam} function using the argument \code{priors}. If using \code{Stan} as the backend,
users can also modify the parameter bounds by modifying the \code{new_lowerbound} and/or \code{new_upperbound} columns.
This will be necessary if using restrictive distributions on some parameters, such as a Beta distribution
for the trend sd parameters for example (Beta only has support on  \code{(0,1)}), so the upperbound cannot
be above \code{1}. Another option is to make use of the prior modification functions in \code{brms}
(i.e. \code{\link[brms]{prior}}) to change prior distributions and bounds (just use the name of the parameter that
you'd like to change as the \code{class} argument; see examples below)
}
\note{
Only the \code{prior}, \code{new_lowerbound} and/or \code{new_upperbound} columns of the output
should be altered when defining the user-defined priors for the \code{mvgam} model. Use only if you are
familiar with the underlying probabilistic programming language. There are no sanity checks done to
ensure that the code is legal (i.e. to check that lower bounds are smaller than upper bounds, for
example)
}
\examples{
# Simulate three integer-valued time series
library(mvgam)
dat <- sim_mvgam(trend_rel = 0.5)

# Get a model file that uses default mvgam priors for inspection (not always necessary,
# but this can be useful for testing whether your updated priors are written correctly)
mod_default <- mvgam(y ~ s(series, bs = 're') +
              s(season, bs = 'cc') - 1,
              family = 'nb',
              data = dat$data_train,
              trend_model = 'AR2',
              run_model = FALSE)

# Inspect the model file with default mvgam priors
code(mod_default)

# Look at which priors can be updated in mvgam
test_priors <- get_mvgam_priors(y ~ s(series, bs = 're') +
                              s(season, bs = 'cc') - 1,
                              family = 'nb',
                              data = dat$data_train,
                              trend_model = 'AR2')
test_priors

# Make a few changes; first, change the population mean for the series-level
# random intercepts
test_priors$prior[2] <- 'mu_raw ~ normal(0.2, 0.5);'

# Now use stronger regularisation for the series-level AR2 coefficients
test_priors$prior[5] <- 'ar2 ~ normal(0, 0.25);'

# Check that the changes are made to the model file without any warnings by
# setting 'run_model = FALSE'
mod <- mvgam(y ~ s(series, bs = 're') +
            s(season, bs = 'cc') - 1,
            family = 'nb',
            data = dat$data_train,
            trend_model = 'AR2',
            priors = test_priors,
            run_model = FALSE)
            code(mod)

# No warnings, the model is ready for fitting now in the usual way with the addition
# of the 'priors' argument

# The same can be done using brms functions; here we will also change the ar1 prior
# and put some bounds on the ar coefficients to enforce stationarity; we set the
# prior using the 'class' argument in all brms prior functions
brmsprior <- c(prior(normal(0.2, 0.5), class = mu_raw),
              prior(normal(0, 0.25), class = ar1, lb = -1, ub = 1),
              prior(normal(0, 0.25), class = ar2, lb = -1, ub = 1))
brmsprior

mod <- mvgam(y ~ s(series, bs = 're') +
            s(season, bs = 'cc') - 1,
          family = 'nb',
          data = dat$data_train,
          trend_model = 'AR2',
          priors = brmsprior,
          run_model = FALSE)
code(mod)

# Look at what is returned when an incorrect spelling is used
test_priors$prior[5] <- 'ar2_bananas ~ normal(0, 0.25);'
mod <- mvgam(y ~ s(series, bs = 're') +
            s(season, bs = 'cc') - 1,
            family = 'nb',
            data = dat$data_train,
            trend_model = 'AR2',
            priors = test_priors,
            run_model = FALSE)
code(mod)

# Example of changing parametric (fixed effect) priors
simdat <- sim_mvgam()

# Add a fake covariate
simdat$data_train$cov <- rnorm(NROW(simdat$data_train))

priors <- get_mvgam_priors(y ~ cov + s(season),
                          data = simdat$data_train,
                          family = poisson(),
                          trend_model = 'AR1')

# Change priors for the intercept and fake covariate effects
priors$prior[1] <- '(Intercept) ~ normal(0, 1);'
priors$prior[2] <- 'cov ~ normal(0, 0.1);'

mod2 <- mvgam(y ~ cov + s(season),
             data = simdat$data_train,
             trend_model = 'AR1',
             family = poisson(),
             priors = priors,
             run_model = FALSE)
code(mod2)

# Likewise using brms utilities (note that you can use
# Intercept rather than `(Intercept)`) to change priors on the intercept
brmsprior <- c(prior(normal(0.2, 0.5), class = cov),
              prior(normal(0, 0.25), class = Intercept))
brmsprior

mod2 <- mvgam(y ~ cov + s(season),
             data = simdat$data_train,
             trend_model = 'AR1',
             family = poisson(),
             priors = brmsprior,
             run_model = FALSE)
code(mod2)

}
\seealso{
\code{\link{mvgam}}
}
\author{
Nicholas J Clark
}
