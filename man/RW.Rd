% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/trend_system.R
\name{RW}
\alias{RW}
\alias{AR}
\alias{CAR}
\alias{VAR}
\title{Specify autoregressive dynamic processes in \pkg{mvgam}}
\usage{
RW(
  time = NA,
  series = NA,
  ma = FALSE,
  cor = FALSE,
  gr = NA,
  subgr = NA,
  n_lv = NULL
)

AR(
  time = NA,
  series = NA,
  p = 1,
  ma = FALSE,
  cor = FALSE,
  gr = NA,
  subgr = NA,
  n_lv = NULL
)

CAR(time = NA, series = NA, p = 1, n_lv = NULL)

VAR(
  time = NA,
  series = NA,
  p = 1,
  ma = FALSE,
  gr = NA,
  subgr = NA,
  n_lv = NULL
)
}
\arguments{
\item{time}{The unquoted name of the variable that represents time in the
supplied \code{data}. This variable should be either a \code{numeric} or \code{integer}
variable. Defaults to \code{time} to align with brms conventions, allowing
flexible time variable naming without requiring explicit "time" columns.
When using the default, a one-time warning will be issued.}

\item{series}{The unquoted name of the variable that represents the series
identifier in the supplied \code{data}. This variable should be either a
\code{character} or \code{factor} variable. Defaults to \code{series} following mvgam
conventions, allowing flexible series variable naming. When using the
default, a one-time warning will be issued.}

\item{ma}{\code{Logical}. Include moving average terms of order \code{1}?
Default is \code{FALSE}.}

\item{cor}{\code{Logical}. Include correlated process errors as part of a
multivariate normal process model? If \code{TRUE} and if
\code{n_series > 1} in the supplied data, a fully structured covariance
matrix will be estimated for the process errors. Default is \code{FALSE}.
Note: For \code{VAR()} models, correlation is always enabled (\code{cor = TRUE})
as this is essential for optimal performance.}

\item{gr}{An optional grouping variable, which must be a \code{factor} in the
supplied \code{data}, for setting up hierarchical residual correlation
structures. If specified, this will automatically set \code{cor = TRUE} and set
up a model where the residual correlations for a specific level of \code{gr}
are modelled hierarchically:

\eqn{\Omega_{group} = \alpha_{cor}\Omega_{global} +
  (1 - \alpha_{cor})\Omega_{group, local}},

where \eqn{\Omega_{global}} is a \emph{global} correlation matrix,
\eqn{\Omega_{group, local}} is a \emph{local deviation} correlation matrix and
\eqn{\alpha_{cor}} is a weighting parameter controlling how strongly the
local correlation matrix \eqn{\Omega_{group}} is shrunk towards the global
correlation matrix \eqn{\Omega_{global}} (larger values of
\eqn{\alpha_{cor}} indicate a greater degree of shrinkage, i.e. a greater
degree of partial pooling).

When used within a \code{VAR()} model, this essentially sets up a hierarchical
panel vector autoregression where both the autoregressive and correlation
matrices are learned hierarchically. If \code{gr} is supplied then \code{subgr}
\emph{must} also be supplied.}

\item{subgr}{A subgrouping \code{factor} variable specifying which element in
\code{data} represents the different time series. Defaults to \code{series}, but
note that models that use the hierarchical correlations, where the
\code{subgr} time series are measured in each level of \code{gr}, \emph{should not}
include a \code{series} element in \code{data}. Rather, this element will be created
internally based on the supplied variables for \code{gr} and \code{subgr}.

For example, if you are modelling temporal counts for a group of species
(labelled as \code{species} in \code{data}) across three different geographical
regions (labelled as \code{region}), and you would like the residuals to be
correlated within regions, then you should specify \code{gr = region} and
\code{subgr = species}. Internally, \code{mvgam()} will create the \code{series} element
for the data using:

\code{series = interaction(group, subgroup, drop = TRUE)}}

\item{p}{A non-negative integer specifying the autoregressive (AR) order.
Default is \code{1}. Cannot currently be larger than \code{3} for \code{AR}
terms, and cannot be anything other than \code{1} for continuous time AR
(\code{CAR}) terms.}
}
\value{
An object of class \code{mvgam_trend}, which contains a list of
arguments to be interpreted by the parsing functions in \pkg{mvgam}.
}
\description{
Set up autoregressive or autoregressive moving average trend models in
\pkg{mvgam}. These functions do not evaluate their arguments â€“ they exist
purely to help set up a model with particular autoregressive trend models.
}
\details{
\strong{Important}: Only ONE trend constructor is allowed per \code{trend_formula}.
For complex temporal dynamics, use flexible parameters within a single trend type:
\itemize{
\item For seasonal patterns: \code{AR(p = c(1, 12))} instead of \code{RW() + AR(p = 12)}
\item For multiple time scales: \code{AR(p = c(1, 7, 30))} for daily, weekly, monthly
\item For multivariate dynamics: \code{VAR(p = 2)} captures cross-series relationships
}

Use \code{vignette("mvgam_overview")} to see the full details of
available stochastic trend types in \pkg{mvgam}, or view the rendered
version on the package website at:
https://nicholasjclark.github.io/mvgam/articles/mvgam_overview.html
}
\section{Parameter Naming Convention}{

All trend model parameters automatically receive a "_trend" suffix to prevent
naming conflicts with observation model parameters. For example:
\itemize{
\item \code{sigma} becomes \code{sigma_trend}
\item \code{theta} becomes \code{theta_trend} (when \code{ma = TRUE})
\item \code{Sigma} becomes \code{Sigma_trend} (when \code{cor = TRUE})
\item \code{ar[p]} becomes \code{ar_trend[p]} (for AR trends)
\item \code{A[p]} becomes \code{A_trend[p]} (for VAR trends)
}

This naming convention is applied consistently across all trend types and must
be considered when:
\itemize{
\item Specifying priors (use \code{prior(normal(0, 1), class = sigma_trend)})
\item Extracting parameters from fitted models
\item Creating custom trend types
}
}

\section{Custom Trend Development}{

When creating custom trend types, define parameters and bounds using their
base names (e.g., "sigma", "alpha"). The \code{process_trend_params()} function
will automatically add the "_trend" suffix and handle bounds consistently.

Example custom trend constructor pattern:
\preformatted{
custom_trend <- function(...) {
  # Define parameters with bounds using base names
  param_bounds <- list(
    decay = c(0, 1),
    amplitude = c(0, Inf),
    phase = NULL  # NULL means no bounds needed
  )
  
  # Process automatically
  processed <- process_trend_params(param_bounds)
  
  # Use in trend object
  structure(list(
    trend = "Custom",
    tpars = processed$tpars,  # c("decay_trend", "amplitude_trend")
    bounds = processed$bounds # list(decay_trend = c(0, 1), ...)
  ), class = "mvgam_trend")
}
}
}

\examples{
\donttest{
# Basic trend model usage with defaults (will issue warnings)
set.seed(0)
simdat <- sim_mvgam(
  T = 50,
  n_series = 3,
  prop_trend = 0.6
)
mod1 <- mvgam(
  y ~ s(season, bs = "cc"),
  trend_formula = ~ RW(),
  data = simdat$data_train,
  chains = 2,
  silent = 2
)

# Using custom time and series variable names with simulated data
set.seed(123)
weekly_data <- sim_mvgam(
  T = 52,
  n_series = 2,
  prop_trend = 0.5
)$data_train

# Rename variables to demonstrate custom naming
weekly_data$week <- weekly_data$time
weekly_data$species <- weekly_data$series
weekly_data$temp <- rnorm(nrow(weekly_data))

mod2 <- mvgam(
  y ~ temp,
  trend_formula = ~ AR(time = week, series = species, p = 1),
  data = weekly_data,
  chains = 2,
  silent = 2
)

# Seasonal AR model with multiple lags using portal_data
data(portal_data)
mod3 <- mvgam(
  captures ~ s(ndvi_ma12) + s(mintemp),
  trend_formula = ~ AR(p = c(1, 12)),  # Annual seasonality
  data = portal_data,
  family = nb(),
  chains = 2,
  silent = 2
)

# Hierarchical models with custom time and series variables
set.seed(456)
multisite_data <- rbind(
  sim_mvgam(T = 30, n_series = 3, prop_trend = 0.7)$data_train \%>\%
    dplyr::mutate(region = "north"),
  sim_mvgam(T = 30, n_series = 3, prop_trend = 0.7)$data_train \%>\%
    dplyr::mutate(region = "south")
) \%>\%
  dplyr::mutate(
    region = as.factor(region),
    unit_id = paste0(region, "_", series),
    timestep = time,
    temperature = rnorm(n())
  ) \%>\%
  dplyr::select(-series)  # Remove series for hierarchical structure

mod4 <- mvgam(
  y ~ temperature,
  trend_formula = ~ VAR(
    time = timestep,
    gr = region,
    subgr = unit_id,
    p = 2
  ),
  data = multisite_data,
  chains = 2,
  silent = 2
)

# Multiple species across sites using portal_data
portal_subset <- portal_data \%>\%
  dplyr::mutate(
    survey_date = time,
    species_site = series,
    count = captures,
    habitat = "grassland",
    temperature = mintemp
  )

mod5 <- mvgam(
  count ~ habitat + temperature,
  trend_formula = ~ RW(time = survey_date, series = species_site),
  data = portal_subset,
  family = nb(),
  chains = 2,
  silent = 2
)

# A short example to illustrate CAR(1) models
# Function to simulate CAR1 data with seasonality
sim_corcar1 <- function(n = 125,
                        phi = 0.5,
                        sigma = 2,
                        sigma_obs = 0.75) {
  # Sample irregularly spaced time intervals
  time_dis <- c(1, runif(n - 1, 0, 5))

  # Set up the latent dynamic process
  x <- vector(length = n)
  x[1] <- -0.3
  for (i in 2:n) {
    # Zero-distances will cause problems in sampling, so mvgam uses a
    # minimum threshold; this simulation function emulates that process
    if (time_dis[i] == 0) {
      x[i] <- rnorm(
        1,
        mean = (phi^1e-3) * x[i - 1],
        sd = sigma * sqrt((1 - phi^(2 * 1e-3)) / (1 - phi^2))
      )
    } else {
      x[i] <- rnorm(
        1,
        mean = (phi^time_dis[i]) * x[i - 1],
        sd = sigma * sqrt((1 - phi^(2 * time_dis[i])) / (1 - phi^2))
      )
    }
  }

  # Add 12-month seasonality
  cov1 <- sin(2 * pi * (1:n) / 12)
  cov2 <- cos(2 * pi * (1:n) / 12)
  beta1 <- runif(1, 0.3, 0.7)
  beta2 <- runif(1, 0.2, 0.5)
  seasonality <- beta1 * cov1 + beta2 * cov2

  # Take Gaussian observations with error and return
  data.frame(
    y = rnorm(n, mean = x + seasonality, sd = sigma_obs),
    season = rep(1:12, 20)[1:n],
    time = cumsum(time_dis)
  )
}

# Sample two time series
set.seed(99)
dat <- rbind(
  dplyr::bind_cols(
    sim_corcar1(phi = 0.65, sigma_obs = 0.55),
    data.frame(series = "series1")
  ),
  dplyr::bind_cols(
    sim_corcar1(phi = 0.8, sigma_obs = 0.35),
    data.frame(series = "series2")
  )
) \%>\%
  dplyr::mutate(series = as.factor(series))

# mvgam with CAR(1) trends and series-level seasonal smooths
mod <- mvgam(
  formula = y ~ -1,
  trend_formula = ~ s(season, bs = 'cc', k = 5, by = trend),
  trend_model = CAR(),
  priors = c(
    prior(exponential(3), class = sigma),
    prior(beta(4, 4), class = sigma_obs)
  ),
  data = dat,
  family = gaussian(),
  chains = 2,
  silent = 2
)

# View usual summaries and plots
summary(mod)
conditional_effects(mod, type = 'expected')
plot(mod, type = 'trend', series = 1)
plot(mod, type = 'trend', series = 2)
plot(mod, type = 'residuals', series = 1)
plot(mod, type = 'residuals', series = 2)
mcmc_plot(
  mod,
  variable = "ar1",
  regex = TRUE,
  type = "hist"
)

# Now an example illustrating hierarchical dynamics
set.seed(123)

# Simulate three species monitored in three different regions
simdat1 <- sim_mvgam(
  trend_model = VAR(),  # cor = TRUE is now automatic for VAR models
  prop_trend = 0.95,
  n_series = 3,
  mu = c(1, 2, 3)
)
simdat2 <- sim_mvgam(
  trend_model = VAR(),  # cor = TRUE is now automatic for VAR models
  prop_trend = 0.95,
  n_series = 3,
  mu = c(1, 2, 3)
)
simdat3 <- sim_mvgam(
  trend_model = VAR(),  # cor = TRUE is now automatic for VAR models
  prop_trend = 0.95,
  n_series = 3,
  mu = c(1, 2, 3)
)

# Set up the data but DO NOT include 'series'
all_dat <- rbind(
  simdat1$data_train \%>\%
    dplyr::mutate(region = "qld"),
  simdat2$data_train \%>\%
    dplyr::mutate(region = "nsw"),
  simdat3$data_train \%>\%
    dplyr::mutate(region = "vic")
) \%>\%
  dplyr::mutate(
    species = gsub("series", "species", series),
    species = as.factor(species),
    region = as.factor(region)
  ) \%>\%
  dplyr::arrange(series, time) \%>\%
  dplyr::select(-series)

# Check priors for a hierarchical AR1 model
get_mvgam_priors(
  formula = y ~ species,
  trend_model = AR(gr = region, subgr = species),
  data = all_dat
)

# Fit the model
mod <- mvgam(
  formula = y ~ species,
  trend_model = AR(gr = region, subgr = species),
  data = all_dat,
  chains = 2,
  silent = 2
)

# Check standard outputs
summary(mod)
conditional_effects(mod, type = "link")

# Inspect posterior estimates for the correlation weighting parameter
mcmc_plot(mod, variable = "alpha_cor", type = "hist")
}
}
\author{
Nicholas J Clark
}
